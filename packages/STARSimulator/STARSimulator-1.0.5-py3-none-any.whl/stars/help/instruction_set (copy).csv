"abs $t1,$t2             ",,Pseudo Instruction,"abs $t1,$t2             ",Absolute value : Set $t1 to absolute value of $t2 (algorithm from Hacker's Delight)
"abs.d $f2,$f4           ",Floating Point Absolute Value,"abs.fmt fd, fs","abs.d $f2,$f4           ","Floating point absolute value double precision : Set $f2 to absolute value of $f4, double precision"
"abs.s $f0,$f1           ",,,"abs.s $f0,$f1           ","Floating point absolute value single precision : Set $f0 to absolute value of $f1, single precision"
"add $t1,$t2,$t3         ",Add Word,"add rd, rs, rt ","add $t1,$t2,$t3         ",Addition with overflow : set $t1 to ($t2 plus $t3)
"add.d $f2,$f4,$f6       ",Floating Point Add,"add.fmt fd, fs, ft","add.d $f2,$f4,$f6       ",Floating point addition double precision : Set $f2 to double-precision floating point value of $f4 plus $f6
"add.s $f0,$f1,$f3       ",,,"add.s $f0,$f1,$f3       ",Floating point addition single precision : Set $f0 to single-precision floating point value of $f1 plus $f3
"addi $t1,$t2,-100       ",Add Immediate Word,"addi rt, rs, imm ","addi $t1,$t2,-100       ",Addition immediate with overflow : set $t1 to ($t2 plus signed 16-bit immediate)
"addi $t1,$t2,100000     ",,,"addi $t1,$t2,100000     ",Addition Immediate : set $t1 to ($t2 plus 32-bit immediate)
"addiu $t1,$t2,-100      ",Add Immediate Unsigned Word,"addiu rt, rs, imm","addiu $t1,$t2,-100      ","Addition immediate unsigned without overflow : set $t1 to ($t2 plus signed 16-bit immediate), no overflow"
"addiu $t1,$t2,100000    ",,,"addiu $t1,$t2,100000    ","Addition Immediate Unsigned: set $t1 to ($t2 plus 32-bit immediate), no overflow"
"addu $t1,$t2,$t3        ",Add Unsigned Word,"addu rd, rs, rt ","addu $t1,$t2,$t3        ","Addition unsigned without overflow : set $t1 to ($t2 plus $t3), no overflow"
"and $t1,$t2,$t3         ",And,"and rd, rs, rt ","and $t1,$t2,$t3         ",Bitwise AND : Set $t1 to bitwise AND of $t2 and $t3
"andi $t1,$t2,100        ",And Immediate,"andi rt, rs, imm","andi $t1,$t2,100        ",Bitwise AND immediate : Set $t1 to bitwise AND of $t2 and zero-extended 16-bit immediate
"andi $t1,$t2,100000     ",,,"andi $t1,$t2,100000     ",AND Immediate : set $t1 to ($t2 bitwise-AND 32-bit immediate)
b label                 ,Unconditional Branch,b offset (Pseudo Instruction),b label                 ,Branch : Branch to statement at label unconditionally
"bc1f 1,label            ",Branch on FP False,"bc1f cc, offset","bc1f 1,label            ","Branch if specified FP condition flag false (BC1F, not BCLF) : If Coprocessor 1 condition flag specified by immediate is false (zero) then branch to statement at label's address"
bc1f label              ,,bc1f offset (cc = 0 implied) ,bc1f label              ,"Branch if FP condition flag 0 false (BC1F, not BCLF) : If Coprocessor 1 condition flag 0 is false (zero) then branch to statement at label's address"
"bc1t 1,label            ",Branch on FP True,"bc1t cc, offset","bc1t 1,label            ","Branch if specified FP condition flag true (BC1T, not BCLT) : If Coprocessor 1 condition flag specified by immediate is true (one) then branch to statement at label's address"
bc1t label              ,,bc1t offset (cc = 0 implied) ,bc1t label              ,"Branch if FP condition flag 0 true (BC1T, not BCLT) : If Coprocessor 1 condition flag 0 is true (one) then branch to statement at label's address"
"beq $t1,$t2,label       ",Branch on Equal,"beq rs, rt, offset","beq $t1,$t2,label       ",Branch if equal : Branch to statement at label's address if $t1 and $t2 are equal
"beqz $t1,label          ",,Pseudo Instruction,"beqz $t1,label          ",Branch if EQual Zero : Branch to statement at label if $t1 is equal to zero
"bge $t1,$t2,label       ",,Pseudo Instruction,"bge $t1,$t2,label       ",Branch if Greater or Equal : Branch to statement at label if $t1 is greater or equal to $t2
"bgeu $t1,$t2,label      ",,Pseudo Instruction,"bgeu $t1,$t2,label      ",Branch if Greater or Equal Unsigned : Branch to statement at label if $t1 is greater or equal to $t2 (unsigned compare)
"bgez $t1,label          ",Branch on Greater Than or Equal to Zero,"bgez rs, offset","bgez $t1,label          ",Branch if greater than or equal to zero : Branch to statement at label's address if $t1 is greater than or equal to zero
"bgezal $t1,label        ",Branch on Greater Than or Equal to Zero and Link,"bgezal rs, offset","bgezal $t1,label        ","Branch if greater then or equal to zero and link : If $t1 is greater than or equal to zero, then set $ra to the Program Counter and branch to statement at label's address"
"bgt $t1,$t2,label       ",,Pseudo Instruction,"bgt $t1,$t2,label       ",Branch if Greater Than : Branch to statement at label if $t1 is greater than $t2
"bgtu $t1,$t2,label      ",,Pseudo Instruction,"bgtu $t1,$t2,label      ",Branch if Greater Than Unsigned: Branch to statement at label if $t1 is greater than $t2 (unsigned compare)
"bgtz $t1,label          ",Branch on Greater Than Zero,"bgtz rs, offset","bgtz $t1,label          ",Branch if greater than zero : Branch to statement at label's address if $t1 is greater than zero
"ble $t1,$t2,label       ",,Pseudo Instruction,"ble $t1,$t2,label       ",Branch if Less or Equal : Branch to statement at label if $t1 is less than or equal to $t2
"bleu $t1,$t2,label      ",,Pseudo Instruction,"bleu $t1,$t2,label      ",Branch if Less or Equal Unsigned : Branch to statement at label if $t1 is less than or equal to $t2 (unsigned compare)
"blez $t1,label          ",Branch on Less Than or Equal Zero,"blez rs, offset","blez $t1,label          ",Branch if less than or equal to zero : Branch to statement at label's address if $t1 is less than or equal to zero
"blt $t1,$t2,label       ",,Pseudo Instruction,"blt $t1,$t2,label       ",Branch if Less Than : Branch to statement at label if $t1 is less than $t2
"bltu $t1,$t2,label      ",,Pseudo Instruction,"bltu $t1,$t2,label      ",Branch if Less Than Unsigned : Branch to statement at label if $t1 is less than $t2
"bltz $t1,label          ",Branch on Less Than Zero,"bltz rs, offset","bltz $t1,label          ",Branch if less than zero : Branch to statement at label's address if $t1 is less than zero
"bltzal $t1,label        ",Branch on Less Than Zero and Link,"bltz rs, offset","bltzal $t1,label        ","Branch if less than zero and link : If $t1 is less than or equal to zero, then set $ra to the Program Counter and branch to statement at label's address"
"bne $t1,$t2,label       ",Branch on Not Equal,"bne rs, rt, offset","bne $t1,$t2,label       ",Branch if not equal : Branch to statement at label's address if $t1 and $t2 are not equal
"bnez $t1,label          ",,Pseudo Instruction,"bnez $t1,label          ",Branch if Not Equal Zero : Branch to statement at label if $t1 is not equal to zero
break                   ,Breakpoint,break code (code = 0 implied),break                   ,Break execution : Terminate program execution with exception
break 100               ,,,break 100               ,Break execution with code : Terminate program execution with specified exception code
"c.eq.d $f2,$f4          ",Floating Point Compare,"c.cond.fmt fs, ft (cc = 0 implied)","c.eq.d $f2,$f4          ","Compare equal double precision : If $f2 is equal to $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false"
"c.eq.d 1,$f2,$f4        ",," c.cond.fmt cc, fs, ft","c.eq.d 1,$f2,$f4        ","Compare equal double precision : If $f2 is equal to $f4 (double-precision), set Coprocessor 1 condition flag specified by immediate to true else set it to false"
"c.eq.s $f0,$f1          ",,,"c.eq.s $f0,$f1          ","Compare equal single precision : If $f0 is equal to $f1, set Coprocessor 1 condition flag 0 true else set it false"
"c.eq.s 1,$f0,$f1        ",,,"c.eq.s 1,$f0,$f1        ","Compare equal single precision : If $f0 is equal to $f1, set Coprocessor 1 condition flag specied by immediate to true else set it to false"
"c.le.d $f2,$f4          ",,,"c.le.d $f2,$f4          ","Compare less or equal double precision : If $f2 is less than or equal to $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false"
"c.le.d 1,$f2,$f4        ",,,"c.le.d 1,$f2,$f4        ","Compare less or equal double precision : If $f2 is less than or equal to $f4 (double-precision), set Coprocessor 1 condition flag specfied by immediate true else set it false"
"c.le.s $f0,$f1          ",,,"c.le.s $f0,$f1          ","Compare less or equal single precision : If $f0 is less than or equal to $f1, set Coprocessor 1 condition flag 0 true else set it false"
"c.le.s 1,$f0,$f1        ",,,"c.le.s 1,$f0,$f1        ","Compare less or equal single precision : If $f0 is less than or equal to $f1, set Coprocessor 1 condition flag specified by immediate to true else set it to false"
"c.lt.d $f2,$f4          ",,,"c.lt.d $f2,$f4          ","Compare less than double precision : If $f2 is less than $f4 (double-precision), set Coprocessor 1 condition flag 0 true else set it false"
"c.lt.d 1,$f2,$f4        ",,,"c.lt.d 1,$f2,$f4        ","Compare less than double precision : If $f2 is less than $f4 (double-precision), set Coprocessor 1 condition flag specified by immediate to true else set it to false"
"c.lt.s $f0,$f1          ",,,"c.lt.s $f0,$f1          ","Compare less than single precision : If $f0 is less than $f1, set Coprocessor 1 condition flag 0 true else set it false"
"c.lt.s 1,$f0,$f1        ",,,"c.lt.s 1,$f0,$f1        ","Compare less than single precision : If $f0 is less than $f1, set Coprocessor 1 condition flag specified by immediate to true else set it to false"
"ceil.w.d $f1,$f2        ",Fixed Point Ceiling Convert to Word Fixed Point,"ceil.w.fmt fd, fs","ceil.w.d $f1,$f2        ",Ceiling double precision to word : Set $f1 to 32-bit integer ceiling of double-precision float in $f2
"ceil.w.s $f0,$f1        ",,,"ceil.w.s $f0,$f1        ",Ceiling single precision to word : Set $f0 to 32-bit integer ceiling of single-precision float in $f1
"clo $t1,$t2             ",Count Leading Ones in Word,"clo rd, rs","clo $t1,$t2             ",Count number of leading ones : Set $t1 to the count of leading one bits in $t2 starting at most significant bit position
"clz $t1,$t2             ",Count Leading Zeroes in Word,"clz rd, rs","clz $t1,$t2             ",Count number of leading zeroes : Set $t1 to the count of leading zero bits in $t2 starting at most significant bit positio
"cvt.d.s $f2,$f1         ",Floating Point Convert to Double Floating Point,"cvt.d.fmt fd, fs","cvt.d.s $f2,$f1         ",Convert from single precision to double precision : Set $f2 to double precision equivalent of single precision value in $f1
"cvt.d.w $f2,$f1         ",,,"cvt.d.w $f2,$f1         ",Convert from word to double precision : Set $f2 to double precision equivalent of 32-bit integer value in $f1
"cvt.s.d $f1,$f2         ",Floating Point Convert to Single Floating Point,"cvt.s.fmt fd, fs","cvt.s.d $f1,$f2         ",Convert from double precision to single precision : Set $f1 to single precision equivalent of double precision value in $f2
"cvt.s.w $f0,$f1         ",,,"cvt.s.w $f0,$f1         ",Convert from word to single precision : Set $f0 to single precision equivalent of 32-bit integer value in $f2
"cvt.w.d $f1,$f2         ",Floating Point Convert to Word Fixed Point,"cvt.w.fmt fd, fs","cvt.w.d $f1,$f2         ",Convert from double precision to word : Set $f1 to 32-bit integer equivalent of double precision value in $f2
"cvt.w.s $f0,$f1         ",,,"cvt.w.s $f0,$f1         ",Convert from single precision to word : Set $f0 to 32-bit integer equivalent of single precision value in $f1
"div $t1,$t2             ",Divide Word,"div rs, rt","div $t1,$t2             ","Division with overflow : Divide $t1 by $t2 then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)"
"div.d $f2,$f4,$f6       ",Floating Point Divide,"div.fmt fd, fs, ft","div.d $f2,$f4,$f6       ",Floating point division double precision : Set $f2 to double-precision floating point value of $f4 divided by $f6
"div.s $f0,$f1,$f3       ",,,"div.s $f0,$f1,$f3       ",Floating point division single precision : Set $f0 to single-precision floating point value of $f1 divided by $f3
"divu $t1,$t2            ",Divide Unsigned Word,"divu rs, rt","divu $t1,$t2            ","Division unsigned without overflow : Divide unsigned $t1 by $t2 then set LO to quotient and HI to remainder (use mfhi to access HI, mflo to access LO)"
"floor.w.d $f1,$f2       ",Floating Point Floor Convert to Word Fixed Point ,"floor.w.fmt fd, fs","floor.w.d $f1,$f2       ",Floor double precision to word : Set $f1 to 32-bit integer floor of double-precision float in $f2
"floor.w.s $f0,$f1       ",,,"floor.w.s $f0,$f1       ",Floor single precision to word : Set $f0 to 32-bit integer floor of single-precision float in $f1
j target                ,Jump,j target,j target                ,Jump unconditionally : Jump to statement at target address
jal target              ,Jump and Link,,jal target              ,Jump and link : Set $ra to Program Counter (return address) then jump to statement at target address
jalr $t1                ,Jump and Link Register,jalr rs (rd = 31($ra) implied),jalr $t1                ,Jump and link register : Set $ra to Program Counter (return address) then jump to statement whose address is in $t1
"# jalr $t1,$t2      ????      ",,"jalr rd, rs","jalr $t1,$t2            ",Jump and link register : Set $t1 to Program Counter (return address) then jump to statement whose address is in $t2
jr $t1                  ,Jump Register,jr rs,jr $t1                  ,Jump register unconditionally : Jump to statement whose address is in $t1
"l.d $f2,($t2)           ",,,"l.d $f2,($t2)           ",Load floating point Double precision : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address
"l.d $f2,100000($t2)     ",,,"l.d $f2,100000($t2)     ",Load floating point Double precision : Set $f2 and $f3 register pair to 64-bit value at effective memory doubleword address
"l.s $f1,($t2)           ",,,"l.s $f1,($t2)           ",Load floating point Single precision : Set $f1 to 32-bit value at effective memory word address
"l.s $f1,100000($t2)     ",,,"l.s $f1,100000($t2)     ",Load floating point Single precision : Set $f1 to 32-bit value at effective memory word address
"la $t1,label            ",,Pseudo Instruction,"la $t1,label            ",Load Address : Set $t1 to label's address
"lb $t1,($t2)            ",Load Byte,"lb rt, offset(base)","lb $t1,($t2)            ",Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address
"lb $t1,-100($t2)        ",,,"lb $t1,-100($t2)        ",Load byte : Set $t1 to sign-extended 8-bit value from effective memory byte address
"lb $t1,100($t2)         ",,,"lb $t1,100($t2)         ",Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address
"lb $t1,100000($t2)      ",,,"lb $t1,100000($t2)      ",Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address
"lb $t1,label            ",,,"lb $t1,label            ",Load Byte : Set $t1 to sign-extended 8-bit value from effective memory byte address
"lbu $t1,($t2)           ",Load Byte Unsigned,"lbu rt, offset(base)","lbu $t1,($t2)           ",Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address
"lbu $t1,-100($t2)       ",,,"lbu $t1,-100($t2)       ",Load byte unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address
"lbu $t1,100($t2)        ",,,"lbu $t1,100($t2)        ",Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address
"lbu $t1,100000($t2)     ",,,"lbu $t1,100000($t2)     ",Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address
"lbu $t1,label           ",,,"lbu $t1,label           ",Load Byte Unsigned : Set $t1 to zero-extended 8-bit value from effective memory byte address
"lh $t1,($t2)            ",Load Halfword,"lh rt, offset(base)","lh $t1,($t2)            ",Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address
"lh $t1,-100($t2)        ",,,"lh $t1,-100($t2)        ",Load halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address
"lh $t1,100($t2)         ",,,"lh $t1,100($t2)         ",Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address
"lh $t1,100000($t2)      ",,,"lh $t1,100000($t2)      ",Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address
"lh $t1,label            ",,,"lh $t1,label            ",Load Halfword : Set $t1 to sign-extended 16-bit value from effective memory halfword address
"lhu $t1,($t2)           ",Load Halfword Unsigned,"lhu rt, offset(base)","lhu $t1,($t2)           ",Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address
"lhu $t1,-100($t2)       ",,,"lhu $t1,-100($t2)       ",Load halfword unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address
"lhu $t1,100($t2)        ",,,"lhu $t1,100($t2)        ",Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address
"lhu $t1,100000($t2)     ",,,"lhu $t1,100000($t2)     ",Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address
"lhu $t1,label           ",,,"lhu $t1,label           ",Load Halfword Unsigned : Set $t1 to zero-extended 16-bit value from effective memory halfword address
"li $t1,-100             ",,Pseudo Instruction,"li $t1,-100             ",Load Immediate : Set $t1 to 16-bit immediate (sign-extended)
"li $t1,100              ",,,"li $t1,100              ",Load Immediate : Set $t1 to unsigned 16-bit immediate (zero-extended)
"li $t1,100000           ",,,"li $t1,100000           ",Load Immediate : Set $t1 to 32-bit immediate
"lui $t1,100             ", Load Upper Immediate,"lui rt, immediate","lui $t1,100             ",Load upper immediate : Set high-order 16 bits of $t1 to 16-bit immediate and low-order 16 bits to 0
"lw $t1,($t2)            ",Load Word ,"lw rt, offset(base)","lw $t1,($t2)            ",Load Word : Set $t1 to contents of effective memory word address
"lw $t1,-100($t2)        ",,,"lw $t1,-100($t2)        ",Load word : Set $t1 to contents of effective memory word address
"lw $t1,100($t2)         ",,,"lw $t1,100($t2)         ",Load Word : Set $t1 to contents of effective memory word address
"lw $t1,100000($t2)      ",,,"lw $t1,100000($t2)      ",Load Word : Set $t1 to contents of effective memory word address
"lw $t1,label            ",,,"lw $t1,label            ",Load Word : Set $t1 to contents of memory word at label's address
"lwl $t1,($t2)           ",Load Word Left,"lwl rt, offset(base)","lwl $t1,($t2)           ","Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
"lwl $t1,-100($t2)       ",,,"lwl $t1,-100($t2)       ","Load word left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
"lwl $t1,100($t2)        ",,,"lwl $t1,100($t2)        ","Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
"lwl $t1,100000($t2)     ",,,"lwl $t1,100000($t2)     ","Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
"lwl $t1,label           ",,,"lwl $t1,label           ","Load Word Left : Load from 1 to 4 bytes left-justified into $t1, starting with effective memory byte address and continuing through the low-order byte of its word"
"lwr $t1,($t2)           ",Load Word Right,"lwr rt, offset(base)","lwr $t1,($t2)           ","Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
"lwr $t1,-100($t2)       ",,,"lwr $t1,-100($t2)       ","Load word right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
"lwr $t1,100($t2)        ",,,"lwr $t1,100($t2)        ","Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
"lwr $t1,100000($t2)     ",,,"lwr $t1,100000($t2)     ","Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
"lwr $t1,label           ",,,"lwr $t1,label           ","Load Word Right : Load from 1 to 4 bytes right-justified into $t1, starting with effective memory byte address and continuing through the high-order byte of its word"
"madd $t1,$t2            ","Multiply and Add Word to HI, LO","madd rs, rt","madd $t1,$t2            ","Multiply add : Multiply $t1 by $t2 then increment HI by high-order 32 bits of product, increment LO by low-order 32 bits of product (use mfhi to access HI, mflo to access LO)"
"maddu $t1,$t2           ","Multiply and Add Unsigned Word to HI, LO","maddu rs, rt","maddu $t1,$t2           ","Multiply add unsigned : Multiply $t1 by $t2 then increment HI by high-order 32 bits of product, increment LO by low-order 32 bits of product, unsigned (use mfhi to access HI, mflo to access LO)"
"mfc1 $t1,$f1            ",Move Word From Floating Point,"mfc1 rt, fs","mfc1 $t1,$f1            ",Move from Coprocessor 1 (FPU) : Set $t1 to value in Coprocessor 1 register $f1
mfhi $t1                ,Move from HI Register,mfhi rd,mfhi $t1                ,Move from HI register : Set $t1 to contents of HI (see multiply and divide operations)
mflo $t1                ,Move from LO Register,mflo rd,mflo $t1                ,Move from LO register : Set $t1 to contents of LO (see multiply and divide operations)
"mov.d $f2,$f4           ",Floating Point Move,"mov.fmt fd, fs","mov.d $f2,$f4           ",Move floating point double precision : Set double precision $f2 to double precision value in $f4
"mov.s $f0,$f1           ",,,"mov.s $f0,$f1           ",Move floating point single precision : Set single precision $f0 to single precision value in $f1
"move $t1,$t2            ",,Pseudo Instruction,"move $t1,$t2            ",MOVE : Set $t1 to contents of $t2
"movf $t1,$t2            ",Move Conditional on Floating Point False,"movf rd, rs, cc (cc = 0 is implied)","movf $t1,$t2            ",Move if FP condition flag 0 false : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag 0 is false (zero)
"movf $t1,$t2,1          ",,,"movf $t1,$t2,1          ",Move if specified FP condition flag false : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag specified by the immediate is false (zero)
"movf.d $f2,$f4          ",Floating Point Move Conditional on Floating Point False,"movf.fmt fd, fs, cc (cc = 0 is implied)","movf.d $f2,$f4          ","Move floating point double precision : If condition flag 0 false, set double precision $f2 to double precision value in $f4"
"movf.d $f2,$f4,1        ",,,"movf.d $f2,$f4,1        ","Move floating point double precision : If condition flag specified by immediate is false, set double precision $f2 to double precision value in $f4"
"movf.s $f0,$f1          ",,,"movf.s $f0,$f1          ","Move floating point single precision : If condition flag 0 is false, set single precision $f0 to single precision value in $f1"
"movf.s $f0,$f1,1        ",,,"movf.s $f0,$f1,1        ","Move floating point single precision : If condition flag specified by immediate is false, set single precision $f0 to single precision value in $f1e"
"movn $t1,$t2,$t3        ",Move Conditional On Not Zero,"movn rd, rs, rt","movn $t1,$t2,$t3        ",Move conditional not zero : Set $t1 to $t2 if $t3 is not zero
"movn.d $f2,$f4,$t3      ",Floating Point Move Conditional On Not Zero,"movn.fmt fd, fs, rt","movn.d $f2,$f4,$t3      ","Move floating point double precision : If $t3 is not zero, set double precision $f2 to double precision value in $f4"
"movn.s $f0,$f1,$t3      ",,,"movn.s $f0,$f1,$t3      ","Move floating point single precision : If $t3 is not zero, set single precision $f0 to single precision value in $f1"
"movt $t1,$t2            ",Move Conditional on Floating Point True,"movt rd, rs, cc (cc = 0 is implied)","movt $t1,$t2            ",Move if FP condition flag 0 true : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag 0 is true (one)
"movt $t1,$t2,1          ",,,"movt $t1,$t2,1          ",Move if specfied FP condition flag true : Set $t1 to $t2 if FPU (Coprocessor 1) condition flag specified by the immediate is true (one)
"movt.d $f2,$f4          ",Floating Point Move Conditional on Floating Point True,"movt.fmt fd, fs, cc (cc = 0 is implied)","movt.d $f2,$f4          ","Move floating point double precision : If condition flag 0 true, set double precision $f2 to double precision value in $f4"
"movt.d $f2,$f4,1        ",,,"movt.d $f2,$f4,1        ","Move floating point double precision : If condition flag specified by immediate is true, set double precision $f2 to double precision value in $f4e"
"movt.s $f0,$f1          ",,,"movt.s $f0,$f1          ","Move floating point single precision : If condition flag 0 is true, set single precision $f0 to single precision value in $f1e"
"movt.s $f0,$f1,1        ",,,"movt.s $f0,$f1,1        ","Move floating point single precision : If condition flag specified by immediate is true, set single precision $f0 to single precision value in $f1e"
"movz $t1,$t2,$t3        ",Move Conditional On Zero,"movz rd, rs, rt","movz $t1,$t2,$t3        ",Move conditional zero : Set $t1 to $t2 if $t3 is zero
"movz.d $f2,$f4,$t3      ",Floating Point Move Conditional On Zero,"movz.fmt fd, fs, rt","movz.d $f2,$f4,$t3      ","Move floating point double precision : If $t3 is zero, set double precision $f2 to double precision value in $f4"
"movz.s $f0,$f1,$t3      ",,,"movz.s $f0,$f1,$t3      ","Move floating point single precision : If $t3 is zero, set single precision $f0 to single precision value in $f1"
"msub $t1,$t2            ","Multiply and Subtract Word to HI, LO","msub rs, rt","msub $t1,$t2            ","Multiply subtract : Multiply $t1 by $t2 then decrement HI by high-order 32 bits of product, decrement LO by low-order 32 bits of product (use mfhi to access HI, mflo to access LO)"
"msubu $t1,$t2           ","Multiply and Subtract Unsigned Word to HI, LO","msubu rs, rt","msubu $t1,$t2           ","Multiply subtract unsigned : Multiply $t1 by $t2 then decrement HI by high-order 32 bits of product, decement LO by low-order 32 bits of product, unsigned (use mfhi to access HI, mflo to access LO)"
"mtc1 $t1,$f1            ",Move Word to Floating Point,"mfc1 rt, fs","mtc1 $t1,$f1            ",Move to Coprocessor 1 (FPU) : Set Coprocessor 1 register $f1 to value in $t1
mthi $t1                ,Move to HI Register,mthi rs,mthi $t1                ,Move to HI registerr : Set HI to contents of $t1 (see multiply and divide operations)
mtlo $t1                ,Move to LO Register,mtlo rs,mtlo $t1                ,Move to LO register : Set LO to contents of $t1 (see multiply and divide operations)
"mul $t1,$t2,$t3         ",Multiply Word to Register,"mul rd, rs, rt","mul $t1,$t2,$t3         ","Multiplication without overflow  : Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t2 and $t3 (use mfhi to access HI, mflo to access LO)"
"mul.d $f2,$f4,$f6       ",Floating Point Multiply,"mul.fmt fd, fs, ft ","mul.d $f2,$f4,$f6       ",Floating point multiplication double precision : Set $f2 to double-precision floating point value of $f4 times $f6
"mul.s $f0,$f1,$f3       ",,,"mul.s $f0,$f1,$f3       ",Floating point multiplication single precision : Set $f0 to single-precision floating point value of $f1 times $f3
"mult $t1, $t2",Multiply Word,"mult rs, rt",,"Multiplication: Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of $t1 and $t2 (use mfhi to access HI, mflo to access LO)"
"multu $t1, $t2",Multiply Unsigned Word,"multu rs, rt",,"Multiplication unsigned: Set HI to high-order 32 bits, LO and $t1 to low-order 32 bits of the product of unsigned $t1 and $t2 (use mfhi to access HI, mflo to access LO)"
"neg $t1,$t2             ",,Pseudo Instruction,"neg $t1,$t2             ",Negate : Set $t1 to negation of $t2
"neg.d $f2,$f4           ",Floating Point Negate,"neg.fmt fd, fs","neg.d $f2,$f4           ",Floating point negate double precision : Set double precision $f2 to negation of double precision value in $f4
"neg.s $f0,$f1           ",,,"neg.s $f0,$f1           ",Floating point negate single precision : Set single precision $f0 to negation of single precision value in $f1
nop                     ,No Operation,nop,nop                     ,Null operation : machine code is all zeroes
"nor $t1,$t2,$t3         ",Not Or,"nor rd, rs, rt","nor $t1,$t2,$t3         ",Bitwise NOR : Set $t1 to bitwise NOR of $t2 and $t3
"not $t1,$t2             ",,Pseudo Instruction,"not $t1,$t2             ",Bitwise NOT (bit inversion)
"or $t1,$t2,$t3          ",Or,"or rd, rs, rt","or $t1,$t2,$t3          ",Bitwise OR : Set $t1 to bitwise OR of $t2 and $t3
"ori $t1,$t2,100         ",Or Immediate,"or rt, rs, imm","ori $t1,$t2,100         ",Bitwise OR immediate : Set $t1 to bitwise OR of $t2 and zero-extended 16-bit immediate
"ori $t1,$t2,100000      ",,,"ori $t1,$t2,100000      ",OR Immediate : set $t1 to ($t2 bitwise-OR 32-bit immediate)
"rol $t1,$t2,10          ",,Pseudo Instruction,"rol $t1,$t2,10          ",ROtate Left : Set $t1 to ($t2 rotated left by number of bit positions specified in 5-bit immediate)
"ror $t1,$t2,10          ",,Pseudo Instruction,"ror $t1,$t2,10          ",ROtate Right : Set $t1 to ($t2 rotated right by number of bit positions specified in 5-bit immediate)
"round.w.d $f1,$f2       ",Floating Point Round to Word Fixed Point,"round.w.fmt fd, fs","round.w.d $f1,$f2       ",Round double precision to word : Set $f1 to 32-bit integer round of double-precision float in $f2
"round.w.s $f0,$f1       ",,,"round.w.s $f0,$f1       ",Round single precision to word : Set $f0 to 32-bit integer round of single-precision float in $f1
"s.d $f2,($t2)           ",,,"s.d $f2,($t2)           ",Store floating point Double precision : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address
"s.d $f2,100000($t2)     ",,,"s.d $f2,100000($t2)     ",Store floating point Double precision : Store 64 bits from $f2 and $f3 register pair to effective memory doubleword address
"s.s $f1,($t2)           ",,,"s.s $f1,($t2)           ",Store floating point Single precision : Store 32-bit value from $f1 to effective memory word address
"s.s $f1,100000($t2)     ",,,"s.s $f1,100000($t2)     ",Store floating point Single precision : Store 32-bit value from $f1 to effective memory word address
"sb $t1,($t2)            ",Store Byte,"sb rt, offset(base)","sb $t1,($t2)            ",Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address
"sb $t1,-100($t2)        ",,,"sb $t1,-100($t2)        ",Store byte : Store the low-order 8 bits of $t1 into the effective memory byte address
"sb $t1,100($t2)         ",,,"sb $t1,100($t2)         ",Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address
"sb $t1,100000($t2)      ",,,"sb $t1,100000($t2)      ",Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address
"sb $t1,label            ",,,"sb $t1,label            ",Store Byte : Store the low-order 8 bits of $t1 into the effective memory byte address
"seq $t1,$t2,$t3         ",,Pseudo Instruction,"seq $t1,$t2,$t3         ",Set Equal : if $t2 equal to $t3 then set $t1 to 1 else 0
"sge $t1,$t2,$t3         ",,Pseudo Instruction,"sge $t1,$t2,$t3         ",Set Greater or Equal : if $t2 greater or equal to $t3 then set $t1 to 1 else 0
"sgeu $t1,$t2,$t3        ",,Pseudo Instruction,"sgeu $t1,$t2,$t3        ",Set Greater or Equal Unsigned : if $t2 greater or equal to $t3 (unsigned compare) then set $t1 to 1 else 0
"sgt $t1,$t2,$t3         ",,Pseudo Instruction,"sgt $t1,$t2,$t3         ",Set Greater Than : if $t2 greater than $t3 then set $t1 to 1 else 0
"sgtu $t1,$t2,$t3        ",,Pseudo Instruction,"sgtu $t1,$t2,$t3        ",Set Greater Than Unsigned : if $t2 greater than $t3 (unsigned compare) then set $t1 to 1 else 0
"sh $t1,($t2)            ",Store Halfword,"sh rt, offset(base)","sh $t1,($t2)            ",Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address
"sh $t1,-100($t2)        ",,,"sh $t1,-100($t2)        ",Store halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address
"sh $t1,100($t2)         ",,,"sh $t1,100($t2)         ",Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address
"sh $t1,100000($t2)      ",,,"sh $t1,100000($t2)      ",Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address
"sh $t1,label            ",,,"sh $t1,label            ",Store Halfword : Store the low-order 16 bits of $t1 into the effective memory halfword address
"sle $t1,$t2,$t3         ",,Pseudo Instruction,"sle $t1,$t2,$t3         ",Set Less or Equal : if $t2 less or equal to $t3 then set $t1 to 1 else 0
"sleu $t1,$t2,$t3        ",,Pseudo Instruction,"sleu $t1,$t2,$t3        ",Set Less or Equal Unsigned: if $t2 less or equal to $t3 (unsigned compare) then set $t1 to 1 else 0
"sll $t1,$t2,10          ",Shift Word Left Logical,"sll rd, rt, sa","sll $t1,$t2,10          ",Shift left logical : Set $t1 to result of shifting $t2 left by number of bits specified by immediate
"sllv $t1,$t2,$t3        ",Shift Word Left Logical Variable,"sllv rd, rt, rs","sllv $t1,$t2,$t3        ",Shift left logical variable : Set $t1 to result of shifting $t2 left by number of bits specified by value in low-order 5 bits of $t3
"slt $t1,$t2,$t3         ",Set on Less Than,"slt rd, rs, rt","slt $t1,$t2,$t3         ","Set less than : If $t2 is less than $t3, then set $t1 to 1 else set $t1 to 0"
"slti $t1,$t2,-100       ",Set on Less Than Immediate,"slti rt, rs, immediate","slti $t1,$t2,-100       ","Set less than immediate : If $t2 is less than sign-extended 16-bit immediate, then set $t1 to 1 else set $t1 to 0"
"sltiu $t1,$t2,-100      ",Set on Less Than Immediate Unsigned,"sltiu rt, rs, immediate","sltiu $t1,$t2,-100      ","Set less than immediate unsigned : If $t2 is less than  sign-extended 16-bit immediate using unsigned comparison, then set $t1 to 1 else set $t1 to 0"
"sltu $t1,$t2,$t3        ",Set on Less Than Unsigned,"sltu rd, rs, rt","sltu $t1,$t2,$t3        ","Set less than unsigned : If $t2 is less than $t3 using unsigned comparision, then set $t1 to 1 else set $t1 to 0"
"sne $t1,$t2,$t3         ",,Pseudo Instruction,"sne $t1,$t2,$t3         ",Set Not Equal : if $t2 not equal to $t3 then set $t1 to 1 else 0
"sqrt.d $f2,$f4          ",Floating Point Square Root,"sqrt.fmt fd, fs","sqrt.d $f2,$f4          ",Square root double precision : Set $f2 to double-precision floating point square root of $f4
"sqrt.s $f0,$f1          ",,,"sqrt.s $f0,$f1          ",Square root single precision : Set $f0 to single-precision floating point square root of $f1
"sra $t1,$t2,10          ",Shift Word Right Arithmetic,"sra rd, rt, sa","sra $t1,$t2,10          ",Shift right arithmetic : Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by immediate
"srav $t1,$t2,$t3        ",Shift Word Right Arithmetic Variable,"srav rd, rt, rs","srav $t1,$t2,$t3        ",Shift right arithmetic variable : Set $t1 to result of sign-extended shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3
"srl $t1,$t2,10          ",Shift Word Right Logical,"srl rd, rt, sa","srl $t1,$t2,10          ",Shift right logical : Set $t1 to result of shifting $t2 right by number of bits specified by immediate
"srlv $t1,$t2,$t3        ",Shift Word Right Logical Variable,"srlv rd, rt, rs","srlv $t1,$t2,$t3        ",Shift right logical variable : Set $t1 to result of shifting $t2 right by number of bits specified by value in low-order 5 bits of $t3
"sub $t1,$t2,$t3         ",Subtract Word,"sub rd, rs, rt","sub $t1,$t2,$t3         ",Subtraction with overflow : set $t1 to ($t2 minus $t3)
"sub.d $f2,$f4,$f6       ",Floating Point Subtract,"sub.fmt fd, fs, ft","sub.d $f2,$f4,$f6       ",Floating point subtraction double precision : Set $f2 to double-precision floating point value of $f4 minus $f6
"sub.s $f0,$f1,$f3       ",,,"sub.s $f0,$f1,$f3       ",Floating point subtraction single precision : Set $f0 to single-precision floating point value of $f1  minus $f3
"subu $t1,$t2,$t3        ",Subtract Unsigned Word,"subu rd, rs, rt","subu $t1,$t2,$t3        ","Subtraction unsigned without overflow : set $t1 to ($t2 minus $t3), no overflow"
"sw $t1,($t2)            ",Store Word,"sw rt, offset(base)","sw $t1,($t2)            ",Store Word : Store $t1 contents into effective memory word address
"sw $t1,-100($t2)        ",,,"sw $t1,-100($t2)        ",Store word : Store contents of $t1 into effective memory word address
"sw $t1,100($t2)         ",,,"sw $t1,100($t2)         ",Store Word : Store $t1 contents into effective memory word address
"sw $t1,100000($t2)      ",,,"sw $t1,100000($t2)      ",Store Word : Store $t1 contents into effective memory word address
"sw $t1,label            ",,,"sw $t1,label            ",Store Word : Store $t1 contents into memory word at label's address
"swl $t1,($t2)           ",Store Word Left,"swl rt, offset(base)","swl $t1,($t2)           ","Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
"swl $t1,-100($t2)       ",,,"swl $t1,-100($t2)       ","Store word left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective byte address and continuing through the low-order byte of its word"
"swl $t1,100($t2)        ",,,"swl $t1,100($t2)        ","Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
"swl $t1,100000($t2)     ",,,"swl $t1,100000($t2)     ","Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
"swl $t1,label           ",,,"swl $t1,label           ","Store Word Left : Store high-order 1 to 4 bytes of $t1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word"
"swr $t1,($t2)           ",Store Word Right,"swr rt, offset(base)","swr $t1,($t2)           ","Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
"swr $t1,-100($t2)       ",,,"swr $t1,-100($t2)       ","Store word right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective byte address and continuing through that byte address"
"swr $t1,100($t2)        ",,,"swr $t1,100($t2)        ","Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
"swr $t1,100000($t2)     ",,,"swr $t1,100000($t2)     ","Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
"swr $t1,label           ",,,"swr $t1,label           ","Store Word Right : Store low-order 1 to 4 bytes of $t1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address"
syscall                 ,,,syscall                 ,Issue a system call : Execute the system call specified by value in $v0
"trunc.w.d $f1,$f2       ",Floating Point Truncate to Word Fixed Point,"trunc.w.fmt fd, fs","trunc.w.d $f1,$f2       ",Truncate double precision to word : Set $f1 to 32-bit integer truncation of double-precision float in $f2
"trunc.w.s $f0,$f1       ",,,"trunc.w.s $f0,$f1       ",Truncate single precision to word : Set $f0 to 32-bit integer truncation of single-precision float in $f1
"xor $t1,$t2,$t3         ",Exclusive OR,"xor rd, rs, rt","xor $t1,$t2,$t3         ",Bitwise XOR (exclusive OR) : Set $t1 to bitwise XOR of $t2 and $t3
"xori $t1,$t2,100        ",Exclusive OR Immediate,"xor rt, rs, immediate","xori $t1,$t2,100        ",Bitwise XOR immediate : Set $t1 to bitwise XOR of $t2 and zero-extended 16-bit immediate
"xori $t1,$t2,100000     ",,,"xori $t1,$t2,100000     ",XOR Immediate : set $t1 to ($t2 bitwise-exclusive-OR 32-bit immediate)
