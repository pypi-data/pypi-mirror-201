# -*- coding: utf-8 -*-
"""anl_meercat_library_flashx.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_0Y_1cAb84sUZIaEqhmxKEL7HHb7cBtk

"""

import os, sys

def splitall(path):
    allparts = []
    while 1:
        head, tail = os.path.split(path)
        if head == path:  # sentinel for absolute paths
            allparts.insert(0, head)
            break
        elif tail == path: # sentinel for relative paths
            allparts.insert(0, tail)
            break
        else:
            path = head
            allparts.insert(0, tail)
    return allparts

os.path.split('source/')

os.path.splitext('1@2.')

#global for now - probably could move into check_file_documentation
units = [
    "Driver",
    "Grid",
    "Multispecies",
    "Particles",
    "PhysicalConstants",
    "RuntimeParameters",
    "Simulation",
    "MoL",
]

doc_extensions_to_check = ['.F90', '.dox']  #might add more types later, e.g., .md files
  filenames_to_check = []

#Auxilliary function used by check_file_documentation.
#General idea is that some files do not have checking unabled so skip over them.

def is_file_documentation_checkable(lines:list, path:str) -> tuple:
  assert isinstance(lines, list)
  assert all([isinstance(x,str) for x in lines])
  assert isinstance(path,str)

  global doc_extensions_to_check
  global filenames_to_check

  try:
    the_file = os.path.split(path)[1]  #the tail has the file name
  except:
    return (False, f'path not parsable: {path}')
  
  if the_file=='':
    return (False, f'path does not include file: {path}')

  try:
    name, extension = os.path.splitext(the_file)
  except:
    return (False, f'file not parsable: {the_file}')

  #first check extension and possibly filename as being listed as checkable
  if extension:
    if extension in doc_extensions_to_check:
      pass
    else:
      return (False, f'File of type {extension} currently not checkable')
  elif name in filenames_to_check:
    pass  #no extension but filename listed as checkable
  else:
    return (False, f"No extension and specific file name {name} not checkable.")

  #Below is Flash-X specific

  if extension=='.dox': return (True, '')  #currently no restrictions on dox files
  
  if extension == '.F90':
    '''
    There are 4 types of F90 files that we will eventually want to check in Flash-X:
      1. Single subroutine per file
      2. Multiple subroutines per file
      3. Module(s)
      4. Mixture of subroutines and modules

    At moment, only dealing with the first, a file with a single subroutine defined.
    Will add more cases later.
    '''
    subs = [line for line in lines if line.startswith('subroutine ')]
    mods = [line for line in lines if line.startswith('module ')]
    return (False, f'Only checking files with a single subroutine currently') if (len(subs) != 1 or len(mods) != 0) else (True, '')

  #checks for other things eventually here, e.g., md, config or toml files.

  return (True, '')

"""#Need directory structure for checking private files

Assume MeerCat calls this function.
"""

dir_struct = None  #assume MeerCat will set this with function below

def set_directory_structure(structure):
  global dir_struct
  dir_struct = structure
  return None

"""##Both of these files depend on format of dir_struct"""

def contains_folder(dir_struct, path, folder):
  return None

def contains_file(dir_struct, path, file_name):
  return None

"""# Main checking function

Input is simply file, in form of a list of lines/strings and the path to the file.

The return value is a dictionary of following form:

<pre>
'file_status': 'checkable' or 'uncheckable: msg' or 'checkable but no documentation'
'missing_fields': list of fields
'problem_fields' = [(f,l,i), (f,l,i) ...] where (f,l,i) for f,l,i in found_fields. Suggested MeerCat msg "problem with this line: check Flash-X documentation."
'bogus_fields': [('@internal', line, i), ...]
</pre>
"""

def check_file_documentation(dir_struct, lines:list, path:str):
  assert isinstance(lines, list)
  assert all([isinstance(x,str) for x in lines])
  assert isinstance(path,str)

  global units  #list of known units in Flash-X

  results_dict = {
      'file_status': 'checkable',
      'missing_fields': [],
      'problem_fields': [],
      'bogus_fields': [],
  }

  checkable, msg = is_file_documentation_checkable(lines, path)  #returns tuple: (bool, msg)
  if not checkable:
    results_dict['file_status'] = f'uncheckable: {msg}'
    return results_dict

  path_components = splitall(path)  #list of all pieces in path, e.g., ['source', 'numericalTools', 'MoL', 'MoL_advance.F90']
  the_unit = [unit for unit in units if unit in path_components]
  name, extension = os.path.splitext(path_components[-1])  #e.g., ('MoL_advance', '.F90') notice dot included
  if extension == '.F90':
      #need to figure out if stub or implementation or private
      the_file = os.path.basename(path)
      the_header = os.path.dirname(path)
      
      if not the_unit:
        #weird case - path that does not include a unit name
        results_dict['file_status'] = f'uncheckable: no unit on path {path}'
        return results_dict

      if len(the_unit)>1:
        #weird case - 2+ units on branch
        results_dict['file_status'] = f'uncheckable: more_than_one_unit_on_path {path}'
        return results_dict

      unit_name = the_unit[0]

      #check for stub - file directly under a unit folder and startswith unit name
      if the_header.endswith(unit_name) and name.startswith(unit_name):
          results = check_implementation_stub(lines, path, name, unit_name)
          for key in results:
            results_dict[key] = results[key]
          return results_dict

      #not stub - check for implementation - file not under unit folder but does start with unit name
      if name.startswith(unit_name):
        results = check_implementation(lines, path, name, unit_name)
        for key in results:
          results_dict[key] = results[key]
        return results_dict

      #not stubbed implementation - must be private
      results = check_private_file(dir_struct, lines, path, name, unit_name)
      for key in results:
        results_dict[key] = results[key]
      return results_dict

  if extension == '.dox':
    unit_name = the_unit[0]
    results = check_dox(lines, path, name, unit_name)
    for key in results:
      results_dict[key] = results[key]
    return results

  results_dict['file_status'] = f'uncheckable: library error for {path}'
  return results_dict

def check_implementation_stub(lines, path, file_name, unit, public=True):
  required_fields = ['@copyright',
                    '@licenseblock',
                    '@file',
                    '@brief',
                    '@ingroup',
                    '@details',
                    '@anchor',
                    #'@param',  #depends if parameters exist
  ]

  bogus_fields = ['@defgroup', '@stubref']  #probably others
  
  path_components = splitall(path)

  problems = dict(bogus_fields=[],  #fields that appear but should not appear in the file
                  missing_fields = [],  #missing fields that should appear
                  problem_fields = [])  #appropriate fields but with a problem in content
  
  #check for bogus fields
  for i,line in enumerate(lines):
    for field in bogus_fields:
      if field in line: problems['bogus_fields'] += [(f'{field} should not appear in stub file', line, i)]

  found_fields = []
  for i,line in enumerate(lines):
    for field in required_fields:
      if field in line: found_fields.append((field, line, i))

  if not found_fields:
    problems['file_status'] = 'checkable but no documentation'
    return problems

  missing_fields = (set(required_fields) - set([f for f,l,i in found_fields]))

  if missing_fields:
    problems['missing_fields'] = list(missing_fields)

  params_found = []

  for field, line, i in found_fields:
    if field == '@brief':
      if '<insert ' in line.lower():
        problems['problem_fields'] += [('@brief has place holder', line, i)]
      continue

    if field == '@ingroup' and public:
      if not line.strip().endswith(unit):
        problems['problem_fields'] += [(f'@ingroup should name containing unit {unit}', line, i)]
      continue

    if field == '@ingroup' and not public:
      if not line.strip().endswith(f'{path_components[-3]}Private'):
        problems['problem_fields'] += [(f'@ingroup should name containing folder {path_components[-3]}Private', line, i)]
      continue

    if field == '@details':
      if '<insert ' in line.lower():
        problems['problem_fields'] += [('@details has place holder', line, i)]
      continue

    if field == '@anchor':
      if not line.strip().endswith(file_name+'_stub'):
        problems['problem_fields'] += [(f'Expecting @anchor {file_name}_stub', line, i)]
      continue

    if field == '@param':
      components = line[line.find('@param'):].split(' ')
      params_found.append(components[1])
      if '<insert ' in line.lower():
        problems['problem_fields'] += [('@param has place holder', line, i)]
      continue

  #Now check if @params missing altogether. First find actual params.

  i = 0
  while not lines[i].startswith("subroutine "):
      i += 1
      if i >= len(lines):
        problems['file_status'] = f'checkable but no subroutine in file: {path}'
        return problems
  j = i
  while lines[i].find(")") == -1:
      i += 1
      if i >= len(lines):
        problems['problem_fields'] += [('No closing found for subroutine.', line, i)]
        return problems

  #Now get params
  raw_sig = " ".join(lines[j : i + 1]).strip("\n").replace("&", " ")[10:]
  sig_params = raw_sig[raw_sig.find("(") + 1 : raw_sig.find(")")].strip().split(",")
  sig_params = [sp.strip() for sp in sig_params]

  #Now know actual params. Is there a @param for each?
  for param in sig_params:
    if param in params_found: continue
    problems['missing_fields'].append(f'@param {param}')

  return problems

def check_implementation(lines, path, file_name, unit):
  required_fields = ['@copyright',
                    '@licenseblock',
                    '@file',
                    '@brief',
                    '@ingroup',
                    '@details',
                    '@stubref',
  ]

  bogus_fields = ['@defgroup', '@anchor']

  problems = dict(bogus_fields=[],  #fields that appear but should not appear in the file
                missing_fields = [],  #missing fields that should appear
                problem_fields = [])  #appropriate fields but with a problem in content

  path_components = splitall(path)

  #check for bogus fields
  for i,line in enumerate(lines):
    for field in bogus_fields:
      if field in line: problems['bogus_fields'] += [(f'{field} should not appear in stub implementation', line, i)]

  found_fields = []
  for i,line in enumerate(lines):
    for field in required_fields:
      if field in line: found_fields.append((field, line, i))

  if not found_fields:
    problems['file_status'] = 'checkable but no documentation'
    return problems

  missing_fields = (set(required_fields) - set([f for f,l,i in found_fields]))

  if missing_fields:
    problems['missing_fields'] = list(missing_fields)

  for field, line, i in found_fields:
    if field == '@brief':
      if '<insert ' in line.lower():
        problems['problem_fields'] += [('@brief has place holder', line, i)]
      continue

    if field == '@ingroup':
      if not line.strip().endswith(path_components[-2]):
        problems['problem_fields'] += [(f'@ingroup should name containing folder {path_components[-2]}', line, i)]
      continue

    if field == '@details':
      if '<insert ' in line.lower():
        problems['problem_fields'] += [('@details has place holder', line, i)]
      continue

    if field == '@stubref':
      name, extension = os.path.splitext(path_components[-1])
      if not line.strip().endswith('{'+name+'}'):
        problems['problem_fields'] += [('@stubref should end with {'+name+'}', line, i)]
      continue

  return problems

def check_private_file(dir_struct, lines, path, file_name, unit):
  '''
  Private files are ones that do not start with the unit name. There are 2 types of private files:
    1. files that are available to any other subfolder in the unit. These must have a stub that appears in the folder localApi.
       They can be implemented in any other subfolder under the unit.
    2. files that are available only in the containing subfolder. These will not have a stub, i.e., will not appear in localApi.

  Need to sort out which we are looking at.
  '''

  #First check if we are in localApi folder.
  path_components = splitall(path)  #list of all pieces in path, e.g., ['source', 'numericalTools', 'MoL', 'MoL_advance.F90']
  if path_components[-2] == 'localAPI':
    return check_private_stub(lines, path, file_name, unit)

  #No. Is there a stub for the file in localApi folder?
  unit_path = []
  for item in path_components:
    if item == unit:
      unit_path.append(item)
      break
    unit_path.append(item)

  if not dir_struct:
    return {'file_status': f'checkable but directory structure has not been set - necessary to check private implementation'}

  #check if localApi exists under unit
  if not contains_folder(dir_struct, '/'.join(unit_path), 'localAPI'):
    #No localApi folder so must be non_stubbed
    return check_private_nonstubbed_implementation(lines, path, file_name, unit)

  #localAPI does exist. check if stub in localAPI
  if not contains_file(dir_struct, '/'.join(unit_path+['localAPI']), file_name):
    #localApi folder but no stub
    return check_private_nonstubbed_implementation(lines, path, file_name, unit)

  #stub exists so must be implementation of stub
  return check_implementation(lines, path, file_name, unit)  #same as normal stubbed implementation

def check_private_stub(lines, path, file_name, unit):
  return check_implementation_stub(lines, path, file_name, unit, public=False)

def check_private_nonstubbed_implementation(lines, path, file_name, unit):
  return {'file_status': f'Checkable but not checking non-stubbed private files. Either no localApi folder or {file_name} not found in that folder'}

def check_dox(lines, path, file_name, unit):
  required_fields = ['@copyright',
                    '@par License',
                    '@parblock',
                    '@endparblock',
                    #'@internal',  only in internal folders
                    '@brief',
                    #'@ingroup',  #folder above unless source
                    '@details',
                    '@defgroup', #containing folder (at least)
  ]

  path_components = splitall(path)

  problems = dict(bogus_fields=[],  #fields that appear but should not appear in the file
                  no_required_fields = False,
                  missing_fields = [],  #missing fields that should appear
                  problem_fields = [])  #appropriate fields but with a problem in content

  '''
  Fairly complicated structure. If you are looking at a path

     source/foo/Fum/Fie/...

  then you would expect following:
     1. foo (not a unit) will have a file foo.dox. It will have a @defgroup foo. It will not have
        an @internal nor an @ingroup.
     2. Assume Fum is a unit. It will have a file Fum.dox with @defgroup Fum. It will have an @ingroup foo. It will not have
        an @internal.
    3. Fie is a folder under a unit. It will have a file Fie.dox with @defgroup Fie. It will have an @ingroup Fum. It will
       have an @internal.

  The code below attempts to check all this. Make sure correct fields are in required list and make sure fields that should not be there are not.
  '''

  #check if top-level
  if path_components[-3] != 'source':
    #not the top dox file in path so must be in a group
    required_fields.append('@ingroup')
    #now check if directly under unit
    if path_components[-2] != unit:
      #no, not under unit
      required_fields.append('@internal')
    else:
      #yes, under unit so should not be @internal
      for i,line in enumerate(lines):
        if '@internal' in line:
          problems['bogus_fields'] += [('@internal', line, i)]
          break
  else:
    #so source/Foo/Foo.dox
    for i,line in enumerate(lines):
      if '@ingroup' in line:
        problems['bogus_fields'] += [('@ingroup', line, i)]
      if '@internal' in line:
        problems['bogus_fields'] += [('@internal', line, i)]

  #done checking for @ingroup and @internal usage

  found_fields = []
  for i,line in enumerate(lines):
    for field in required_fields:
      if field in line: found_fields.append((field, line, i))

  if not found_fields:
    problems['no_required_fields'] = True
    return problems

  missing_fields = (set(required_fields) - set([f for f,l,i in found_fields]))
  if missing_fields:
    problems['missing_fields'] = list(missing_fields)

  for field, line, i in found_fields:
    if field == '@brief':
      if '<insert ' in line.lower():
        problems['problem_fields'] += [('@brief has place holder', line, i)]
      continue

    if field == '@ingroup':
      if not line.strip().endswith(path_components[-3]):
        problems['problem_fields'] += [(f'@ingroup should name {path_components[-3]}', line, i)]
      continue

    if field == '@details':
      if '<insert ' in line.lower():
        problems['problem_fields'] += [('@details has place holder', line, i)]
      continue

    #a bit complicated. Determine if dox for public or dox for private.
    if field == '@defgroup':
      if path_components[-1].startswith(unit):
        #file name starts with unit
        if path_components[-2] not in line:
          problems['problem_fields'] += [(f'Expecting @defgroup {path_components[-2]}', line, i)]
      else:
        #file name does not start with unit so must be private
        if f'{unit}Private' not in line:
          problems['problem_fields'] += [(f'Expecting @defgroup {unit}Private', line, i)]
      continue

  return problems

#source/numericalTools/MoL/MoL_advance.F90
stub_test_pub = '''!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file
!! @brief MoL_advance stub

!> @ingroup MoL
!!
!! @brief Take a timestep from t to t+dt
!! @anchor MoL_advance_stub
!! @details
!!
!!
!! This procedure is the main entry point into the MoL integrator,
!! and should be called once per time step.  All evolved variables
!! will be advanced from the time `t` to the time `t + dt` based
!! on the evaluation of the RHS terms for the variables' equations.
!!
!! @todo When/if subcyling is available in Flash-X, this will extend
!!       to include a level-indicator as well
!!
!! @param t  Current time
!! @param dt Size of the timestep to take
subroutine MoL_advance(t, dt)
   implicit none

   real, intent(in) :: t, dt

   return
end subroutine MoL_advance
'''

check_file_documentation(stub_test_pub.split('\n'), 'source/numericalTools/MoL/MoL_advance.F90')

#source/numericalTools/MoL/localAPI/ml_advance.F90

#source/numericalTools/MoL/localAPI/localAPI.dox
stub_test_priv = '''/** 
    @copyright Copyright 2023 UChicago Argonne, LLC and contributors

    @par License
    @parblock
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    @endparblock
    
    @internal  
    @defgroup MoLPrivate MoL localAPI
    @ingroup MoL

    @brief Provides interfaces to private procedures used internally by MoL
*/
'''

check_file_documentation(stub_test_priv.split('\n'), '')

#source/numericalTools/MoL/MoLMain/MoL_advance.F90
implementation_test = '''!> @copyright Copyright 2023 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file
!! @brief MoL_advance implementation

!> @ingroup MoLMain
!!
!! @brief Implements MoL_advance
!!
!! @details
!! This implementation saves the intial state of the evolved variables at
!! time `t` and calls a method-specific `ml_advance`
!!
!! @stubref{MoL_advance}
subroutine MoL_advance(t, dt)
   use ml_interface, only: ml_advance
   use ml_memInterface, only: ml_memCopy

#include "MoL.h"

   implicit none

   real, intent(in) :: t, dt

   call ml_memCopy(MOL_INITIAL, MOL_EVOLVED)

   call ml_advance(t, dt)
end subroutine MoL_advance
'''

check_file_documentation(implementation_test.split('\n'), 'source/numericalTools/MoL/MoLMain/MoL_advance.F90')

#source/numericalTools/MoL/MoL.dox
dox_unit_test = '''/**
    @copyright Copyright 2023 UChicago Argonne, LLC and contributors

    @par License
    @parblock
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    @endparblock
    
    @defgroup MoL Method of Lines Unit
    @ingroup numericalTools
   
    @brief Method-of-Lines time integrators and utilities

    @details
    For further information, please refer to @ref source/numericalTools/MoL/README.md
*/
'''

check_file_documentation(dox_unit_test.split('\n'), 'source/numericalTools/MoL/MoL.dox')

#source/numericalTools/MoL/MoLMain/MR/MR.dox
dox_internal_test = '''/** 
    @copyright Copyright 2022 UChicago Argonne, LLC and contributors

    @par License
    @parblock
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    @endparblock
    
    @internal  
    @defgroup MoLMR MoL Multi-Rate Integrator
    @ingroup MoLMain

    @brief Provides implementation of a multi-rate IMEX integrator
*/
'''

check_file_documentation(dox_internal_test.split('\n'), '')

#source/numericalTools/MoL/localAPI/ml_error.F90
private_stub = '''!> @copyright Copyright 2022 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file
!! @brief ml_error stub

!> @ingroup MoLPrivate
!!
!! @brief Issue a MoL-specific error message and abort
!!
!! @details
!! @anchor ml_error_stub
!!
!! @param msg  Description of the error that occurred
subroutine ml_error(msg)
   implicit none

   character(len=*), intent(in) :: msg

   return
end subroutine ml_error
'''

check_file_documentation(private_stub.split('\n'), 'source/numericalTools/MoL/localAPI/ml_error.F90')

#source/numericalTools/MoL/MoLMain/ml_error.F90
private_implementation = '''!> @copyright Copyright 2022 UChicago Argonne, LLC and contributors
!!
!! @licenseblock
!!   Licensed under the Apache License, Version 2.0 (the "License");
!!   you may not use this file except in compliance with the License.
!!
!!   Unless required by applicable law or agreed to in writing, software
!!   distributed under the License is distributed on an "AS IS" BASIS,
!!   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!   See the License for the specific language governing permissions and
!!   limitations under the License.
!! @endlicenseblock
!!
!! @file
!! @brief ml_error implementation

!> @ingroup MoLMain
!!
!! @brief Implements ml_error
!!
!! @stubref{ml_error}
subroutine ml_error(msg)
   use Driver_interface, only: Driver_abort

#include "constants.h"

   implicit none

   character(len=*), intent(in) :: msg

   ! Error-messaging is always turned on
   call Driver_abort("[MoL] ERROR: "//msg)
end subroutine ml_error
'''

#error until define folder functions from dir struct
check_file_documentation(private_implementation.split('\n'), 'source/numericalTools/MoL/MoLMain/ml_error.F90')
