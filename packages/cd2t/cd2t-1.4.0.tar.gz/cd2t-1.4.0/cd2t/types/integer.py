from cd2t.types.base import BaseDataType
from cd2t.results import FindingsList, WrongValueFinding, AutogenerationError, AutogenerationInfo
from cd2t.References import References, OPT, ReferenceElement
from cd2t.schema import SchemaError
import copy


class Integer(BaseDataType):
    type = 'integer'
    matching_classes = [int]
    support_reference = True
    options = [
        # option_name, required, class
        ('autogenerate', False, bool, False),
        ('maximum', False, int, None),
        ('minimum', False, int, None),
        ('not_allowed_values', False, list, list()),
        ('autogenerate_maximum', False, int, None),
        ('autogenerate_minimum', False, int, None),
        ('autogenerate_find', False, str, 'next_higher'),
    ]

    def __init__(self) -> None:
        super().__init__()
        self.minimum = None
        self.maximum = None
        self.not_allowed_values = list()
        self.autogenerate = False
        self.autogenerate_find = 'next_higher'
        self.autogenerate_minimum = None
        self.autogenerate_maximum = None
    
    def verify_options(self, path: str):
        for integer in self.not_allowed_values:
            if not isinstance(integer, int):
                raise SchemaError("Option 'not_allowed_values' contains non-integer", path)
        if self.autogenerate_find not in ['next_higher', 'next_lower']:
            raise SchemaError("Option 'autogenerate_find' must be 'next_higher' or 'next_lower'", path)
    
    def autogenerate_data(self, data :any, path :str, references :References):
        FL = FindingsList()
        if data is not None or not self.autogenerate:
            return data, FL
        # We need to autogenerate
        if self.autogenerate_find == 'next_lower':
            up = False
            new_value = self.autogenerate_maximum
            if new_value is None:
                new_value = self.maximum or 1
            end = self.autogenerate_minimum
            if end is None:
                end = self.minimum
            step = -1
        else:
            up = True
            new_value = self.autogenerate_minimum
            if new_value is None:
                new_value = self.minimum or 1
            end = self.autogenerate_maximum
            if end is None:
                end = self.maximum
            step = 1

        if OPT.UNIQUE not in self.ref_OPT:
            
            FL.append(AutogenerationInfo(path=path,
                                         message='Autogenerated value is %d' % new_value))
            return new_value, FL

        while end is None or ((up and new_value <= end) or (not up and new_value >= end)):
            if OPT.UNIQUE in self.ref_OPT:
                new_element = ReferenceElement(self.ref_key, path, new_value, self.ref_OPT)
                if references.same_unique(new_element) is None:
                    # We find a unique integer value
                    references.add_element(new_element)
                    FL.append(AutogenerationInfo(
                                        path=path,
                                        message='Autogenerated value is %d' % new_value))
                    return new_value, FL
                new_value = new_value + step
        FL.append(AutogenerationError(path=path, message='All values in use!'))
        return data, FL
 
    def verify_data(self, data :any, path :str, references=References()) -> FindingsList:
        FL = FindingsList()
        if self.minimum is not None and self.minimum > data:
            FL.append(WrongValueFinding(
                path=path, message='%d is lower than minimum %d' % (data, self.minimum)))
        elif self.maximum is not None and self.maximum < data:
            FL.append(WrongValueFinding(
                path=path, message='%d is higher than maximum %d' % (data, self.maximum)))
        elif data in self.not_allowed_values:
            FL.append(WrongValueFinding(
                path=path, message='%d is not allowed' % data))
        return FL
