
from cd2t.types.base import BaseDataType
from cd2t.results import DataTypeMismatch, AutogenerationInfo
from cd2t.references import *
from cd2t.schema import SchemaError


class Bool(BaseDataType):
    options = [
        # option_name, required, class
        ('autogenerate', False, bool, False),
        ('autogenerate_default', False, bool, None),
        ('allowed_value', False, bool, None)
    ]

    def __init__(self, data_type_classes=dict(), path=str()) -> None:
        super().__init__()
        self.autogenerate = False
        self.autogenerate_default = None
        self.allowed_value = None
    
    def verify_options(self, path: str):
        if self.autogenerate:
            if self.autogenerate_default is None:
                raise SchemaError("'autogenerate_default' is required, if autogenerate is enabled", path)
            elif self.allowed_value is not None and self.autogenerate_default != self.allowed_value:
                raise SchemaError("'allowed_value' and 'autogenerate_default' must be equal", path)


 
    def verify_data(self, data :any, path :str, references=References()) -> list:
        results = list()
        if not isinstance(data, bool):
            results.append(DataTypeMismatch(path=path, message='Value is not a boolean'))
        if self.allowed_value is not None and data != self.allowed_value:
            results.append(ValidationFinding(path=path, message='Value is not allowed'))
        return results
    
    def autogenerate_values(self, data :any, path :str, references :References):
        if data is not None or not self.autogenerate:
            return data, list()
        new_value = self.autogenerate_default
        new = dict(
            reference=self.ref_key,
            path=path,
            value=new_value
        )
        result = AutogenerationInfo(
                    reference=new,
                    path=path,
                    message='Autogenerated value is %s' % str(new_value))
        return new_value, [result]
    