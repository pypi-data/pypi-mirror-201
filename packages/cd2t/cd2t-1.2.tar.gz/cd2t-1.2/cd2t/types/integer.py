from cd2t.types.base import BaseDataType
from cd2t.results import *
from cd2t.references import *
from cd2t.schema import SchemaError
import copy


class Integer(BaseDataType):
    matching_class = int
    support_reference = True
    options = [
        # option_name, required, class
        ('autogenerate', False, bool, False),
        ('maximum', False, int, None),
        ('minimum', False, int, None),
        ('not_allowed_values', False, list, list()),
        ('autogenerate_maximum', False, int, None),
        ('autogenerate_minimum', False, int, None),
        ('autogenerate_find', False, str, 'next_higher'),
    ]

    def __init__(self) -> None:
        super().__init__()
        self.minimum = None
        self.maximum = None
        self.not_allowed_values = list()
        self.autogenerate = False
        self.autogenerate_find = 'next_higher'
        self.autogenerate_minimum = None
        self.autogenerate_maximum = None
    
    def verify_options(self, path: str):
        for integer in self.not_allowed_values:
            if not isinstance(integer, int):
                raise SchemaError("Option 'not_allowed_values' contains non-integer", path)
        if self.autogenerate_find not in ['next_higher', 'next_lower']:
            raise SchemaError("Option 'autogenerate_find' must be 'next_higher' or 'next_lower'", path)
    
    def autogenerate_values(self, data :any, path :str, references :References):
        if data is not None:
            self.verify_reference(data, path, references)
            return data, list()
        if not self.autogenerate:
            return data, list()
        # We need to autogenerate
        if self.autogenerate_find == 'next_lower':
            up = False
            new_value = self.autogenerate_maximum
            if new_value is None:
                new_value = self.maximum or 1
            end = self.autogenerate_minimum
            if end is None:
                end = self.minimum
            step = -1
        else:
            up = True
            new_value = self.autogenerate_minimum
            if new_value is None:
                new_value = self.minimum or 1
            end = self.autogenerate_maximum
            if end is None:
                end = self.maximum
            step = 1

        if OPT.UNIQUE not in self.ref_OPT:
            return new_value, [AutogenerationInfo(
                                reference=dict(),
                                path=path,
                                message='Autogenerated value is %d' % new_value)]

        while end is None or ((up and new_value <= end) or (not up and new_value >= end)):
            if OPT.UNIQUE in self.ref_OPT:
                new_element = ReferenceElement(self.ref_key, path, new_value, self.ref_OPT)
                if references.same_unique(new_element) is None:
                    # We find a unique integer value
                    references.add_element(new_element)
                    new = dict(
                        reference=self.ref_key,
                        path=path,
                        value=new_value
                    )
                    return new_value, [AutogenerationInfo(
                                        reference=new,
                                        path=path,
                                        message='Autogenerated value is %d' % new_value)]
                new_value = new_value + step
        return data, [AutogenerationError(reference=dict(),
                                          path=path,
                                          message='All values in use!')]
 
    def verify_data(self, data :any, path :str, references=References()) -> list:
        if not isinstance(data, int):
            return [(DataTypeMismatch(path, 'Value is not an integer'))]
        if self.minimum is not None and self.minimum > data:
            return [(WrongValueFinding(path, '%d is lower than minimum %d' % (data, self.minimum)))]
        if self.maximum is not None and self.maximum < data:
            return [(WrongValueFinding(path, '%d is higher than maximum %d' % (data, self.maximum)))]
        if data in self.not_allowed_values:
            return [(WrongValueFinding(path, '%d is not allowed' % data))]
        return list()
