# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbs

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Synchronization points to specify the call sequence, alternatively to the use of run index
# Notes:
#   - The names of the synchronization points of a callables have to be unique
#   - The names of the synchronization points of a callables have match to the Data Layer compliance guide lines meaning any alphanumeric character are allowed [a-zA-Z_][a-zA-Z0-9-._]+
#   - To ensure that other callable can run after or before this callable it's recommended to set at least one synchronization point in each list
class SyncPoints(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAsSyncPoints(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = SyncPoints()
        x.Init(buf, n + offset)
        return x

    # SyncPoints
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # User defined synchronization points, execute callable in order after these points, 
    # SyncPoints
    def After(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # SyncPoints
    def AfterLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SyncPoints
    def AfterIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # User defined synchronization points, execute callable in order before these points, any alphanumeric character
    # SyncPoints
    def Before(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # SyncPoints
    def BeforeLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # SyncPoints
    def BeforeIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

def SyncPointsStart(builder): builder.StartObject(2)
def SyncPointsAddAfter(builder, after): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(after), 0)
def SyncPointsStartAfterVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def SyncPointsAddBefore(builder, before): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(before), 0)
def SyncPointsStartBeforeVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def SyncPointsEnd(builder): return builder.EndObject()

try:
    from typing import List
except:
    pass

class SyncPointsT(object):

    # SyncPointsT
    def __init__(self):
        self.after = None  # type: List[str]
        self.before = None  # type: List[str]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        syncPoints = SyncPoints()
        syncPoints.Init(buf, pos)
        return cls.InitFromObj(syncPoints)

    @classmethod
    def InitFromObj(cls, syncPoints):
        x = SyncPointsT()
        x._UnPack(syncPoints)
        return x

    # SyncPointsT
    def _UnPack(self, syncPoints):
        if syncPoints is None:
            return
        if not syncPoints.AfterIsNone():
            self.after = []
            for i in range(syncPoints.AfterLength()):
                self.after.append(syncPoints.After(i))
        if not syncPoints.BeforeIsNone():
            self.before = []
            for i in range(syncPoints.BeforeLength()):
                self.before.append(syncPoints.Before(i))

    # SyncPointsT
    def Pack(self, builder):
        if self.after is not None:
            afterlist = []
            for i in range(len(self.after)):
                afterlist.append(builder.CreateString(self.after[i]))
            SyncPointsStartAfterVector(builder, len(self.after))
            for i in reversed(range(len(self.after))):
                builder.PrependUOffsetTRelative(afterlist[i])
            after = builder.EndVector(len(self.after))
        if self.before is not None:
            beforelist = []
            for i in range(len(self.before)):
                beforelist.append(builder.CreateString(self.before[i]))
            SyncPointsStartBeforeVector(builder, len(self.before))
            for i in reversed(range(len(self.before))):
                builder.PrependUOffsetTRelative(beforelist[i])
            before = builder.EndVector(len(self.before))
        SyncPointsStart(builder)
        if self.after is not None:
            SyncPointsAddAfter(builder, after)
        if self.before is not None:
            SyncPointsAddBefore(builder, before)
        syncPoints = SyncPointsEnd(builder)
        return syncPoints
