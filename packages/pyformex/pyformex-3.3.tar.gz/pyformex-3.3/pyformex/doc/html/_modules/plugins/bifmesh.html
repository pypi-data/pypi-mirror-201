

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><!--
##
##  This file is part of the pyFormex project.
##  pyFormex is a tool for generating, manipulating and transforming 3D
##  geometrical models by sequences of mathematical operations.
##  Home page: http://pyformex.org
##  Project page:  http://savannah.nongnu.org/projects/pyformex/
##  Copyright (C) Benedict Verhegghe (benedict.verhegghe@ugent.be)
##  Distributed under the GNU General Public License version 3 or later.
##
##
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see http://www.gnu.org/licenses/.
##
-->
    <title>plugins.bifmesh &#8212; pyFormex 3.3 documentation</title>

    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pyformex.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="icon" type="image/png" href="../../_static/pyformex_fav.png" />

  </head><body>

<div class="header">
  <a href="http://pyformex.org">
  <img src="../../_static/scallop_dome_small.png" alt="scallop dome" border="0" hspace="20" vspace="12" align="left" />
  <img src="../../_static/pyformex-logo-2.png" alt="pyformex logo" border="0" hspace="10" vspace="8" align="left" />
  </a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyFormex 3.3 documentation</a> &gt;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &gt;</li>
        <!--li class="nav-item nav-item-this"><a href="">plugins.bifmesh</a></li--> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<!-- PYFORMEX_SIDEBAR_LOGO -->
<!-- PYFORMEX_WEBSITE_SIDEBAR_TOP -->

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for plugins.bifmesh</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1">##</span>
<span class="c1">##  SPDX-FileCopyrightText: Â© 2007-2023 Benedict Verhegghe &lt;bverheg@gmail.com&gt;</span>
<span class="c1">##  SPDX-License-Identifier: GPL-3.0-or-later</span>
<span class="c1">##</span>
<span class="c1">##  This file is part of pyFormex 3.3  (Sun Mar 26 20:16:15 CEST 2023)</span>
<span class="c1">##  pyFormex is a tool for generating, manipulating and transforming 3D</span>
<span class="c1">##  geometrical models by sequences of mathematical operations.</span>
<span class="c1">##  Home page: https://pyformex.org</span>
<span class="c1">##  Project page: https://savannah.nongnu.org/projects/pyformex/</span>
<span class="c1">##  Development: https://gitlab.com/bverheg/pyformex</span>
<span class="c1">##  Distributed under the GNU General Public License version 3 or later.</span>
<span class="c1">##</span>
<span class="c1">##  This program is free software: you can redistribute it and/or modify</span>
<span class="c1">##  it under the terms of the GNU General Public License as published by</span>
<span class="c1">##  the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">##  (at your option) any later version.</span>
<span class="c1">##</span>
<span class="c1">##  This program is distributed in the hope that it will be useful,</span>
<span class="c1">##  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">##  GNU General Public License for more details.</span>
<span class="c1">##</span>
<span class="c1">##  You should have received a copy of the GNU General Public License</span>
<span class="c1">##  along with this program.  If not, see http://www.gnu.org/licenses/.</span>
<span class="c1">##</span>

<span class="sd">&quot;&quot;&quot;Vascular Sweeping Mesher</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">#from numpy import *</span>
<span class="kn">from</span> <span class="nn">pyformex.trisurface</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyformex.core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyformex.simple</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyformex.connectivity</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyformex.curve</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyformex.plugins.isopar</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyformex.elements</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">pyformex.plugins.fe</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyformex.mesh</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyformex.project</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyformex.geomtools</span> <span class="kn">import</span> <span class="n">triangleCircumCircle</span>

<span class="kn">from</span> <span class="nn">pyformex.gui.draw</span> <span class="kn">import</span> <span class="n">draw</span><span class="p">,</span> <span class="n">zoomAll</span><span class="p">,</span> <span class="n">sleep</span><span class="p">,</span> <span class="n">undraw</span>


<div class="viewcode-block" id="structuredQuadMeshGrid"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.structuredQuadMeshGrid">[docs]</a><span class="k">def</span> <span class="nf">structuredQuadMeshGrid</span><span class="p">(</span><span class="n">sgx</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">sgy</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">isopquad</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;it returns nodes (2D) and elems of a structured quadrilateral grid. nodes and elements are both ordered first vertically (y) and then orizontally (x). This function is the equivalent of simple.rectangularGrid but on the mesh level.&quot;&quot;&quot;</span>
    <span class="n">sg</span><span class="o">=</span><span class="n">regularGrid</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="n">sgx</span><span class="p">,</span> <span class="n">sgy</span><span class="p">],</span> <span class="n">swapaxes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">sgc</span><span class="o">=</span><span class="n">sgy</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">esg</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="n">array</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="n">sgc</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">sgc</span><span class="p">,</span>  <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sgc</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span><span class="o">+</span><span class="n">sgc</span><span class="o">*</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sgx</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">isopquad</span><span class="o">==</span><span class="s1">&#39;quad16&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="n">sg</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">esg</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">regularGrid</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">swapaxes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># control points for the hex64 applied to a basic struct hex grid</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">sg</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">esg</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span></div>

<div class="viewcode-block" id="structuredHexMeshGrid"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.structuredHexMeshGrid">[docs]</a><span class="k">def</span> <span class="nf">structuredHexMeshGrid</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span><span class="p">,</span> <span class="n">isophex</span><span class="o">=</span><span class="s1">&#39;hex64&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;it builds a structured hexahedral grid with nodes and elements both numbered in a structured way: first along z, then along y,and then along x. The resulting hex cells are oriented along z. This function is the equivalent of simple.rectangularGrid but for a mesh. Additionally, dx,dy,dz can be either integers or div (1D list or array). In case of list/array, first and last numbers should be 0.0 and 1.0 if the desired grid has to be inside the region 0.,0.,0. to 1.,1.,1.</span>
<span class="sd">    TODO: include other optons to get the control points for other isoparametric transformation for hex.&quot;&quot;&quot;</span>
    <span class="n">sgx</span><span class="p">,</span> <span class="n">sgy</span><span class="p">,</span> <span class="n">sgz</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dz</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span> <span class="n">sgx</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span> <span class="n">sgy</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span> <span class="n">sgz</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">n3</span><span class="o">=</span><span class="n">regularGrid</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="n">sgx</span><span class="p">,</span> <span class="n">sgy</span><span class="p">,</span> <span class="n">sgz</span><span class="p">],</span> <span class="n">swapaxes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span> <span class="n">n3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">array</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span> <span class="n">n3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">array</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dz</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span> <span class="n">n3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">array</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">nyz</span><span class="o">=</span><span class="p">(</span><span class="n">sgy</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">sgz</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">xh0</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">nyz</span><span class="p">,</span> <span class="n">nyz</span><span class="o">+</span><span class="n">sgz</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span><span class="n">sgz</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">xh0</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xh0</span><span class="p">,</span> <span class="n">xh0</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># first cell</span>
    <span class="n">hz</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xh0</span><span class="o">+</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sgz</span><span class="p">)])</span>  <span class="c1"># z column</span>
    <span class="n">hzy</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">hz</span><span class="o">+</span><span class="p">(</span><span class="n">sgz</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sgy</span><span class="p">)])</span>  <span class="c1"># zy 2D rectangle</span>
    <span class="n">hzyx</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="n">hzy</span><span class="o">+</span><span class="n">nyz</span><span class="o">*</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sgx</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># zyx 3D</span>
    <span class="k">if</span> <span class="n">isophex</span><span class="o">==</span><span class="s1">&#39;hex64&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="n">Coords</span><span class="p">(</span><span class="n">n3</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">hzyx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">regularGrid</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">swapaxes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># control points for the hex64 applied to a basic struct hex grid</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">Coords</span><span class="p">(</span><span class="n">n3</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">hzyx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span></div>



<div class="viewcode-block" id="findBisectrixUsingPlanes"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.findBisectrixUsingPlanes">[docs]</a><span class="k">def</span> <span class="nf">findBisectrixUsingPlanes</span><span class="p">(</span><span class="n">cpx</span><span class="p">,</span> <span class="n">centx</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;it returns a bisectrix-points at each point of a Polygon (unit vector of the bisectrix). All the bisectrix-points are on the side of centx (inside the Polygon), regardless to the concavity or convexity of the angle, thus avoiding the problem of collinear or concave segments. The points will point towards the centx if the centx is offplane. It uses the lines from intersection of 2 planes.&quot;&quot;&quot;</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">cpx</span><span class="p">,</span> <span class="p">[</span><span class="n">cpx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">cx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">cx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">#    draw(Formex(cx))</span>
<span class="c1">#    drawNumbers(Formex(cx))</span>
<span class="c1">#    drawNumbers(Formex(cx[0]))</span>
    <span class="k">if</span> <span class="n">centx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">centx</span><span class="o">=</span><span class="n">cx</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1">#draw(Formex(centx))</span>
    <span class="n">nx0</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">v0</span><span class="o">=</span><span class="n">cx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">cx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">z0</span><span class="o">=</span><span class="n">cross</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">centx</span><span class="o">-</span><span class="n">cx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">nx0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">z0</span><span class="p">,</span> <span class="n">v0</span><span class="p">)))</span>
    <span class="n">c1</span><span class="o">=</span><span class="n">cx</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">nx1</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">v0</span><span class="o">=</span><span class="n">c1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">c1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">z0</span><span class="o">=</span><span class="n">cross</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">centx</span><span class="o">-</span><span class="n">c1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">nx1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">cross</span><span class="p">(</span><span class="n">z0</span><span class="p">,</span> <span class="n">v0</span><span class="p">)))</span>
    <span class="n">nx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">nx1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">nx0</span><span class="o">+</span><span class="n">nx1</span><span class="p">)</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">at</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>  <span class="c1"># new added</span>
    <span class="c1">#[draw(Formex([[cpx[i], cpx[i]+nx[i]]])) for i in range(cpx[:].shape[0])]</span>
    <span class="k">return</span> <span class="n">nx</span></div>



<div class="viewcode-block" id="cpBoundaryLayer"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.cpBoundaryLayer">[docs]</a><span class="k">def</span> <span class="nf">cpBoundaryLayer</span><span class="p">(</span><span class="n">BS</span><span class="p">,</span>  <span class="n">centr</span><span class="p">,</span> <span class="n">issection0</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="n">bl_rel</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;it takes n points of a nearly circular section (for the isop transformation, n should be 24, 48 etc) and find the control points needed for the boundary layer. The center of the section has to be given separately.</span>
<span class="sd">    -issection0 needs to be True only for the section-0 of each branch of a bifurcation, which has to share the control points with the other branches. So it must be False for all other sections and single vessels.</span>
<span class="sd">    This implementation for the bl (separated from the inner lumen) is needed to ensure an optimal mesh quality at the boundary layer in terms of angular skewness, needed for WSS calculation.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">BS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;BE CAREFUL: the number of points along each circular section need to be even to split a vessel in 2 halves with the same connectivity!&quot;</span><span class="p">)</span>
    <span class="n">bllength</span><span class="o">=</span><span class="n">length</span><span class="p">(</span><span class="n">BS</span><span class="o">-</span><span class="n">centr</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">bl_rel</span>
    <span class="n">blvecn</span><span class="o">=</span><span class="n">findBisectrixUsingPlanes</span><span class="p">(</span><span class="n">BS</span><span class="p">,</span> <span class="n">centr</span><span class="p">)</span>  <span class="c1"># unit vectors similar to bisectrix but obtained as intersection of planes</span>
    <span class="c1">#draw(Formex(centr))</span>
    <span class="c1">#print bisbs</span>
    <span class="k">if</span> <span class="n">issection0</span><span class="p">:</span>  <span class="c1"># inside the bifurcation center the 3 half sections need to touch each others on 1 single line. Thus, because the control points on this line (the bifurcation axis) needs to be the same, these 2 special points are defined differently, but only at the first section of each branches.</span>
        <span class="n">blvecn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">centr</span><span class="o">-</span><span class="n">BS</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">midp</span><span class="o">=</span><span class="n">BS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span>  <span class="c1"># is 12 if use 24 control points, will be 24 with 48 cp.</span>
        <span class="n">blvecn</span><span class="p">[</span><span class="n">midp</span><span class="p">]</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">centr</span><span class="o">-</span><span class="n">BS</span><span class="p">[</span><span class="n">midp</span><span class="p">])</span>
    <span class="n">blvec</span><span class="o">=</span><span class="n">blvecn</span><span class="o">*</span><span class="n">bllength</span>
    <span class="n">cpblayer</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="n">BS</span><span class="o">+</span><span class="n">blvec</span><span class="o">*</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>
    <span class="n">cpblayer</span><span class="o">=</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">cpblayer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1">#draw(Formex(cpblayer[:].reshape(-1, 3)))</span>
    <span class="c1">#drawNumbers(Formex(cpblayer[0]))</span>
    <span class="n">r4</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cpblayer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">3</span><span class="p">)])</span>
    <span class="n">r4</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">r4</span><span class="o">=</span> <span class="n">r4</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cpblayer</span><span class="p">[</span><span class="n">r4</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">cpblayer</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># control points of the boundaary layer, points on the border with the inner part of the lumen</span></div>

<div class="viewcode-block" id="cpQuarterLumen"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.cpQuarterLumen">[docs]</a><span class="k">def</span> <span class="nf">cpQuarterLumen</span><span class="p">(</span><span class="n">lumb</span><span class="p">,</span> <span class="n">centp</span><span class="p">,</span> <span class="n">edgesq</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">diag</span><span class="o">=</span><span class="mf">0.6</span><span class="o">*</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">verbos</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;control points for 1 quarter of lumen mapped in quad regions. lumb is a set of points on a quarter of section. centp is the center of the section. The number of poin I found that edgesq=0.75, diag=0.6*2**0.5 give the better mapping. Also possible edgesq=0.4, diag=0.42*2**0.5. Currently, it is not perfect if the section is not planar.&quot;&quot;&quot;</span>
    <span class="n">arcp</span><span class="o">=</span><span class="n">lumb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">arcsh</span><span class="o">=</span> <span class="n">arcp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">xcp1</span><span class="p">,</span> <span class="n">xcp3</span><span class="o">=</span><span class="n">centp</span><span class="o">+</span><span class="p">(</span><span class="n">arcp</span><span class="p">[[</span><span class="n">arcsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span><span class="o">-</span><span class="n">centp</span><span class="p">)</span><span class="o">*</span><span class="n">edgesq</span>
    <span class="n">xcp2</span><span class="o">=</span><span class="n">centp</span><span class="o">+</span><span class="p">(</span><span class="n">arcp</span><span class="p">[</span><span class="n">arcsh</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">centp</span><span class="p">)</span><span class="o">*</span><span class="n">diag</span>
    <span class="n">nc0</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="n">centp</span><span class="p">,</span> <span class="n">xcp1</span><span class="p">,</span> <span class="n">xcp2</span><span class="p">,</span> <span class="n">xcp3</span><span class="p">])</span>  <span class="c1"># new coord0</span>
    <span class="n">grid16</span><span class="o">=</span> <span class="n">regularGrid</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">swapaxes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># grid</span>
    <span class="n">ncold</span><span class="o">=</span><span class="n">grid16</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>  <span class="c1"># old coord</span>
    <span class="n">fx</span><span class="o">=</span><span class="n">arcsh</span><span class="o">//</span><span class="mi">6</span>
    <span class="n">sc</span><span class="o">=</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="o">/</span><span class="n">fx</span><span class="p">,</span> <span class="mf">1.</span><span class="o">/</span><span class="n">fx</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
    <span class="n">grid16</span><span class="o">=</span><span class="n">Formex</span><span class="p">([</span><span class="n">grid16</span><span class="p">])</span><span class="o">.</span><span class="n">replicm</span><span class="p">((</span><span class="n">fx</span><span class="p">,</span> <span class="n">fx</span><span class="p">))</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">sc</span><span class="p">)[:]</span>
    <span class="n">gridint</span><span class="o">=</span> <span class="n">Isopar</span><span class="p">(</span><span class="s1">&#39;quad4&#39;</span><span class="p">,</span> <span class="n">nc0</span><span class="p">,</span> <span class="n">ncold</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">grid16</span><span class="p">)</span>  <span class="c1"># 4 internal grids</span>
    <span class="n">xa0</span><span class="o">=</span><span class="n">Coords</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Coords</span><span class="p">(</span><span class="n">ncold</span><span class="p">[[</span><span class="mi">3</span><span class="p">]]),</span> <span class="n">Coords</span><span class="p">(</span><span class="n">ncold</span><span class="p">[[</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">div</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">fx</span><span class="p">)</span>
    <span class="n">xa1</span><span class="o">=</span><span class="n">Coords</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Coords</span><span class="p">(</span><span class="n">ncold</span><span class="p">[[</span><span class="mi">2</span><span class="p">]]),</span> <span class="n">Coords</span><span class="p">(</span><span class="n">ncold</span><span class="p">[[</span><span class="mi">1</span><span class="p">]]),</span> <span class="n">div</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">fx</span><span class="p">)</span>
    <span class="n">xa</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">xa0</span><span class="p">,</span> <span class="n">xa1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">xa</span><span class="o">=</span> <span class="n">Isopar</span><span class="p">(</span><span class="s1">&#39;quad4&#39;</span><span class="p">,</span> <span class="n">nc0</span><span class="p">,</span> <span class="n">ncold</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">xar3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fx</span><span class="p">)])</span>
    <span class="n">gridext</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">xar3</span><span class="p">],</span> <span class="n">arcp</span><span class="p">[</span><span class="n">xar3</span><span class="p">])))</span>
    <span class="n">gridext</span> <span class="o">=</span> <span class="n">Coords</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">Coords</span><span class="p">(</span><span class="n">gridext</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">Coords</span><span class="p">(</span><span class="n">gridext</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">div</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">gridext</span><span class="o">=</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">gridext</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">fx</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>  <span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbos</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;---one Quarter of section is submapped in </span><span class="si">%d</span><span class="s1"> internal and </span><span class="si">%d</span><span class="s1"> transitional quad regions---&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">gridint</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gridext</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="c1">#    gridG=concatenate([gridint, gridext], axis=0)</span>
<span class="c1">#    print &#39;---one Quarter of section is submapped in %d quad regions---&#39;%gridG.shape[0]</span>
<span class="c1">#    [draw(Formex(fo).setProp(i)) for  i, fo in enumerate(gridG) ]</span>
<span class="c1">#    for i in gridG:</span>
<span class="c1">#        di= [drawNumbers(Formex(i))]</span>
<span class="c1">#        zoomAll()</span>
<span class="c1">#        undraw(di)</span>
<span class="c1">#    exit()</span>
    <span class="k">return</span> <span class="n">gridint</span><span class="p">,</span> <span class="n">gridext</span></div>


<div class="viewcode-block" id="visualizeSubmappingQuadRegion"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.visualizeSubmappingQuadRegion">[docs]</a><span class="k">def</span> <span class="nf">visualizeSubmappingQuadRegion</span><span class="p">(</span><span class="n">sqr</span><span class="p">,</span> <span class="n">timewait</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;visualilze the control points (-1,16,3) in each submapped region and check the quality of the region (which will be inherited by the mesh crossectionally)&quot;&quot;&quot;</span>
    <span class="n">sqr3</span><span class="o">=</span><span class="n">regularGrid</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">swapaxes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># base old coords</span>
    <span class="n">sqrn3</span><span class="p">,</span> <span class="n">sqre3</span><span class="o">=</span><span class="n">structuredQuadMeshGrid</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># quad mesh to map</span>
    <span class="k">for</span>  <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sqr</span><span class="p">):</span>
        <span class="n">sqr0</span><span class="o">=</span><span class="n">Formex</span><span class="p">(</span><span class="n">sqrn3</span><span class="p">)</span><span class="o">.</span><span class="n">isopar</span><span class="p">(</span><span class="s1">&#39;quad16&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">sqr3</span><span class="p">)[:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">sqr0</span><span class="o">=</span><span class="n">Formex</span><span class="p">(</span><span class="n">sqr0</span><span class="p">[</span><span class="n">sqre3</span><span class="p">])</span>
        <span class="n">draw</span><span class="p">(</span><span class="n">Formex</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">setProp</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">draw</span><span class="p">(</span><span class="n">sqr0</span><span class="o">.</span><span class="n">setProp</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">di</span><span class="o">=</span> <span class="p">[</span><span class="n">drawNumbers</span><span class="p">(</span><span class="n">Formex</span><span class="p">(</span><span class="n">f</span><span class="p">))]</span>
        <span class="n">zoomAll</span><span class="p">()</span>
        <span class="c1">###here check quality of G0: if it is not good enough, change the parameters of the cpQuarterLumen(quartsec[0], oc, edgesq= ..., diag= ...)</span>
        <span class="k">if</span> <span class="n">timewait</span><span class="o">!=</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">sleep</span><span class="p">(</span><span class="n">timewait</span><span class="p">)</span>
        <span class="n">undraw</span><span class="p">(</span><span class="n">di</span><span class="p">)</span></div>


<div class="viewcode-block" id="cpOneSection"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.cpOneSection">[docs]</a><span class="k">def</span> <span class="nf">cpOneSection</span><span class="p">(</span><span class="n">hc</span><span class="p">,</span> <span class="n">oc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isBranchingSection</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbos</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;hc is a numbers of points on the boundary line of 1 almost circular section. oc is the center point of the section. It returns 3 groups of control points: for the inner part, for the transitional part and for the boundary layer of one single section&quot;&quot;&quot;</span>

    <span class="c1">##if the center is not given, it is calculated from the first and the half points of the section</span>
    <span class="k">if</span> <span class="n">oc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">oc</span><span class="o">=</span><span class="p">(</span><span class="n">hc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">hc</span><span class="p">[</span><span class="n">hc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span>

    <span class="c1">##create control points for the boundary layer of 1 full section.</span>
    <span class="k">if</span> <span class="n">verbos</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">isBranchingSection</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--BRANCHING SECTION:section located at the center of the bifurcation&quot;</span><span class="p">)</span>
    <span class="n">cpbl</span><span class="p">,</span> <span class="n">hlum</span><span class="o">=</span><span class="n">cpBoundaryLayer</span><span class="p">(</span><span class="n">hc</span><span class="p">,</span>  <span class="n">centr</span><span class="o">=</span><span class="n">oc</span><span class="p">,</span> <span class="n">issection0</span><span class="o">=</span><span class="n">isBranchingSection</span><span class="p">)</span>

    <span class="c1">##split the inner lumen in quarters and check if the isop can be applied</span>
    <span class="k">if</span> <span class="n">hlum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">24</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of points along each circular section should be a multiple of 24 in order to allow mapping!&quot;</span><span class="p">)</span>
    <span class="n">npq</span> <span class="o">=</span> <span class="n">hlum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">4</span>
    <span class="n">hlum1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">hlum</span><span class="p">,</span> <span class="p">[</span><span class="n">hlum</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">quartsec</span><span class="o">=</span><span class="p">[</span><span class="n">hlum1</span><span class="p">[</span><span class="n">npq</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="n">npq</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>  <span class="c1"># split in quarters</span>

    <span class="c1">##created control points of each quarter</span>
    <span class="n">cpis</span><span class="p">,</span> <span class="n">cpts</span><span class="o">=</span><span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">quartsec</span><span class="p">:</span>
        <span class="n">i</span><span class="o">=</span><span class="n">cpQuarterLumen</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">oc</span><span class="p">)</span>
        <span class="n">cpis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># control points of the inner part of a section</span>
        <span class="n">cpts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># control points of the transitional part of a section</span>
    <span class="c1">#visualizeSubmappingQuadRegion(cpss, timewait=None)#</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">cpis</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">array</span><span class="p">(</span><span class="n">cpts</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">array</span><span class="p">(</span><span class="n">cpbl</span><span class="p">)</span></div>

<div class="viewcode-block" id="cpAllSections"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.cpAllSections">[docs]</a><span class="k">def</span> <span class="nf">cpAllSections</span><span class="p">(</span><span class="n">HC</span><span class="p">,</span> <span class="n">OC</span><span class="p">,</span> <span class="n">start_end_branching</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;control points of all sections divided  in 3 groups of control points: for the inner part, for the transitional part and for the boundary layer. if start_end_branching is [True,True] the first and the last section are considered bifurcation sections and therefore meshed differently. &quot;&quot;&quot;</span>
    <span class="n">isBranching</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">HC</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">isBranching</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">start_end_branching</span>  <span class="c1"># if first section is a branching section</span>
    <span class="c1">#print isBranching</span>
    <span class="n">cpain</span><span class="p">,</span> <span class="n">cpatr</span><span class="p">,</span> <span class="n">cpabl</span><span class="o">=</span><span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hc</span><span class="p">,</span> <span class="n">oc</span><span class="p">,</span> <span class="n">isBr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">HC</span><span class="p">,</span> <span class="n">OC</span><span class="p">,</span> <span class="n">isBranching</span><span class="p">):</span>
        <span class="n">i</span><span class="o">=</span><span class="n">cpOneSection</span><span class="p">(</span><span class="n">hc</span><span class="p">,</span> <span class="n">oc</span><span class="p">,</span>  <span class="n">isBranchingSection</span><span class="o">=</span><span class="n">isBr</span><span class="p">)</span>
        <span class="n">cpain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">cpatr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">cpabl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">cpain</span><span class="p">,</span> <span class="n">cpatr</span><span class="p">,</span> <span class="n">cpabl</span><span class="o">=</span><span class="p">[</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="n">cpain</span><span class="p">,</span> <span class="n">cpatr</span><span class="p">,</span> <span class="n">cpabl</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;# sections= </span><span class="si">%d</span><span class="s1">,  # inner quad reg = </span><span class="si">%d</span><span class="s1">, # trans quad reg = </span><span class="si">%d</span><span class="s1">, # boundary-layer quad reg = </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">cpain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cpain</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cpatr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cpabl</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">start_end_branching</span><span class="o">==</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--this vessel BIFURCATES both at FIRST AND LAST section&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start_end_branching</span><span class="o">==</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--this vessel BIFURCATES at FIRST section&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start_end_branching</span><span class="o">==</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--this vessel BIFURCATES at LAST section&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start_end_branching</span><span class="o">==</span><span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;--this vessel DOES NOT BIFURCATE&#39;</span><span class="p">)</span>
    <span class="c1">#[visualizeSubmappingQuadRegion(i) for i in cpain]</span>
    <span class="c1">#[visualizeSubmappingQuadRegion(i) for i in cpatr]</span>
    <span class="c1">#[visualizeSubmappingQuadRegion(i) for i in cpabl]</span>
    <span class="k">return</span> <span class="n">cpain</span><span class="p">,</span> <span class="n">cpatr</span><span class="p">,</span> <span class="n">cpabl</span></div>

<span class="c1">##FIRST STEP ----- FROM SPLINE-PTS to CONTROL-POINTS-QUAD16-------------------------</span>
<span class="c1">#cpAin, cpAtr, cpAbl=cpAllSections(HC, OC, [False, False])#control points of all sections grouped in inner, trans and boundary layer. Each contains number of long_slice, number of hex-reg, 16, 3.</span>
<span class="c1">##[visualizeSubmappingQuadRegion(i) for i in cpAin]</span>
<span class="c1">##pause()</span>
<div class="viewcode-block" id="cpStackQ16toH64"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.cpStackQ16toH64">[docs]</a><span class="k">def</span> <span class="nf">cpStackQ16toH64</span><span class="p">(</span><span class="n">cpq16</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;sweeping trick: from sweeping sections longitudinally to mapping hex64: ittakes -1,16,3 (cp of the quad16) and groups them in -1,64,3 (cp of the hex63) but slice after slice: [0,1,2,3],[1,2,3,4],[2,3,4,5],... It is a trick to use the hex64 for sweeping along an arbitrary number of sections.&quot;&quot;&quot;</span>
    <span class="n">cpqindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">i</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cpq16</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">3</span><span class="p">)])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">cpq16t</span><span class="o">=</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">cpq16</span><span class="p">[</span><span class="n">cpqindex</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">shcp</span><span class="o">=</span><span class="n">cpq16t</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">return</span> <span class="n">cpq16t</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="n">shcp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shcp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span></div>

<span class="c1">##SECOND STEP ----- FROM CONTROL-POINTS-QUAD16 to CONTROL-POINTS-HEX64-------------------------</span>
<span class="c1">#hex_cp=[cpStackQ16toH64(i) for i in [cpAin, cpAtr, cpAbl] ]#control points for hex64 divided in 3 groups: central, transition, and boundary layer. The stacking uses the TRICK for sweeping.</span>
<span class="c1">#</span>
<span class="c1">##THIRD STEP ----- specifing mesh_blocks parameters and build 3 mesh blocks</span>
<span class="c1">#ncirc=3</span>
<span class="c1">#nlong=2</span>
<span class="c1">#ntr=2#int or div</span>
<span class="c1">#nbl=[0., 0.4, 0.7, 0.8, 0.9, 1.]#int or div</span>
<span class="c1">#in_block=structuredHexMeshGrid(nlong, ncirc,ncirc,  isophex=&#39;hex64&#39;)</span>
<span class="c1">#tr_block=structuredHexMeshGrid(nlong, ncirc,ntr,  isophex=&#39;hex64&#39;)</span>
<span class="c1">#bl_block=structuredHexMeshGrid(nlong, ncirc,nbl,  isophex=&#39;hex64&#39;)</span>

<div class="viewcode-block" id="mapHexLong"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.mapHexLong">[docs]</a><span class="k">def</span> <span class="nf">mapHexLong</span><span class="p">(</span><span class="n">mesh_block</span><span class="p">,</span> <span class="n">cpvr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;map a structured mesh (n_block, e_block, cp_block are in mesh_block) into a volume defined by the control points cpvr (# regions longitudinally, # regions in 1 cross sectionsm, 64, 3 ). cp_block are the control points of the mesh block. It returns nodes and elements. Nodes are repeated in subsequently mapped regions !</span>
<span class="sd">    TRICK: in order to make the mapping working for an arbitrary number of sections the following trick is used: of the whole mesh_block, only the part located between the points 1--2 is meshed and mapped between 2 slices only. Thus, the other parts 0--1 and 2--3 are not mapped. To do so, the first and the last slice need to be meshed separately: n_start 0--1 and n_end 2--3.&quot;&quot;&quot;</span>
    <span class="n">n_block</span><span class="p">,</span> <span class="n">e_block</span><span class="p">,</span> <span class="n">cp_block</span><span class="o">=</span><span class="n">mesh_block</span>
    <span class="n">n_start</span><span class="p">,</span> <span class="n">n_body</span><span class="p">,</span> <span class="n">n_end</span><span class="o">=</span><span class="p">[</span><span class="n">n_block</span><span class="o">.</span><span class="n">scale</span><span class="p">([</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="n">i</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
    <span class="n">cp_start</span><span class="p">,</span> <span class="n">cp_body</span><span class="p">,</span> <span class="n">cp_end</span><span class="o">=</span><span class="n">cpvr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cpvr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">cpvr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n</span><span class="o">=</span><span class="p">[[</span><span class="n">Coords</span><span class="p">(</span><span class="n">n_tract</span><span class="p">)</span><span class="o">.</span><span class="n">isopar</span><span class="p">(</span><span class="s1">&#39;hex64&#39;</span><span class="p">,</span> <span class="n">cpi</span><span class="p">,</span> <span class="n">cp_block</span><span class="p">)</span> <span class="k">for</span> <span class="n">cpi</span> <span class="ow">in</span> <span class="n">cp_tract</span><span class="p">]</span> <span class="k">for</span> <span class="n">n_tract</span><span class="p">,</span> <span class="n">cp_tract</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">n_start</span><span class="p">,</span> <span class="n">n_body</span><span class="p">,</span> <span class="n">n_end</span><span class="p">],</span> <span class="p">[</span><span class="n">cp_start</span><span class="p">,</span> <span class="n">cp_body</span><span class="p">,</span> <span class="n">cp_end</span><span class="p">])]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">e_block</span></div>


<div class="viewcode-block" id="mapQuadLong"><a class="viewcode-back" href="../../ref/plugins.bifmesh.html#plugins.bifmesh.mapQuadLong">[docs]</a><span class="k">def</span> <span class="nf">mapQuadLong</span><span class="p">(</span><span class="n">mesh_block</span><span class="p">,</span> <span class="n">cpvr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;TRICK: in order to make the mapping working for an arbitrary number of sections the following trick is used: of the whole mesh_block, only the part located between the points 1--2 is meshed and mapped between 2 slices only. Thus, the other parts 0--1 and 2--3 are not mapped. To do so, the first and the last slice need to be meshed separately: n_start 0--1 and n_end 2--3.&quot;&quot;&quot;</span>
    <span class="n">n_block</span><span class="p">,</span> <span class="n">e_block</span><span class="p">,</span> <span class="n">cp_block</span><span class="o">=</span><span class="n">mesh_block</span>
    <span class="n">n_start</span><span class="p">,</span> <span class="n">n_body</span><span class="p">,</span> <span class="n">n_end</span><span class="o">=</span><span class="p">[</span><span class="n">n_block</span><span class="o">.</span><span class="n">scale</span><span class="p">([</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span><span class="o">.</span><span class="n">translate</span><span class="p">([</span><span class="n">i</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
    <span class="n">cp_body</span><span class="o">=</span><span class="n">cpvr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">cp_start</span><span class="o">=</span><span class="n">cp_body</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span>
    <span class="n">cp_end</span><span class="o">=</span><span class="n">cp_body</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">:]</span>
    <span class="n">n</span><span class="o">=</span><span class="p">[[</span><span class="n">Coords</span><span class="p">(</span><span class="n">n_tract</span><span class="p">)</span><span class="o">.</span><span class="n">isopar</span><span class="p">(</span><span class="s1">&#39;quad16&#39;</span><span class="p">,</span> <span class="n">cpi</span><span class="p">,</span> <span class="n">cp_block</span><span class="p">)</span> <span class="k">for</span> <span class="n">cpi</span> <span class="ow">in</span> <span class="n">cp_tract</span><span class="p">]</span> <span class="k">for</span> <span class="n">n_tract</span><span class="p">,</span> <span class="n">cp_tract</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">n_start</span><span class="p">,</span> <span class="n">n_body</span><span class="p">,</span> <span class="n">n_end</span><span class="p">],</span> <span class="p">[</span><span class="n">cp_start</span><span class="p">,</span> <span class="n">cp_body</span><span class="p">,</span> <span class="n">cp_end</span><span class="p">])]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">e_block</span></div>

<span class="c1"># End</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">pyFormex 3.3 documentation</a> &gt;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &gt;</li>
        <!--li class="nav-item nav-item-this"><a href="">plugins.bifmesh</a></li--> 
      </ul>
    </div>
    <div class="footer">
    <span class="left">
        &copy; Copyright 2004-2023, Benedict Verhegghe.
    </span>
      Last updated on Mar 27, 2023.
    <span class="right">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.4.3.
    </span>
    </div>
  </body>
</html>