

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><!--
##
##  This file is part of the pyFormex project.
##  pyFormex is a tool for generating, manipulating and transforming 3D
##  geometrical models by sequences of mathematical operations.
##  Home page: http://pyformex.org
##  Project page:  http://savannah.nongnu.org/projects/pyformex/
##  Copyright (C) Benedict Verhegghe (benedict.verhegghe@ugent.be)
##  Distributed under the GNU General Public License version 3 or later.
##
##
##  This program is free software: you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation, either version 3 of the License, or
##  (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with this program.  If not, see http://www.gnu.org/licenses/.
##
-->
    <title>42. trisurface — Operations on triangulated surfaces. &#8212; pyFormex 3.3 documentation</title>

    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pyformex.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="43. utils — A collection of miscellaneous utility functions." href="utils.html" />
    <link rel="prev" title="41. track — track.py" href="track.html" />
<link rel="icon" type="image/png" href="../_static/pyformex_fav.png" />

  </head><body>

<div class="header">
  <a href="http://pyformex.org">
  <img src="../_static/scallop_dome_small.png" alt="scallop dome" border="0" hspace="20" vspace="12" align="left" />
  <img src="../_static/pyformex-logo-2.png" alt="pyformex logo" border="0" hspace="10" vspace="8" align="left" />
  </a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="utils.html" title="43. utils — A collection of miscellaneous utility functions."
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="track.html" title="41. track — track.py"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pyFormex 3.3 documentation</a> &gt;</li>
          <li class="nav-item nav-item-1"><a href="../refman.html" accesskey="U">pyFormex reference manual</a> &gt;</li>
        <!--li class="nav-item nav-item-this"><a href=""><span class="section-number">42. </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">trisurface</span></code> — Operations on triangulated surfaces.</a></li--> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<!-- PYFORMEX_SIDEBAR_LOGO -->
<!-- PYFORMEX_WEBSITE_SIDEBAR_TOP -->

  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">42. <code class="xref py py-mod docutils literal notranslate"><span class="pre">trisurface</span></code> — Operations on triangulated surfaces.</a><ul>
<li><a class="reference internal" href="#classes-defined-in-module-trisurface">42.1. Classes defined in module trisurface</a></li>
<li><a class="reference internal" href="#functions-defined-in-module-trisurface">42.2. Functions defined in module trisurface</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="track.html"
                        title="previous chapter"><span class="section-number">41. </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">track</span></code> — track.py</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="utils.html"
                        title="next chapter"><span class="section-number">43. </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">utils</span></code> — A collection of miscellaneous utility functions.</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>


    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-trisurface">
<span id="trisurface-operations-on-triangulated-surfaces"></span><span id="sec-ref-trisurface"></span><h1><span class="section-number">42. </span><a class="reference internal" href="#module-trisurface" title="trisurface: Operations on triangulated surfaces."><code class="xref py py-mod docutils literal notranslate"><span class="pre">trisurface</span></code></a> — Operations on triangulated surfaces.<a class="headerlink" href="#module-trisurface" title="Permalink to this headline">¶</a></h1>
<p>A triangulated surface is a surface consisting solely of triangles.
Any surface in space, no matter how complex, can be approximated with
a triangulated surface.</p>
<div class="section" id="classes-defined-in-module-trisurface">
<h2><span class="section-number">42.1. </span>Classes defined in module trisurface<a class="headerlink" href="#classes-defined-in-module-trisurface" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="trisurface.TriSurface">
<em class="property">class </em><code class="sig-prename descclassname">trisurface.</code><code class="sig-name descname">TriSurface</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">prop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface" title="Permalink to this definition">¶</a></dt>
<dd><p>A class representing a triangulated 3D surface.</p>
<p>A triangulated surface is a surface consisting of a collection of
triangles. The TriSurface is subclassed from <a class="reference internal" href="mesh.html#mesh.Mesh" title="mesh.Mesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code></a> with a
fixed plexitude of 3.
The surface contains <cite>ntri</cite> triangles and <cite>nedg</cite> edges. Each triangle
has 3 vertices with 3 coordinates. The total number of vertices is
<cite>ncoords</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>args</strong> – <p>Data to initialize the TriSurface. This can be 1, 2 or 3 arguments
specifying one the the following data sets:</p>
<ul>
<li><p>an (ntri,3,3) <a class="reference internal" href="../glossary.html#term-array_like"><span class="xref std std-term">array_like</span></a> specifying the coordinates of
the vertices of the triangles,</p></li>
<li><p>a <a class="reference internal" href="formex.html#formex.Formex" title="formex.Formex"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formex</span></code></a> with plexitude 3,</p></li>
<li><p>a <a class="reference internal" href="mesh.html#mesh.Mesh" title="mesh.Mesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code></a> with plexitude 3,</p></li>
<li><p>an (ncoords,3) <a class="reference internal" href="../glossary.html#term-coords_like"><span class="xref std std-term">coords_like</span></a> with the vertex coordinates
and an (ntri,3) int <a class="reference internal" href="../glossary.html#term-array_like"><span class="xref std std-term">array_like</span></a> specifying three vertex indices
for each of the triangles</p></li>
<li><p>an (ncoords,3) <a class="reference internal" href="../glossary.html#term-coords_like"><span class="xref std std-term">coords_like</span></a> with the vertex coordinates,
an (nedg,2) int <a class="reference internal" href="../glossary.html#term-array_like"><span class="xref std std-term">array_like</span></a> specifying the vertex inidices
of the edges, and an (ntri,3) int <a class="reference internal" href="../glossary.html#term-array_like"><span class="xref std std-term">array_like</span></a> specifying
the edge indices of the triangles.</p></li>
</ul>
</p></li>
<li><p><strong>prop</strong> (int <a class="reference internal" href="../glossary.html#term-array_like"><span class="xref std std-term">array_like</span></a>, optional) – This keyword argument can be used to attribute property values to
the elements of the TriSurface, like in the <a class="reference internal" href="mesh.html#mesh.Mesh" title="mesh.Mesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code></a> class.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trisurface.TriSurface.read" title="trisurface.TriSurface.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TriSurface.read</span></code></a></dt><dd><p>read a TriSurface from file</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Formex.toSurface</span></code></dt><dd><p>convert a Formex to a TriSurface</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mesh.toSurface</span></code></dt><dd><p>convert a Mesh to a TriSurface</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>This example is a unit square divided in two triangles with the following
following layout and numbering of nodes(n), elements(e) and edges:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n3</span>      <span class="mi">4</span>    <span class="n">n2</span>
  <span class="n">o</span><span class="o">---------</span><span class="n">o</span>
  <span class="o">|</span>        <span class="o">/|</span>
  <span class="o">|</span>  <span class="n">e1</span>   <span class="o">/</span> <span class="o">|</span>
  <span class="o">|</span>      <span class="o">/</span>  <span class="o">|</span>
  <span class="o">|</span>     <span class="o">/</span>   <span class="o">|</span>
 <span class="mi">2</span><span class="o">|</span>    <span class="o">/</span><span class="mi">1</span>   <span class="o">|</span><span class="mi">3</span>
  <span class="o">|</span>   <span class="o">/</span>     <span class="o">|</span>
  <span class="o">|</span>  <span class="o">/</span>      <span class="o">|</span>
  <span class="o">|</span> <span class="o">/</span>   <span class="n">e0</span>  <span class="o">|</span>
  <span class="o">|/</span>        <span class="o">|</span>
  <span class="n">o</span><span class="o">---------</span><span class="n">o</span>
<span class="n">n0</span>     <span class="mi">0</span>     <span class="n">n1</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">eltype</span><span class="o">=</span><span class="s1">&#39;quad4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;tri3-u&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">TriSurface: nnodes: 4, nelems: 2, nplex: 3, level: 2, eltype: tri3</span>
<span class="go">  BBox: [0. 0. 0.], [1. 1. 0.]</span>
<span class="go">  Size: [1. 1. 0.]</span>
<span class="go">  Length: 4.0  Area: 1.0  Volume: 0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
<span class="go">[[0. 0. 0.]</span>
<span class="go"> [1. 0. 0.]</span>
<span class="go"> [1. 1. 0.]</span>
<span class="go"> [0. 1. 0.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">elems</span><span class="p">)</span>
<span class="go">[[0 1 2]</span>
<span class="go"> [2 3 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nedges</span><span class="p">(),</span> <span class="n">S</span><span class="o">.</span><span class="n">nfaces</span><span class="p">())</span>
<span class="go">5 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
<span class="go">[[0 1]</span>
<span class="go"> [2 0]</span>
<span class="go"> [3 0]</span>
<span class="go"> [1 2]</span>
<span class="go"> [2 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">elem_edges</span><span class="p">)</span>
<span class="go">[[0 3 1]</span>
<span class="go"> [4 2 1]]</span>
</pre></div>
</div>
<dl class="py method">
<dt id="trisurface.TriSurface.nedges">
<code class="sig-name descname">nedges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.nedges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.nedges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of edges of the TriSurface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As a side-effect, this computes and stores the
<a class="reference internal" href="mesh.html#mesh.Mesh.edges" title="mesh.Mesh.edges"><code class="xref py py-attr docutils literal notranslate"><span class="pre">edges</span></code></a> and <a class="reference internal" href="mesh.html#mesh.Mesh.elem_edges" title="mesh.Mesh.elem_edges"><code class="xref py py-attr docutils literal notranslate"><span class="pre">elem_edges</span></code></a> arrays.
The returned value is the first dimension of self.edges.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.nfaces">
<code class="sig-name descname">nfaces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.nfaces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.nfaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of faces of the TriSurface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As a side-effect, this computes and stores the
<a class="reference internal" href="mesh.html#mesh.Mesh.edges" title="mesh.Mesh.edges"><code class="xref py py-attr docutils literal notranslate"><span class="pre">edges</span></code></a> and <a class="reference internal" href="mesh.html#mesh.Mesh.elem_edges" title="mesh.Mesh.elem_edges"><code class="xref py py-attr docutils literal notranslate"><span class="pre">elem_edges</span></code></a> arrays.
The returned value is the first dimension of self.elem_edges.
Use self.nelems() to get the number of faces without having the
side effect.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.vertices">
<code class="sig-name descname">vertices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.vertices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.vertices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of the nodes of the TriSurface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The direct use of the <a class="reference internal" href="coords.html#module-coords" title="coords: A structured collection of 3D coordinates."><code class="xref py py-attr docutils literal notranslate"><span class="pre">coords</span></code></a> is prefered over this method.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.shape">
<code class="sig-name descname">shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.shape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of points, edges, faces of the TriSurface.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>ncoords</strong> (<em>int</em>) – The number of vertices</p></li>
<li><p><strong>nedges</strong> (<em>int</em>) – The number of edges</p></li>
<li><p><em>nfaces</em> – The number of faces</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.set_coords">
<code class="sig-name descname">set_coords</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">coords</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.set_coords"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.set_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the coords.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.set_elems">
<code class="sig-name descname">set_elems</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">elems</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.set_elems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.set_elems" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the elems.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.set_edges_faces">
<code class="sig-name descname">set_edges_faces</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">edges</span></em>, <em class="sig-param"><span class="n">faces</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.set_edges_faces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.set_edges_faces" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the edges and faces.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">S</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.append"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge another surface with self.</p>
<p class="rubric">Notes</p>
<p>This just merges the data sets, and does not check
whether the surfaces intersect or are connected!
This is intended mostly for use inside higher level functions.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.read">
<em class="property">classmethod </em><code class="sig-name descname">read</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fn</span></em>, <em class="sig-param"><span class="n">ftype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">convert</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a surface from file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> (<a class="reference internal" href="../glossary.html#term-path_like"><span class="xref std std-term">path_like</span></a>) – <p>The pathname of the file to be read. The name suffix normally
normally specifies the file type. Currently the following
file types can be read:</p>
<ul>
<li><p>obj, off, ply (polygon formats)</p></li>
<li><p>gts (libgts format)</p></li>
<li><p>stl (ascii or binary)</p></li>
<li><p>neu (Gambit neutral)</p></li>
<li><p>smesh (tetgen)</p></li>
<li><p>vtk, vtp (vtk formats)</p></li>
</ul>
<p>Compressed files for the polygon, gts and stl formats are also
supported, if they are compressed with gzip or bzip2 and have
an extra name suffix ‘.gz’ or ‘.bz2’, respectively.
These files are transparently decompressed during reading.
This allows for a very efficient use of storage space for
large models.</p>
</p></li>
<li><p><strong>ftype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the file type. This is (only) needed if the filename
suffix does not specify the file type.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">TriSurface</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">pf</span><span class="o">.</span><span class="n">cfg</span><span class="p">[</span><span class="s1">&#39;datadir&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="s1">&#39;horse.off&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="go">TriSurface: nnodes: 669, nelems: 1334, nplex: 3, level: 2, eltype: tri3</span>
<span class="go">  BBox: [-0.0918 -0.0765 -0.0422], [0.0925 0.0777 0.0428]</span>
<span class="go">  Size: [0.1843 0.1542 0.085 ]</span>
<span class="go">  Length: 0.0  Area: 0.03646  Volume: 0.0002634</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fn</span></em>, <em class="sig-param"><span class="n">ftype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">binary</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">color</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the surface to file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> (<a class="reference internal" href="../glossary.html#term-path_like"><span class="xref std std-term">path_like</span></a>) – The output file name. The suffix will determine the file format,
unless explicitely specified by <code class="docutils literal notranslate"><span class="pre">ftype</span></code>.
Available formats are: ‘pgf’, ‘gts’, ‘off’,
‘stl’, ‘stla’, ‘stlb’, ‘obj’, ‘smesh’, ‘vtp’, ‘vtk’.
If there is no suffix, ‘off’ format is used.
For most file formats, an extra ‘.gz’ or ‘.bz2’ suffix can be
added to have the file transparently be compressed by ‘gzip’ or
‘bzip2’, respectively.</p></li>
<li><p><strong>ftype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>optional</em>) – The output file format. If not provided, it is determined from
the filename suffix.
For a ‘stl’ types, <code class="docutils literal notranslate"><span class="pre">ftype</span></code> may be set to ‘stla’ or ‘stlb’
to force ascii or binary STL format.</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>optional</em>) – A name for the model that will be written into the output file
if it is a ‘pgf’ or ‘obj’ format.</p></li>
<li><p><strong>binary</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, use binary format when the file format supports it.
This is only useful if the file format supports both ascii and
binary formats (currently ‘ply’ and ‘stl’).</p></li>
<li><p><strong>color</strong> (<a class="reference internal" href="../glossary.html#term-color_like"><span class="xref std std-term">color_like</span></a>) – The color of the object to be written in case of a binary stl
type (see also notes).</p></li>
<li><p><strong>kargs</strong> – Extra keyword arguments to be passed to the writer.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the surface has ‘color’ in its <code class="xref py py-class docutils literal notranslate"><span class="pre">Attributes</span></code>, the color
will be written to the file in the case of the formats:
‘pgf’, ‘stlb’, ‘stl’ with <code class="docutils literal notranslate"><span class="pre">binary=True</span></code>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">eltype</span><span class="o">=</span><span class="s1">&#39;quad4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;tri3-u&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">utils</span><span class="o">.</span><span class="n">TempDir</span><span class="p">()</span> <span class="k">as</span> <span class="nb">dir</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">fn</span> <span class="o">=</span> <span class="nb">dir</span> <span class="o">/</span> <span class="s1">&#39;test.off&#39;</span>
<span class="gp">... </span>    <span class="n">S</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Square&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">read_text</span><span class="p">())</span>
<span class="go">Writing surface to file .../test.off (off)</span>
<span class="go">Wrote 4 vertices, 2 faces</span>
<span class="go">OFF</span>
<span class="go"># OFF file written by pyFormex ...</span>
<span class="go"># name=Square</span>
<span class="go">4 2 0</span>
<span class="go">0.0 0.0 0.0</span>
<span class="go">1.0 0.0 0.0</span>
<span class="go">1.0 1.0 0.0</span>
<span class="go">0.0 1.0 0.0</span>
<span class="go">3 0 1 2</span>
<span class="go">3 2 3 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.areaNormals">
<code class="sig-name descname">areaNormals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.areaNormals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.areaNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the area and normal vectors of the surface triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>areas</strong> (<em>ndarray</em>) – A float (nelems,) shaped array with the areas of the triangles.</p></li>
<li><p><strong>fnormals</strong> (<em>ndarray</em>) – A float (nelems, 3) shaped array with the normalized normal
vectors on the triangles.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As a side-effect, the returned arrays are stored in the object,
to avoid recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trisurface.TriSurface.areas" title="trisurface.TriSurface.areas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">areas</span></code></a></dt><dd><p>return only the areas</p>
</dd>
<dt><a class="reference internal" href="#trisurface.TriSurface.normals" title="trisurface.TriSurface.normals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normals</span></code></a></dt><dd><p>return only the normals</p>
</dd>
<dt><a class="reference internal" href="#trisurface.TriSurface.avgVertexNormals" title="trisurface.TriSurface.avgVertexNormals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">avgVertexNormals</span></code></a></dt><dd><p>return averaged normals at the vertices</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">eltype</span><span class="o">=</span><span class="s1">&#39;quad4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;tri3-u&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">areas</span><span class="p">,</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">areaNormals</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>
<span class="go">[0.5 0.5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">normals</span><span class="p">)</span>
<span class="go">[[0. 0. 1.]</span>
<span class="go"> [0. 0. 1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.areas">
<code class="sig-name descname">areas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.areas"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.areas" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the areas of the triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>areas</strong> (<em>ndarray</em>) – A float (nelems,) shaped array with the areas of the triangles.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As a side-effect, the normals are computed as well and both are stored
in the object, to avoid recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="mesh.html#mesh.Mesh.area" title="mesh.Mesh.area"><code class="xref py py-meth docutils literal notranslate"><span class="pre">area()</span></code></a></dt><dd><p>return the total area of the surface</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">eltype</span><span class="o">=</span><span class="s1">&#39;quad4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;tri3-u&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">areas</span><span class="p">())</span>
<span class="go">[0.5 0.5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.normals">
<code class="sig-name descname">normals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.normals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normals on the triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>normals</strong> (<em>ndarray</em>) – A float (nelems, 3) shaped array with the normalized normal
vectors on the triangles.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As a side-effect, the areas are computed as well and both are stored
in the object, to avoid recalculation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trisurface.TriSurface.avgVertexNormals" title="trisurface.TriSurface.avgVertexNormals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">avgVertexNormals</span></code></a></dt><dd><p>return averaged normals at the vertices</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">eltype</span><span class="o">=</span><span class="s1">&#39;quad4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;tri3-u&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">normals</span><span class="p">())</span>
<span class="go">[[0. 0. 1.]</span>
<span class="go"> [0. 0. 1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.avgVertexNormals">
<code class="sig-name descname">avgVertexNormals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.avgVertexNormals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.avgVertexNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the average normals at the vertices.</p>
<p>TriSurfaces are often used as an approximation of a smooth surface.
In such case, a more realistic rendering is obtained by using the
average normals at the vertices instead of the facet normals.
The normals are computed as the average of the normals on the faces
connected to the node, using the angle between the edges as weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>normals</strong> (<em>ndarray</em>) – A float (ncoords, 3) shaped array with the normalized
averaged normal vectors at the nodes.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="geomtools.html#geomtools.polygonAvgNormals" title="geomtools.polygonAvgNormals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geomtools.polygonAvgNormals</span></code></a></dt><dd><p>the function used to compute the average normals and providing more options and examples.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>The model is an octaeder having its vertices in the directions
of the global axes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyformex</span> <span class="kn">import</span> <span class="n">simple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">simple</span><span class="o">.</span><span class="n">sphere</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="s1">&#39;octa&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">avgVertexNormals</span><span class="p">())</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]</span>
<span class="go"> [-1.  0.  0.]</span>
<span class="go"> [ 0. -1.  0.]</span>
<span class="go"> [ 0.  0. -1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.volume">
<code class="sig-name descname">volume</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.volume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.volume" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the enclosed volume of the surface.</p>
<p>This will only be correct if the surface is a closed manifold.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.nodalWeights">
<code class="sig-name descname">nodalWeights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.nodalWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.nodalWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns point weight based on adjacent area weight.</p>
<p>One third of the area of each triangle is attributed to each of
its nodes, and the results are summed at the nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>np.ndarray</em> – Area based point weight array.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyformex.simple</span> <span class="kn">import</span> <span class="n">Cube</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">Cube</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;tri3-u&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodalWeights</span><span class="p">())</span>
<span class="go">[1.     0.6667 0.6667 0.6667 0.6667 0.6667 1.     0.6667]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">nodalWeights</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">6.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.inertia">
<code class="sig-name descname">inertia</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span><span class="o">=</span><span class="default_value">'C'</span></em>, <em class="sig-param"><span class="n">density</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">totalmass</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.inertia"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Return inertia related quantities of the surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>'C' | 'W' | 'X' | 'A' | 'V'</em>) – <p>Defines how the mass is distributed over the model.</p>
<ul>
<li><p>’C’: The mass of each triangle is concentrated at
the centroid of the triangle. This is the default.</p></li>
<li><p>’W’: The mass of each triangle is concentrated at the nodes
of the triangles, attributing ont third to each.</p></li>
<li><p>’X’: The mass is concentrated at the nodes, attributing an
equal share of the total mass to each of them.</p></li>
<li><p>’A’: The mass is evenly distributed over the triangles. This
is currently not implemented!</p></li>
<li><p>’V’, the mass is evenly distributed over the volume inside
the surface.</p></li>
</ul>
</p></li>
<li><p><strong>density</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – A constant density (mass per unit area, or mass per unit volume
with <code class="docutils literal notranslate"><span class="pre">model='V'</span></code>. This allows the returned inertia values to
be realistic.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><a class="reference internal" href="inertia.html#inertia.Inertia" title="inertia.Inertia"><code class="xref py py-class docutils literal notranslate"><span class="pre">Inertia</span></code></a> – An Inertia instance with the following attributes:</p>
<ul class="simple">
<li><p>mass: the total mass (float)</p></li>
<li><p>ctr:: the center of mass: float (3,)</p></li>
<li><p>tensor: the inertia tensor in the central axes: shape (3,3)</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘A’ model is currently not implemented. The ‘C’ model
neglects the inertia of each triangle around its own centroid.</p>
<p>It is currently not possible to specify variable density.</p>
<p class="rubric">Examples</p>
<p>This is an approximation of a spherical surface with radius R=1.
A perfect spherical surface with density 1 has a mass
<code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">4</span> <span class="pre">πR^2</span> <span class="pre">=</span> <span class="pre">12.566...</span></code> and a rotational inertia
<code class="docutils literal notranslate"><span class="pre">2/3</span> <span class="pre">MR^2</span> <span class="pre">=</span> <span class="pre">8.377...</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyformex.simple</span> <span class="kn">import</span> <span class="n">sphere</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">inertia</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
<span class="go">12.50...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>
<span class="go">[[ 8.2735  0.     -0.    ]</span>
<span class="go"> [ 0.      8.2735  0.    ]</span>
<span class="go"> [-0.      0.      8.2735]]</span>
</pre></div>
</div>
<p>The results are smaller than the theoretical, because the nodes
are on the sphere, but the triangle centroids are slightly inside.
Therefore, concentrating the mass at the nodes gives better results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">inertia</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
<span class="go">12.50...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>
<span class="go">[[ 8.3375  0.     -0.    ]</span>
<span class="go"> [ 0.      8.3375  0.    ]</span>
<span class="go"> [-0.      0.      8.3375]]</span>
</pre></div>
</div>
<p>Let’s use an area-equivalent spherical approximation instead: this
has the nodes slightly outside the sphere and the centroids inside.
As expected, it delivers the correct mass.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SA</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">equiv</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">SA</span><span class="o">.</span><span class="n">inertia</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
<span class="go">12.566...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>
<span class="go">[[ 8.3533 -0.     -0.    ]</span>
<span class="go"> [-0.      8.3533 -0.    ]</span>
<span class="go"> [-0.     -0.      8.3533]]</span>
</pre></div>
</div>
<p>Considered as a volume, the mass of a perfect sphere is
4/3 πR^2 = 4.188… and the inertia is 2/5 MR^2 = 1.675….</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">inertia</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
<span class="go">4.1526...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>
<span class="go">[[ 1.6515  0.     -0.    ]</span>
<span class="go"> [ 0.      1.6515 -0.    ]</span>
<span class="go"> [-0.     -0.      1.6515]]</span>
</pre></div>
</div>
<p>With a volume-equivalent model, we get:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SV</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">equiv</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="o">=</span> <span class="n">SV</span><span class="o">.</span><span class="n">inertia</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="s1">&#39;V&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
<span class="go">4.188...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">tensor</span><span class="p">)</span>
<span class="go">[[ 1.6755 -0.      0.    ]</span>
<span class="go"> [-0.      1.6755 -0.    ]</span>
<span class="go"> [ 0.     -0.      1.6755]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.curvature">
<code class="sig-name descname">curvature</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">neigh</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.curvature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute curvature parameters at the nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>neigh</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – The maximum number of edge steps allowed from a node to its
neigbors to have them included in the node’s neigborhood.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><a class="reference internal" href="utils.html#utils.Namespace" title="utils.Namespace"><code class="xref py py-class docutils literal notranslate"><span class="pre">Namespace</span></code></a> – An object with the following attributes:</p>
<ul class="simple">
<li><p>S: the shape index</p></li>
<li><p>C: the curvedness</p></li>
<li><p>K: the Gaussian curvature</p></li>
<li><p>H: the mean curvature</p></li>
<li><p>k1: the first principal curvature</p></li>
<li><p>k2: the second principal curvature</p></li>
<li><p>d1: the first principal direction</p></li>
<li><p>d2: the second principal direction</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Algorithms are based on Koenderink and Van Doorn, 1992 and
Dong and Wang, 2005.</p>
<p>The shape index varies between -1 and +1 and classifies the
surface as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">concave</span>     <span class="n">concave</span>                   <span class="n">convex</span>     <span class="n">convex</span>
  <span class="n">ellipsoid</span>   <span class="n">cylinder</span>   <span class="n">hyperboloid</span>    <span class="n">cylinder</span>   <span class="n">ellipsoid</span>
 <span class="o">+----------+----------+--------------+----------+----------+</span>
<span class="o">-</span><span class="mi">1</span>        <span class="o">-</span><span class="mi">5</span><span class="o">/</span><span class="mi">8</span>       <span class="o">-</span><span class="mi">3</span><span class="o">/</span><span class="mi">8</span>            <span class="mi">3</span><span class="o">/</span><span class="mi">8</span>        <span class="mi">5</span><span class="o">/</span><span class="mi">8</span>         <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.surfaceType">
<code class="sig-name descname">surfaceType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.surfaceType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.surfaceType" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the TriSurface is a manifold, orientable and closed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>manifold</strong> (<em>bool</em>) – True if the surface is a manifold</p></li>
<li><p><strong>orientable</strong> (<em>bool</em>) – True if the surface is an orientable manifold</p></li>
<li><p><strong>closed</strong> (<em>bool</em>) – True if the surface is a closed manifold</p></li>
<li><p><strong>mincon</strong> (<em>int</em>) – The minimum number of triangles at any edge</p></li>
<li><p><strong>maxcon</strong> (<em>int</em>) – The maximum  number of triangles at any edge</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trisurface.TriSurface.isManifold" title="trisurface.TriSurface.isManifold"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isManifold</span></code></a></dt><dd><p>check if a surface is a manifold</p>
</dd>
<dt><a class="reference internal" href="#trisurface.TriSurface.isOrientable" title="trisurface.TriSurface.isOrientable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isOrientable</span></code></a></dt><dd><p>check if a surface is an orientable manifold</p>
</dd>
<dt><a class="reference internal" href="#trisurface.TriSurface.isClosedManifold" title="trisurface.TriSurface.isClosedManifold"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isClosedManifold</span></code></a></dt><dd><p>check if a surface is a closed manifold</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>A Möbius ring is an open non-orientable manifold. A Klein bottle
is a closed non-orientable (self-intersecting) manifold.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyformex</span> <span class="kn">import</span> <span class="n">simple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simple</span><span class="o">.</span><span class="n">sphere</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">surfaceType</span><span class="p">()</span>
<span class="go">(True, True, True, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simple</span><span class="o">.</span><span class="n">MoebiusRing</span><span class="p">()</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span><span class="o">.</span><span class="n">surfaceType</span><span class="p">()</span>
<span class="go">(True, False, False, 1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyformex.examples.KleinBottle</span> <span class="kn">import</span> <span class="n">KleinBottle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">KleinBottle</span><span class="p">()</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">surfaceType</span><span class="p">()</span>
<span class="go">(True, True, False, 1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">fuse</span><span class="p">()</span><span class="o">.</span><span class="n">surfaceType</span><span class="p">()</span>
<span class="go">(True, False, True, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.isManifold">
<code class="sig-name descname">isManifold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.isManifold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.isManifold" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the TriSurface is a manifold.</p>
<p>A surface is a manifold if for every point of the surface a small
sphere exists that cuts the surface to a part that can continuously
be deformed to an open disk.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>bool</em> – True if the surface is a manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.isClosedManifold">
<code class="sig-name descname">isClosedManifold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.isClosedManifold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.isClosedManifold" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the TriSurface is a closed manifold.</p>
<p>A closed manifold is a manifold where each edge has exactly
two triangles connected to it.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>bool</em> – True if the surface is a closed manifold.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.isConvexManifold">
<code class="sig-name descname">isConvexManifold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.isConvexManifold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.isConvexManifold" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the TriSurface is a convex manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>bool</em> – True if the surface is a convex manifold.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyformex</span> <span class="kn">import</span> <span class="n">simple</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">simple</span><span class="o">.</span><span class="n">sphere</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">isConvexManifold</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.isOrientable">
<code class="sig-name descname">isOrientable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.isOrientable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.isOrientable" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether the TriSurface is an orientable manifold.</p>
<p>A surface is an orientable manifold if it is a manifold and if
for all edges where two triangles meet, the triangles have the
two nodes in opposite order in their element definition.
This also means that if the two triangles are rotated around the
edge to fall in the same plane, with their third vertex at
opposite sides of the edge, the triangles have the same positive
normal.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>bool</em> – True if the surface is orientable.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trisurface.TriSurface.amborientedEdges" title="trisurface.TriSurface.amborientedEdges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">amborientedEdges</span></code></a></dt><dd><p>list the edges where the normals are opposite</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.nonManifoldEdges">
<code class="sig-name descname">nonManifoldEdges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.nonManifoldEdges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.nonManifoldEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the non-manifold edges.</p>
<p>Non-manifold edges are edges having more than two triangles
connected to them.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>int array</em> – The indices of the non-manifold edges in a TriSurface.
These indices refer to the list of edges as stored in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">edges</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.nonManifoldEdgesFaces">
<code class="sig-name descname">nonManifoldEdgesFaces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.nonManifoldEdgesFaces"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.nonManifoldEdgesFaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the non-manifold edges and faces.</p>
<p>Non-manifold edges are edges that are connected to more than
two faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>edges</strong> (<em>int array</em>) – The indices of the non-manifold edges.</p></li>
<li><p><strong>faces</strong> (<em>int array</em>) – The indices of the faces connected to any of the non-manifold edges.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.removeNonManifold">
<code class="sig-name descname">removeNonManifold</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.removeNonManifold"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.removeNonManifold" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the non-manifold edges.</p>
<p>Removes the non-manifold edges by iteratively applying
<code class="xref py py-meth docutils literal notranslate"><span class="pre">removeDuplicate()</span></code> and <a class="reference internal" href="#trisurface.TriSurface.collapseEdge" title="trisurface.TriSurface.collapseEdge"><code class="xref py py-meth docutils literal notranslate"><span class="pre">collapseEdge()</span></code></a> until no edge
has more than two connected triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>TriSurface</em> – The reduced surface.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.amborientedEdges">
<code class="sig-name descname">amborientedEdges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.amborientedEdges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.amborientedEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the amboriented edges.</p>
<p>Amboriented edges are edges where two triangles are connected
with different orientation, making the surface non-orientable.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>int array</em> – The indices of the amboriented edges in a TriSurface.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This requires that the surface is a manifold. Non-manifold edges
are also amboriented, but are not included in this list. An error is
raised if there are non-manifold edges.</p>
<p>In a manifold surface there are only two triangles possible at an
edge,and they should have the edge nodes numbered in different order
for the surface to be orientable. Thus all the edges should come out
as unique when permutations=’none’ is used
in <a class="reference internal" href="arraytools.html#arraytools.uniqueRowsIndex" title="arraytools.uniqueRowsIndex"><code class="xref py py-func docutils literal notranslate"><span class="pre">arraytools.uniqueRowsIndex()</span></code></a>. The non-unique edges are
the amboriented edges.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.borderEdges">
<code class="sig-name descname">borderEdges</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.borderEdges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.borderEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the border edges of a TriSurface.</p>
<p>Border edges are edges that belong to only one element.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>bool ndarray</em> – An array of length self.nedges() that is True for the
edges that are on the border of the surface.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">eltype</span><span class="o">=</span><span class="s1">&#39;quad4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;tri3-u&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">borderEdges</span><span class="p">())</span>
<span class="go">[ True False  True  True  True]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.borderEdgeNrs">
<code class="sig-name descname">borderEdgeNrs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.borderEdgeNrs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.borderEdgeNrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the numbers of the border edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>int array</em> – The indices of the border edges.
These indices refer to the list of edges as stored in
<code class="xref py py-attr docutils literal notranslate"><span class="pre">edges</span></code>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">eltype</span><span class="o">=</span><span class="s1">&#39;quad4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;tri3-u&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">borderEdgeNrs</span><span class="p">())</span>
<span class="go">[0 2 3 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.borderNodeNrs">
<code class="sig-name descname">borderNodeNrs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.borderNodeNrs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.borderNodeNrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect the border nodes of TriSurface.</p>
<p>The border nodes are the vertices belonging to the border edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>int array</em> – The indices of the border nodes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.checkBorder">
<code class="sig-name descname">checkBorder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.checkBorder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.checkBorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the border contours of a TriSurface.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="elements.html#elements.Elems" title="elements.Elems"><code class="xref py py-class docutils literal notranslate"><span class="pre">Elems</span></code></a> – A list of connectivity tables. Each table holds the
subsequent line segments of one continuous contour of the border
of the surface.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">eltype</span><span class="o">=</span><span class="s1">&#39;quad4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s1">&#39;tri3-u&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span><span class="o">.</span><span class="n">checkBorder</span><span class="p">()</span>
<span class="go">[Elems([[0, 1],</span>
<span class="go">       [1, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 0]], eltype=Line2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.border">
<code class="sig-name descname">border</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">compact</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.border"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.border" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the border meshes of a TriSurface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>compact</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True (default), the returned meshes are compacted.
Setting compact=False will return all Meshes with the full
surface coordinate sets. This is e.g useful for filling the
border and merging the result with the original surface.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of <a class="reference internal" href="mesh.html#mesh.Mesh" title="mesh.Mesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code></a> – The complete border of the surface is returned as a list
of plex-2 Meshes. Each Mesh constitutes a continuous part
of the border.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.fillBorder">
<code class="sig-name descname">fillBorder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'radial'</span></em>, <em class="sig-param"><span class="n">dir</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">compact</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.fillBorder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.fillBorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the border areas of a surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – One of the methods accepted by the <a class="reference internal" href="#trisurface.fillBorder" title="trisurface.fillBorder"><code class="xref py py-func docutils literal notranslate"><span class="pre">fillBorder()</span></code></a> function:
‘radial’, ‘border’ or ‘planar.</p></li>
<li><p><strong>dir</strong> ((3,) <a class="reference internal" href="../glossary.html#term-array_like"><span class="xref std std-term">array_like</span></a>, optional) – Only used with <code class="docutils literal notranslate"><span class="pre">method='planar'</span></code>: the projection direction.
See <a class="reference internal" href="#trisurface.fillBorder" title="trisurface.fillBorder"><code class="xref py py-func docutils literal notranslate"><span class="pre">fillBorder()</span></code></a>.</p></li>
<li><p><strong>compact</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True (default), the returned surfaces are compacted. If False,
they still retain all the nodes of the original surface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><em>list of TriSurface</em> – The list of surfaces that fill all the border contours of the
input surface as obtained by :meth:border’. If the surface
is initially closed, an empty list is returned.</p>
<p>The surfaces will have property values higher than those of
the parent surface. Thus, if they are added to the surface
to close the holes in it, the different parts can still be
identified.</p>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trisurface.TriSurface.close" title="trisurface.TriSurface.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a></dt><dd><p>closes the surface by adding the border fills</p>
</dd>
<dt><a class="reference internal" href="#trisurface.fillBorder" title="trisurface.fillBorder"><code class="xref py py-func docutils literal notranslate"><span class="pre">trisurface.fillBorder()</span></code></a></dt><dd><p>fill a contour with a TriSurface</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.close">
<code class="sig-name descname">close</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'radial'</span></em>, <em class="sig-param"><span class="n">dir</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close all the holes in a surface.</p>
<p>Computes the hole filling surfaces and adds them to the
surface to make it a closed surface. Parameters are like for
<a class="reference internal" href="#trisurface.fillBorder" title="trisurface.fillBorder"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fillBorder()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>TriSurface</em> – A TriSurface which is the merging of the input surface
with the surfaces returned by <a class="reference internal" href="#trisurface.fillBorder" title="trisurface.fillBorder"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fillBorder()</span></code></a>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trisurface.fillBorder" title="trisurface.fillBorder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fillBorder</span></code></a></dt><dd><p>compute the hole filling surfaces</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.edgeLengths">
<code class="sig-name descname">edgeLengths</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.edgeLengths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.edgeLengths" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the lengths of all edges</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>float array</em> – The length of all the edges, in the order of <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mesh.edges</span></code>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As a side effect, this computes and stores the connectivities
of the edges to nodes and of the elements to edges in the
attributes <code class="docutils literal notranslate"><span class="pre">edges</span></code>, resp. <code class="docutils literal notranslate"><span class="pre">elem_edges</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.edgeAngles">
<code class="sig-name descname">edgeAngles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">return_mask</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.edgeAngles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.edgeAngles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the signed angles over all edges.</p>
<p>The edge angles are the angles between the faces connected to
that edge. It is the angle between the 2 face normals. The surface
should be a manifold (having max. 2 faces per edge). The returned
angles are in degrees in the range ]-180, 180]. The sign of the
angle determines the convexity of the surface over that edge:</p>
<ul class="simple">
<li><p>angle &lt; 0: concave</p></li>
<li><p>angle = 0: flat</p></li>
<li><p>angle &gt; 0: convex</p></li>
<li><p>angle = 180: folded</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>return_mask</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, also returns the mask of edges connecting two faces.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>angles</strong> (<em>float array</em>) – An array with for each edge the angle between the normals on
the two faces sharing that edge. For edges connected to only
one element, a value 0 is returned.</p></li>
<li><p><strong>mask</strong> (<em>bool array</em>) – True for the edges that connect two faces. Only returned if
return_mask is True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As a side effect, this method also sets the area, normals,
elem_edges and edges attributes.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.featureEdges">
<code class="sig-name descname">featureEdges</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">angle</span><span class="o">=</span><span class="default_value">60.0</span></em>, <em class="sig-param"><span class="n">minangle</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.featureEdges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.featureEdges" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the feature edges of the surface.</p>
<p>Feature edges are edges that are prominent features of the geometry.
They are either border edges or edges where the normals on the two
adjacent triangles differ more than a given value.
The non feature edges then represent edges on a rather smooth surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>angle</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The minimum value of the angle (in degrees) between the normals on
two adjacent triangles in order for the edge to be considered a
feature edge.</p></li>
<li><p><strong>minangle</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – The maximum negative edge angle value for concave edges to be
considered feature edges. If not specified, this is set equal
to -angle.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>bool array</em> – An array with shape (nedg,) where the feature edges
are marked True. These are the edges where sel.edgeAngles()
is outside the range [minangle, angle].</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As a side effect, this also sets the <cite>elem_edges</cite> and <cite>edges</cite>
attributes, which can be used to get the edge data with the same
numbering as used in the returned mask. Thus, the following
constructs a Mesh with the feature edges of a surface S:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">featureEdges</span><span class="p">()</span>
<span class="n">Mesh</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span><span class="n">S</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.quality">
<code class="sig-name descname">quality</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.quality"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.quality" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a quality measure for the triangle schapes.</p>
<p>The quality of a triangle is defined as the ratio of the square
root of its surface area to its perimeter, divided by the same
ratio for an equilateral triangle with the same area.  The quality
thus has a value 1.0 for an equilateral triangle and tends to 0.0
for a very stretched triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>array</em> – A float array with the quality of each of the triangles.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>This model has four triangles with increasing shear. The first
is an equilateral triangle. The last is the most obtuse.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">Formex</span><span class="p">(</span><span class="s1">&#39;3:064&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">Formex</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">F</span><span class="o">.</span><span class="n">shear</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">trl</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]]</span>
<span class="gp">... </span>    <span class="p">)</span><span class="o">.</span><span class="n">toSurface</span><span class="p">()</span><span class="o">.</span><span class="n">scale</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">3.</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">areas</span><span class="p">())</span>
<span class="go">[0.433 0.433 0.433 0.433]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">perimeters</span><span class="p">())</span>
<span class="go">[3.     3.1889 3.7321 4.5023]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">aspectRatio</span><span class="p">())</span>
<span class="go">[1.1547 2.0207 3.4641 5.4848]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">quality</span><span class="p">())</span>
<span class="go">[1.     0.9408 0.8038 0.6663]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.aspectRatio">
<code class="sig-name descname">aspectRatio</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.aspectRatio"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.aspectRatio" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the apect ratio of the triangles of the surface.</p>
<p>The aspect ratio of a triangle is the ratio of the longest edge
over the smallest altitude of the triangle.
Equilateral triangles have the smallest aspect ratio: 2/√3.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>array</em> – A float array with the aspect ratio of each of the triangles.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trisurface.TriSurface.quality" title="trisurface.TriSurface.quality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quality</span></code></a></dt><dd><p>compute a quality measure for triangular meshes</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.perimeters">
<code class="sig-name descname">perimeters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.perimeters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.perimeters" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the perimeters of all triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>array</em> – A float array with the perimeter of each of the triangles.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trisurface.TriSurface.quality" title="trisurface.TriSurface.quality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quality</span></code></a></dt><dd><p>compute a quality measure for triangular meshes</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.smallestAltitude">
<code class="sig-name descname">smallestAltitude</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.smallestAltitude"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.smallestAltitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the smallest altitude of the triangles of the surface.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.longestEdge">
<code class="sig-name descname">longestEdge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.longestEdge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.longestEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the longest edge of the triangles of the surface.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.shortestEdge">
<code class="sig-name descname">shortestEdge</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.shortestEdge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.shortestEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the shortest edge of the triangles of the surface.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.stats">
<code class="sig-name descname">stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a text with full statistics about the surface.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.distanceOfPoints">
<code class="sig-name descname">distanceOfPoints</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">X</span></em>, <em class="sig-param"><span class="n">return_points</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.distanceOfPoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.distanceOfPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the distances of points X to the TriSurface.</p>
<p>The distance of a point is the minimum of:
- the smallest perpendicular distance to any of the facets;
- the smallest perpendicular distance to any of the edges;
- the smallest distance to any of the vertices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<a class="reference internal" href="../glossary.html#term-coords_like"><span class="xref std std-term">coords_like</span></a>) – An (nX,3) shaped float array with the coordinates of nX points.</p></li>
<li><p><strong>return_points</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, also returns an array with the closest points on the
surface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>dist</strong> (<em>array</em>) – A float array of length nX with the distance of the points to the
surface.</p></li>
<li><p><strong>footpoints</strong> (<em>array</em>) – Only returned if return_points = True: an array with shape (nX,3)
holding the coordinates of the footpoints on the surface.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.degenerate">
<code class="sig-name descname">degenerate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.degenerate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.degenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the degenerate faces according to area and normals.</p>
<p>A triangle is degenerate if its area is less or equal to zero or the
normal has a nan.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><em>int array</em> – The sorted list of indices of the degenerate elements.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.removeDegenerate">
<code class="sig-name descname">removeDegenerate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">compact</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.removeDegenerate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.removeDegenerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the degenerate elements from a TriSurface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>compact</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, the TriSurface is compacted after removing the
degenerate elements.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>TriSurface</em> – A TriSurface with all the degenerate elements removed.
By default, the coords attribute is unaltered and will still contain
all points, even ones that are no longer connected to any element.
If <code class="docutils literal notranslate"><span class="pre">compact=True</span></code>, unused nodes are removed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.collapseEdge">
<code class="sig-name descname">collapseEdge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">edg</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.collapseEdge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.collapseEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Collapse an edge in a TriSurface.</p>
<p>Collapsing an edge removes the triangles connected to the edge
and replaces the two vertices of the edge with a single one,
placed at the center of the edge.
Triangles connected to one of the edge vertices, will
become connected to the new vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edg</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – The index of the edg to be removed. This is an index in the
<code class="xref py py-attr docutils literal notranslate"><span class="pre">edges</span></code> array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>TriSurface</em> – An almost equivalent surface with the specified edge removed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.offset">
<code class="sig-name descname">offset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">distance</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.offset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.offset" title="Permalink to this definition">¶</a></dt>
<dd><p>Offset a surface with a certain distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>distance</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Distance over which the points should be moved.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>TriSurface</em> – A TriSurface obtaine by moving all the nodes of the input surface
over the specified distance in the direction of the averaged
normal vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.dualMesh">
<code class="sig-name descname">dualMesh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'median'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.dualMesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.dualMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dual mesh of a compacted triangulated surface.</p>
<p>Creates a new triangular mesh where all triangles with prop <cite>p</cite>
represent the dual mesh region around the original surface node <cite>p</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>method</strong> (<em>'median' | 'voronoi'</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Mesh</em> – The dual Mesh. The elements have property numbers equal to
the node number around which they are based.</p></li>
<li><p><strong>.. Note</strong> (<em>This needs more explanation.</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.partitionByAngle">
<code class="sig-name descname">partitionByAngle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">angle</span><span class="o">=</span><span class="default_value">60.0</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">'number'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.partitionByAngle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.partitionByAngle" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition the surface by splitting it at sharp edges.</p>
<p>The surface is partitioned in parts in which all elements can be
reached without ever crossing a sharp edge angle. More precisely,
any two triangles will belong to the same part if the can be connected
by a line in the surface that does not cross an edge between
two elements having their normals differ more than the specified
angle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>angle</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The minimum value of the angle (in degrees) between the normals on
two adjacent triangles in order for the edge to be considered a
sharp edge.</p></li>
<li><p><strong>sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – <p>Defines how the resulting parts are sorted (by assigning them
increasing part numbers). The following sort criteria are currently
defined (any other value will return the parts unsorted):</p>
<ul>
<li><p>’number’: sort in decreasing order of the number of triangles
in the part. This is the default.</p></li>
<li><p>’area’: sort according to decreasing surface area of the part.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>int array</em> – An int array specifying for each triangle to which part it belongs.
Values are in the range 0..nparts.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>In order for the operation to be non-trivial, the specified edges,
possibly together with (parts of) the border, should form one or
more closed loops.</p>
<p>Beware that the existence of degenerate elements may cause
unexpected results. If unsure, use the <a class="reference internal" href="#trisurface.TriSurface.removeDegenerate" title="trisurface.TriSurface.removeDegenerate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">removeDegenerate()</span></code></a>
method first to remove those elements.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.cutWithPlane1">
<code class="sig-name descname">cutWithPlane1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">side</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">return_intersection</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">atol</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.cutWithPlane1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.cutWithPlane1" title="Permalink to this definition">¶</a></dt>
<dd><p>Cut a surface with a plane.</p>
<p>Cut the surface with a plane defined by a point p and normal n.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is experimental and may not work correctly.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (float <a class="reference internal" href="../glossary.html#term-array_like"><span class="xref std std-term">array_like</span></a> (3,)) – A point in the cutting plane.</p></li>
<li><p><strong>n</strong> (float <a class="reference internal" href="../glossary.html#term-array_like"><span class="xref std std-term">array_like</span></a> (3,)) – The normal vector to the cutting plane.</p></li>
<li><p><strong>side</strong> (<em>'' | '+' | '-'</em>) – Selects the returned parts. Default (‘’) is to return a tuple
of two surfaces, with the parts at the positive,
resp. negative side of the plane, as defined by the normal vector.
If a ‘+’ or ‘-‘ is specified, only the corresponding part
is returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Spos</strong> (<em>TriSurface, optional</em>) – The part of the surfacec at the positive side of thr plane (p,n).
Only returned if side is ‘’ or  ‘+’.</p></li>
<li><p><strong>Sneg</strong> (<em>TriSurface, optional</em>) – The part of the surfacec at the negative side of thr plane (p,n).
Only returned if side is ‘’ or  ‘-‘.</p></li>
<li><p><em>The returned surfaces have their normals fixed wherever possible.</em></p></li>
<li><p><em>Prop values are set containing the triangle number in the</em></p></li>
<li><p><em>original surface from which the elements resulted.</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.cutWithPlane">
<code class="sig-name descname">cutWithPlane</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.cutWithPlane"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.cutWithPlane" title="Permalink to this definition">¶</a></dt>
<dd><p>Cut a surface with a plane or a set of planes.</p>
<p>Cut the surface with one or more planes and return either one side
or both. This uses a conversion to a 3-plex Formex to do the
cutting, and then converts the results back to TriSurface(s).
The parameters are the same as in <code class="xref py py-meth docutils literal notranslate"><span class="pre">Formex.CutWithPlane()</span></code>.
The returned surface(s) will have the normals fixed wherever possible.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.intersectionWithPlane">
<code class="sig-name descname">intersectionWithPlane</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">p</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">atol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">'number'</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.intersectionWithPlane"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.intersectionWithPlane" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection lines with plane (p,n).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<a class="reference internal" href="../glossary.html#term-coords_like"><span class="xref std std-term">coords_like</span></a> (3,)) – A point in the cutting plane.</p></li>
<li><p><strong>n</strong> (<a class="reference internal" href="../glossary.html#term-coords_like"><span class="xref std std-term">coords_like</span></a> (3,)) – The positive normal on the plane</p></li>
<li><p><strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Tolerance value to consider points lying in the plane. A small
positive value is recommended in order to include triangle edges
that happen to fall exactly in the cutting plane.</p></li>
<li><p><strong>sort</strong> (<em>'number' | 'distance'</em>) – The sorting method for the connected components in the output Mesh.
The default ‘number’ sorts in decreasing number of elements in the
component. Setting to ‘distance’ will sort the parts according to
increasing distance from the point p.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Mesh</em> – The intersection of the TriSurface with the plane. This is a Mesh
of eltype ‘line’. The line segments in the Mesh are ordered in a
way to form continuous lines. The Mesh has property numbers such
that all segments forming a single continuous part have the same
property value. The parts are assigned property numbers
according to their sort order.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The splitProp() method can be used to get a list of separate Meshes.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.slice">
<code class="sig-name descname">slice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dir</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">nplanes</span><span class="o">=</span><span class="default_value">20</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.slice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Intersect a surface with a series of parallel planes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dir</strong> (int | <a class="reference internal" href="../glossary.html#term-array_like"><span class="xref std std-term">array_like</span></a> (3,)) – The direction of the normal on the planes. A single
int (0..2) may be used to specify one of the global axes.</p></li>
<li><p><strong>nplanes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – The number of planes to be used. The planes are spread at
equal distances over the bbox of the surface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of <a class="reference internal" href="mesh.html#mesh.Mesh" title="mesh.Mesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code></a> – A list of <cite>nplanes</cite> Meshes of type ‘line2’, being the
intersections of the surface with each of the planes.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The intersections are obtained with <a class="reference internal" href="#trisurface.TriSurface.intersectionWithPlane" title="trisurface.TriSurface.intersectionWithPlane"><code class="xref py py-meth docutils literal notranslate"><span class="pre">intersectionWithPlane()</span></code></a>.
See there for more dretails on the returned Meshes.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.refine">
<code class="sig-name descname">refine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_edges</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_cost</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'gts'</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.refine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine a TriSurface.</p>
<p>Refining a TriSurface means increasing the number of triangles and
reducing their size, while keeping the changes to the modeled surface
minimal.
Construct a refined version of the surface.
This uses the external program <cite>gtsrefine</cite>. The surface
should be a closed orientable non-intersecting manifold.
Use the <a class="reference internal" href="#trisurface.TriSurface.check" title="trisurface.TriSurface.check"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check()</span></code></a> method to find out.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><cite>max_edges</cite>: int: stop the refining process if the number of
edges exceeds this value</p></li>
<li><p><cite>min_cost</cite>: float: stop the refining process if the cost of refining
an edge is smaller</p></li>
<li><p><cite>log</cite>: boolean: log the evolution of the cost</p></li>
<li><p><cite>verbose</cite>: boolean: print statistics about the surface</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.similarity">
<code class="sig-name descname">similarity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">S</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.similarity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the similarity with another TriSurface.</p>
<p>Compute a quantitative measure of the similarity of the volumes
enclosed by two TriSurfaces. Both the calling and the passed
TriSurface should be closed manifolds (see <a class="reference internal" href="#trisurface.TriSurface.isClosedManifold" title="trisurface.TriSurface.isClosedManifold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isClosedManifold()</span></code></a>).</p>
<p>Returns a tuple (jaccard, dice, overlap).
If A and B are two closed manifolds, VA and VB are their respective
volumes, VC is the volume of the intersection of A and B, and VD is
the volume of the union of A and B, then the following similarity
measures are defined:</p>
<ul class="simple">
<li><p>jaccard coefficient: VC / VD</p></li>
<li><p>dice: 2 * VC / (VA + VB)</p></li>
<li><p>overlap: VC / min(VA,VB)</p></li>
</ul>
<p>Both jaccard and dice range from 0 when the surfaces are completely
disjoint to 1 when the surfaces are identical. The overlap coefficient
becomes 1 when one of the surfaces is completely inside the other.</p>
<p>This method uses gts library to compute the intersection or union.
If that fails, nan values are returned.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.fixNormals">
<code class="sig-name descname">fixNormals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">outwards</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">return_parts</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.fixNormals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.fixNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix the orientation of the normals.</p>
<p>Some surface operations may result in improperly oriented normals,
switching directions from one triangle to the adjacent one.
This method tries to reverse triangles with improperly oriented
normals so that a singly oriented surface may be achieved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>'admesh' | 'internal'</em>) – The method to be used. If not specified, the default ‘internal’
is used and a warning is shown about the changed default.
The ‘internal’ method does not rely on external software, and is
relatively fast. As it does not fuse the nodes nor compacts the
node array, it guarantees that the numbering of nodes and elements
is retained.
The ‘admesh’ uses an external program and needs to write the
surface to a file and read it back. This method will always
do a fuse and compaction, so if the surface was not fused and
compacted before the call, the result may have different node
and/or element numberings.</p></li>
<li><p><strong>outwards</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True (default), a test is done whether the surface is a closed
manifold, or a set of closed manifolds, and if so, the normals are
oriented outwards. Setting this value to False may result in a
closed surfaces with all normals pointing inside.</p></li>
<li><p><strong>return_parts</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, also returns an index identifying to which connected part
each of the triangles belong. Part numbers are in order of
decreasing number of triangles.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.11)"><strong>ValueError</strong></a> – if the surface is not a manifold. Such a surface is not: orientable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.fixNormals_internal">
<code class="sig-name descname">fixNormals_internal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.fixNormals_internal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.fixNormals_internal" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix normals using an internal algorithm.</p>
<p>This is normally invoked as <code class="docutils literal notranslate"><span class="pre">fixNormals('internal')</span></code>.
See <a class="reference internal" href="#trisurface.TriSurface.fixNormals" title="trisurface.TriSurface.fixNormals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fixNormals()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.fixNormals_admesh">
<code class="sig-name descname">fixNormals_admesh</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.fixNormals_admesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.fixNormals_admesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Fix normals using admesh.</p>
<p>This is normally invoked as <code class="docutils literal notranslate"><span class="pre">fixNormals('admesh')</span></code>.
See <a class="reference internal" href="#trisurface.TriSurface.fixNormals" title="trisurface.TriSurface.fixNormals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fixNormals()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.check">
<code class="sig-name descname">check</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">matched</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.check" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the surface using gtscheck.</p>
<p>Uses the external program <cite>gtscheck</cite> to check whether the surface
is an orientable, non self-intersecting manifold.
This is a necessary condition for using the <cite>gts</cite> methods:
split, coarsen, refine, boolean. Additionally, the surface should be
closed: this can be checked with <a class="reference internal" href="#trisurface.TriSurface.isClosedManifold" title="trisurface.TriSurface.isClosedManifold"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isClosedManifold()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matched</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, self intersecting triangles are returned as element
indices of self. This is the default. If False, the self
intersecting triangles are returned as a separate TriSurface.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, prints the statistics reported by the gtscheck
command.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>status</strong> (<em>int</em>) – Return code from the checking program. One of the following:</p>
<ul>
<li><p>0: the surface is an orientable, non self-intersecting manifold.</p></li>
<li><p>1: the created GTS file is invalid: this should normally not occur.</p></li>
<li><p>2: the surface is not an orientable manifold. This may be due to
misoriented normals. The <a class="reference internal" href="#trisurface.TriSurface.fixNormals" title="trisurface.TriSurface.fixNormals"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fixNormals()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">reverse()</span></code>
methods may be used to help fixing the problem in such case.</p></li>
<li><p>3: the surface is an orientable manifold but is
self-intersecting. The self intersecting triangles are returned as
the second return value.</p></li>
</ul>
</li>
<li><p><strong>intersect</strong> (<em>None | list of ints | TriSurface</em>) – None in case of a <code class="docutils literal notranslate"><span class="pre">status</span></code> 0, 1 or 2. For <code class="docutils literal notranslate"><span class="pre">status</span></code> value 3,
returns the self intersecting triangles as a list of element
numbers (if <code class="docutils literal notranslate"><span class="pre">matched</span></code> is True) or as a TriSurface (if <code class="docutils literal notranslate"><span class="pre">matched</span></code>
is False).</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">base</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the surface using gtssplit.</p>
<p>Splits the surface into connected and manifold components.
This uses the external program <cite>gtssplit</cite>. The surface
should be a closed orientable non-intersecting manifold.
Use the <a class="reference internal" href="#trisurface.TriSurface.check" title="trisurface.TriSurface.check"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check()</span></code></a> method to find out.</p>
<p>This method creates a series of files with given base name,
each file contains a single connected manifold.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.coarsen">
<code class="sig-name descname">coarsen</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">min_edges</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_cost</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">mid_vertex</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">length_cost</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">max_fold</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">volume_weight</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">boundary_weight</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">shape_weight</span><span class="o">=</span><span class="default_value">0.0</span></em>, <em class="sig-param"><span class="n">progressive</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.coarsen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.coarsen" title="Permalink to this definition">¶</a></dt>
<dd><p>Coarsen a surface using gtscoarsen.</p>
<p>Construct a coarsened version of the surface.
This uses the external program <cite>gtscoarsen</cite>. The surface
should be a closed orientable non-intersecting manifold.
Use the <a class="reference internal" href="#trisurface.TriSurface.check" title="trisurface.TriSurface.check"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check()</span></code></a> method to find out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>min_edges</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Stop the coarsening process if the number of edges was to fall
below it.</p></li>
<li><p><strong>max_cost</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Stop the coarsening process if the cost of collapsing an edge is
larger than the specified value.</p></li>
<li><p><strong>mid_vertex</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – Use midvertex as replacement vertex instead of the default, which
is a volume optimized point.</p></li>
<li><p><strong>length_cost</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – Use length^2 as cost function instead of the default optimized
point cost.</p></li>
<li><p><strong>max_fold</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Maximum fold angle in degrees.</p></li>
<li><p><strong>volume_weight</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Weight used for volume optimization.</p></li>
<li><p><strong>boundary_weight</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Weight used for boundary optimization.</p></li>
<li><p><strong>shape_weight</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Weight used for shape optimization.</p></li>
<li><p><strong>progressive</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, write progressive surface file.</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If Trye, log the evolution of the cost.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, print statistics about the surface.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.gts_refine">
<code class="sig-name descname">gts_refine</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">max_edges</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_cost</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">log</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.gts_refine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.gts_refine" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine the TriSurface.</p>
<p>Refining a TriSurface means increasing the number of triangles and
reducing their size, while keeping the changes to the modeled surface
minimal.
This uses the external program <cite>gtsrefine</cite>. The surface
should be a closed orientable non-intersecting manifold.
Use the <a class="reference internal" href="#trisurface.TriSurface.check" title="trisurface.TriSurface.check"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check()</span></code></a> method to find out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_edges</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Stop the refining process if the number of edges exceeds this value.</p></li>
<li><p><strong>min_cost</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Stop the refining process if the cost of refining an edge is smaller.
(Not recommended).</p></li>
<li><p><strong>log</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, log the evolution of the cost.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, print statistics about the surface.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If neither max_edges nor min_cost are specified, the refining process
aims to double the number of edges.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.gts_smooth">
<code class="sig-name descname">gts_smooth</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">niter</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">lamb</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.gts_smooth"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.gts_smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth the surface using gtssmooth.</p>
<p>Smooth a surface by applying iterations of a Laplacian filter.
This uses the external program <cite>gtssmooth</cite>. The surface
should be a closed orientable non-intersecting manifold.
Use the <a class="reference internal" href="#trisurface.TriSurface.check" title="trisurface.TriSurface.check"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check()</span></code></a> method to find out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lamb</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Laplacian filter parameter.</p></li>
<li><p><strong>niter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Number of iterations.</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, print statistics about the surface.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.gts_set">
<code class="sig-name descname">gts_set</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">surf</span></em>, <em class="sig-param"><span class="n">op</span></em>, <em class="sig-param"><span class="n">prop</span><span class="o">=</span><span class="default_value">[1, 1, 2, 2]</span></em>, <em class="sig-param"><span class="n">check</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.gts_set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.gts_set" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a boolean operation with another surface.</p>
<p>Boolean operations between surfaces are a basic operation in
free surface modeling. Both surfaces should be closed orientable
non-intersecting manifolds. Use the <a class="reference internal" href="#trisurface.TriSurface.check" title="trisurface.TriSurface.check"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check()</span></code></a> method to find out.</p>
<p>Following is a list of defined operations, where surface 1 relates to
<cite>self</cite> and surface 2 to the <cite>surf</cite> argument. For simplicity, the
operations are identified by a short string. All returned surfaces
are manifolds. The first four are the basic parts: these may be closed
or not. The following operations are constructed by combining some
of the basic results. These are mathematical set operation on the
volumes inside the surfaces, and always result in closed surfaces.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 55%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Result</p></th>
<th class="head"><p>Computed from</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">i</span></code></p></td>
<td><p>the part of surface 1 inside surface 2</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">o</span></code></p></td>
<td><p>the part of surface 1 outside surface 2</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">2i</span></code></p></td>
<td><p>the part of surface 2 inside surface 1</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">2o</span></code></p></td>
<td><p>the part of surface 2 outside surface 1</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">+</span></code></p></td>
<td><p>the union of surfaces 1 and 2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">o</span></code> plus <code class="docutils literal notranslate"><span class="pre">2o</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
<td><p>the intersection of surfaces 1 and 2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i</span></code> plus <code class="docutils literal notranslate"><span class="pre">2i</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-</span></code></p></td>
<td><p>the difference of surface 1 minus surface 2</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">o</span></code> plus reversed <code class="docutils literal notranslate"><span class="pre">2i</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">2-</span></code></p></td>
<td><p>the difference of surface 2 minus surface 1</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">i</span></code> plus reversed <code class="docutils literal notranslate"><span class="pre">2o</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">^</span></code></p></td>
<td><p>the symmetric difference of the surfaces</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">+</span></code> plus reversed <code class="docutils literal notranslate"><span class="pre">*</span></code></p></td>
</tr>
</tbody>
</table>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surf</strong> (<a class="reference internal" href="#trisurface.TriSurface" title="trisurface.TriSurface"><em>TriSurface</em></a>) – Another TriSurface that is a closed manifold surface.</p></li>
<li><p><strong>op</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em> or </em><em>list of str</em>) – The operation(s) to perform: one of the operations specified
above, or a list of such operations. A special value <code class="docutils literal notranslate"><span class="pre">a</span></code> will
return the full list of 9 surfaces in the above order.</p></li>
<li><p><strong>prop</strong> (<em>list of int</em>) – A list of 4 integer values that will be set as props on the
four base surfaces, to facilitate identification of the parts
of the result(s). The default value will give prop values 1 or
2 depending on the original surface the parts belonged to.
Specifying None or an empty list will return surfaces without
props.</p></li>
<li><p><strong>check</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, a check is done that the surfaces are not self-intersecting;
if one of them is, the set of self-intersecting faces is written
(as a GtsSurface) on standard output</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, print statistics about the surface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><a class="reference internal" href="#trisurface.TriSurface" title="trisurface.TriSurface"><code class="xref py py-class docutils literal notranslate"><span class="pre">TriSurface</span></code></a> or list thereof – A single manifold surface, or a list of such surfaces, corresponding
to the specified oppetaion(s). The base operation may not be closed.
The set operations always are closed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method uses the external command ‘gtsset’ and will not run if
it is not installed (available from pyformex/extras).</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.boolean">
<code class="sig-name descname">boolean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">surf</span></em>, <em class="sig-param"><span class="n">op</span></em>, <em class="sig-param"><span class="n">check</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.boolean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.boolean" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a boolean operation with another surface.</p>
<p>Boolean operations between surfaces are a basic operation in
free surface modeling. Both surfaces should be closed orientable
non-intersecting manifolds.
Use the <a class="reference internal" href="#trisurface.TriSurface.check" title="trisurface.TriSurface.check"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check()</span></code></a> method to find out.</p>
<p>The boolean operations are set operations on the enclosed volumes:
union(‘+’), difference(‘-‘) or intersection(‘*’).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surf</strong> (<a class="reference internal" href="#trisurface.TriSurface" title="trisurface.TriSurface"><em>TriSurface</em></a>) – Another TriSurface that is a closed manifold surface.</p></li>
<li><p><strong>op</strong> (<em>'+'</em><em>, </em><em>'-'</em><em> or </em><em>'*'</em>) – The boolean operation to perform: union(‘+’), difference(‘-‘)
or intersection(‘*’).</p></li>
<li><p><strong>check</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, a check is done that the surfaces are not self-intersecting;
if one of them is, the set of self-intersecting faces is written
(as a GtsSurface) on standard output</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, print statistics about the surface.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>TriSurface</em> – A closed manifold TriSurface that is the volume union, difference or
intersection of self with surf.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method uses the external command ‘gtsset’ and will not run if
it is not installed (available from pyformex/extras).</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.intersection">
<code class="sig-name descname">intersection</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">surf</span></em>, <em class="sig-param"><span class="n">check</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.intersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection curve(s) of two surfaces.</p>
<p>Boolean operations between surfaces are a basic operation in
free surface modeling. Both surfaces should be closed orientable
non-intersecting manifolds.
Use the <a class="reference internal" href="#trisurface.TriSurface.check" title="trisurface.TriSurface.check"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check()</span></code></a> method to find out.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surf</strong> (<a class="reference internal" href="#trisurface.TriSurface" title="trisurface.TriSurface"><em>TriSurface</em></a>) – A closed manifold surface.</p></li>
<li><p><strong>check</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, a check is made that the surfaces are not self-intersecting;
if one of them is, the set of self-intersecting faces is written
(as a GtsSurface) on standard output</p></li>
<li><p><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True, statistics about the surface are printed on stdout.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Mesh</em> – A Mesh with eltype Line2 holding all the line segments of the
intersection curve(s).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.inside">
<code class="sig-name descname">inside</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pts</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'gts'</span></em>, <em class="sig-param"><span class="n">tol</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">multi</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.inside"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.inside" title="Permalink to this definition">¶</a></dt>
<dd><p>Test which of the points pts are inside the surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pts</strong> (<em>:term_`coords_like`</em>) – The points to check agains the surface.</p></li>
<li><p><strong>method`</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – <p>Method to be used for the detection. Depending on
the software you have installed the following are possible:</p>
<ul>
<li><p>’gts’: provided by pyformex-extra (default)</p></li>
<li><p>’vtk’: provided by python-vtk (slower)</p></li>
</ul>
</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Tolerance on equality of floating point values.</p></li>
<li><p><strong>multi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, uses multiprocessing to speed up the operation.
Only used with method=’gts’.</p></li>
<li><p><strong>keep</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, the temporary directory with intermediate results is
not erased. This may be useful for debugging purposes. Only
used with method=’gts’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>int array</em> – The indices of the points that are inside the surface.
The indices refer to the onedimensional list
of points as obtained from Coords(pts).points().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.outside">
<code class="sig-name descname">outside</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pts</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.outside"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.outside" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the points outside the surface.</p>
<p>This is the complement of <a class="reference internal" href="#trisurface.TriSurface.inside" title="trisurface.TriSurface.inside"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inside()</span></code></a>. See there for
parameters and return value.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.voxelize">
<code class="sig-name descname">voxelize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">bbox</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">return_formex</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.voxelize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.voxelize" title="Permalink to this definition">¶</a></dt>
<dd><p>Voxelize the volume inside a closed surface.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>(</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>)</em>) – Resolution, i.e. number of voxel cells to use along the three axes.
If a single int is specified, the number of cells will be adapted
according to the surface’s <code class="xref py py-meth docutils literal notranslate"><span class="pre">sizes()</span></code> (as the voxel cells are
always cubes). The specified number of voxels will be used along the
largest direction.</p></li>
<li><p><strong>bbox</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><em>(</em><em>point</em><em>,</em><em>point</em><em>)</em>) – Defines the bounding box of the volume that needs to be voxelized.
A float specifies a relative amount to add to the surface’s bounding
box. Note that this defines the bounding box of the centers of the
voxels.</p></li>
<li><p><strong>return_formex</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, also returns a Formex with the centers of the voxels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>voxels</strong> (<em>int array (nz,ny,nx)</em>) – The array has a value 1 for the voxels whose center is inside the
surface, else 0.</p></li>
<li><p><strong>centers</strong> (<em>Formex</em>) – A plex-1 Formex with the centers of the voxels, and property values
0 or 1 if the point is respectively outside or inside the surface.
The voxel cell ordering in the Formex is z-direction first, then y,
then x.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See also example Voxelize, for saving the voxel values in a stack
of binary images.</p>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.remesh">
<code class="sig-name descname">remesh</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'acvd'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.remesh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.remesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a quality remesh of the TriSurface.</p>
<p>Remeshing a TriSurface means replacing the surface with a new mesh
of triangles, which are more equally shaped, while trying to keep
the represented surface as close as possible to the original.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – <p>One of ‘acvd’ or ‘instant’. The first character suffices.
Depending on this value, one of the <code class="xref py py-meth docutils literal notranslate"><span class="pre">remesh_acvd()</span></code>,
<a class="reference internal" href="#trisurface.remesh_instant" title="trisurface.remesh_instant"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remesh_instant()</span></code></a> is called.</p>
<p>The ‘acvd’ method is included with pyFormex and is normally
always available on a successful install. The ‘instant’ method
requires an external program ‘instant-meshes’. The Help menu
contains an option to install it.</p>
</p></li>
<li><p><strong>kargs</strong> – Keyword arguments to be passed to the specific method
selected. See the specific method for explanation of the
parameters.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>TriSurface | Mesh | None</em> – In most cases a TriSurface is returned. The ‘instant’
method however allows remeshing to quads. In that cases a
Mesh of eltype ‘quad4’ is returner. If the external conversion
failed, None is returned.</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError:</strong> – If the requested external remeshing program is not available.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="lib.clust.html#lib.clust.remesh_acvd" title="lib.clust.remesh_acvd"><code class="xref py py-func docutils literal notranslate"><span class="pre">lib.clust.remesh_acvd()</span></code></a></dt><dd><p>remesh using the ACVD technique</p>
</dd>
<dt><a class="reference internal" href="#trisurface.remesh_instant" title="trisurface.remesh_instant"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remesh_instant</span></code></a></dt><dd><p>remesh using the external program ‘instant-meshes’</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.tetgen">
<code class="sig-name descname">tetgen</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">quality</span><span class="o">=</span><span class="default_value">2.0</span></em>, <em class="sig-param"><span class="n">volume</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">filename</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.tetgen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.tetgen" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tetrahedral mesh inside the surface.</p>
<p>This uses <a class="reference internal" href="plugins.tetgen.html#plugins.tetgen.tetMesh" title="plugins.tetgen.tetMesh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tetMesh()</span></code></a> to generate a quality
tetrahedral mesh inside the surface. The surface should be a closed
manifold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quality</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The quality of the output tetrahedral mesh. The value is a
constraint on the circumradius-to-shortest-edge ratio. The
default (2.0) already provides a high quality mesh. Providing
a larger value will reduce quality but increase speed. With
quality=None, no quality constraint will be imposed.</p></li>
<li><p><strong>volume</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – If provided, applies a maximum tetrahedron volume constraint.</p></li>
<li><p><strong>filename</strong> (<a class="reference internal" href="../glossary.html#term-path_like"><span class="xref std std-term">path_like</span></a>) – Specifies where the intermediate files will be stored.
The default will use a temporary directory which will be destroyed
after return. If the path of an existing directory is provided,
the files will be stored in that directory with a name ‘surface.off’
for the original surface model and files ‘surface.1.*’ for the
generated tetrahedral model (in tetgen format).
If the path does not exist or is an existing file, the parent
directory should exist and files are stored with the given
file name as base. Existing files will be silently overwritten.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Mesh</em> – A tetrahedral Mesh (eltype=’tet4’) filling the input surface,
provided the <a class="reference internal" href="plugins.tetgen.html#plugins.tetgen.tetMesh" title="plugins.tetgen.tetMesh"><code class="xref py py-func docutils literal notranslate"><span class="pre">tetMesh()</span></code></a> function finished
successfully.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.surface2webgl">
<code class="sig-name descname">surface2webgl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">caption</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#trisurface.TriSurface.surface2webgl" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a WebGL model of a surface</p>
<ul class="simple">
<li><p><cite>S</cite>: TriSurface</p></li>
<li><p><cite>name</cite>: basename of the output files</p></li>
<li><p><cite>caption</cite>: text to use as caption</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.webgl">
<code class="sig-name descname">webgl</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">caption</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#trisurface.TriSurface.webgl" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a WebGL model of a surface</p>
<ul class="simple">
<li><p><cite>S</cite>: TriSurface</p></li>
<li><p><cite>name</cite>: basename of the output files</p></li>
<li><p><cite>caption</cite>: text to use as caption</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt id="trisurface.TriSurface.pzf_dict">
<code class="sig-name descname">pzf_dict</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#TriSurface.pzf_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.TriSurface.pzf_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct common part of all Geometry pzf dicts</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions-defined-in-module-trisurface">
<h2><span class="section-number">42.2. </span>Functions defined in module trisurface<a class="headerlink" href="#functions-defined-in-module-trisurface" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="trisurface.fillBorder">
<code class="sig-prename descclassname">trisurface.</code><code class="sig-name descname">fillBorder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">border</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'radial'</span></em>, <em class="sig-param"><span class="n">dir</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#fillBorder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.fillBorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a triangulated surface inside a given closed polygonal line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>border</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">PolyLine</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">Coords</span></code>) – <p>A closed polygonal line that forms the border of the triangulated
surface to be created. The polygon does not have to be planar.
The line can be provided as one of the following:</p>
<ul>
<li><p>a closed PolyLine,</p></li>
<li><p>a 2-plex Mesh, with a Connectivity table such that the elements
in the specified order form a closed polyline,</p></li>
<li><p>a simple Coords holding the subsequent vertices of the polygonal
border line.</p></li>
</ul>
</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – <p>Specifies the algorithm to be used to fill the polygon. Currently
available are:</p>
<ul>
<li><p>’radial’: this method adds a central point and connects all border
segments with the center to create triangles.</p></li>
<li><p>’border’: this method creates subsequent triangles by connecting the
endpoints of two consecutive border segments and thus works its way
inwards until the hole is closed. Triangles are created at the line
segments that form the smallest angle.</p></li>
<li><p>’planar’: this method projects the border on a plane, fills the
border in 2D, then maps that back to the original border.
The projection direction can be specified with <code class="docutils literal notranslate"><span class="pre">dir</span></code>.</p></li>
</ul>
<p>See also Notes below.</p>
</p></li>
<li><p><strong>dir</strong> ((3,) <a class="reference internal" href="../glossary.html#term-array_like"><span class="xref std std-term">array_like</span></a>, optional) – A vector specyfing the direction of the projection in the case of
<code class="docutils literal notranslate"><span class="pre">method='planar'</span></code>. If not provided, the best direction is
automatically choosen.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>TriSurface</em> – A TriSurface filling the hole inside the border.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘radial’ method produces nice results if the border is relative smooth,
nearly convex and nearly planar. It adds an extra point though, which may
be unwanted. On irregular 3D borders there is a high change that the
resulting TriSurface contains intersecting triangles.</p>
<p>The ‘border’ method is slower on large borders, does not introduce any
new point and has a better chance of avoiding intersecting triangles
on irregular 3D borders.</p>
<p>The ‘planar’ method gives very good results if the border curve is more
or less planar.</p>
<p>The resulting surface can be checked for intersecting triangles with the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">check()</span></code> method.</p>
</dd></dl>

<dl class="py function">
<dt id="trisurface.instant_meshes">
<code class="sig-prename descclassname">trisurface.</code><code class="sig-name descname">instant_meshes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">infile</span></em>, <em class="sig-param"><span class="n">outfile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#instant_meshes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.instant_meshes" title="Permalink to this definition">¶</a></dt>
<dd><p>Remesh a tri3 mesh to a quality tri3 and/or quad4 mesh</p>
<p>Uses the external ‘Instant Meshes’ program to remesh a tri3 mesh
to a tri3 and/or quad4 mesh of the desired quality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>infile</strong> (<a class="reference internal" href="../glossary.html#term-path_like"><span class="xref std std-term">path_like</span></a>) – An .obj file containing a pure tri3 mesh.</p></li>
<li><p><strong>outfile</strong> (<a class="reference internal" href="../glossary.html#term-path_like"><span class="xref std std-term">path_like</span></a>) – The output file with the quad (or quad dominated) Mesh.
It can be a .obj or .ply file. If not provided, it is generated
from the input file with the ‘.obj’ suffix replaced ‘with _quad.obj’.</p></li>
<li><p><strong>threads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Number of threads to use in parallel computations.</p></li>
<li><p><strong>deterministic</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, prefer (slower) deterministic algorithms. Default False.</p></li>
<li><p><strong>crease</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – Dihedral angle threshold for creases.</p></li>
<li><p><strong>smooth</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Number of smoothing &amp; ray tracing reprojection steps (default: 2).
Setting this to 0 may result in degenerate quads (with two adjacent
edges along the same line).</p></li>
<li><p><strong>dominant</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, generate a quad dominant mesh instead of a pure quad mesh.
The output may contain some triangles and pentagones as well.
Default False.</p></li>
<li><p><strong>intrinsic</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, use intrinsic mode (extrinsic is the default).</p></li>
<li><p><strong>boundaries</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If True, align the result on the boundaries. Default False.
Only applies when the surface is not closed.</p></li>
<li><p><strong>posy</strong> (<em>3 | 4 | 6</em>) – Specifies the position symmetry type. Default 4.</p></li>
<li><p><strong>rosy</strong> (<em>2 | 4 | 6</em>) – Specifies the orientation symmetry type. Default 4.</p></li>
<li><p><strong>scale</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The intended edge length of the quad elements. Ignored if either
faces or vertices is provided. See notes.</p></li>
<li><p><strong>faces</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – The intended number of quads in the output mesh. Ignored if
vertices is provided. See notes.</p></li>
<li><p><strong>vertices</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – The intended number of vertices in the output mesh. See notes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Path | None</em> – The path of the output file if the conversion was successful, else None.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ‘Instant Meshes’ executable should be installed as ‘instant-meshes’.</p>
<p>To control the output resolution, one should specify exactly one of
scale, faces or vertices. These are mutually exclusive.</p>
<p>If a pure quad mesh is requested (the default), the number of
faces and vertices is likely to end up being around 4 times larger and
the edges two times shorter than requested.
This is because the initial remeshing may end up with some
triangles and/or pentagons, which then require a subdivision of all faces
into smaller quads. You may anticipate to this by specifying smaller values.
This late subdivision is not done if <code class="docutils literal notranslate"><span class="pre">dominant=True</span></code>
is specified, or if the initial remesh does not have any triangles or
pentagons.</p>
<p>With dominant=False, posy = 3 or 6 results in a Tri3 Mesh, while posy = 4
yields a Quad4 Mesh. The best quality is usually obtained with posy=rosy=6
to produce triangles and posy=rosy=4 for quads.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#trisurface.TriSurface.remesh" title="trisurface.TriSurface.remesh"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TriSurface.remesh()</span></code></a></dt><dd><p>apply remeshing on a TriSurface</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt id="trisurface.remesh_instant">
<code class="sig-prename descclassname">trisurface.</code><code class="sig-name descname">remesh_instant</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">S</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">infile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">outfile</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nplex</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/trisurface.html#remesh_instant"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#trisurface.remesh_instant" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a quality remesh of the TriSurface.</p>
<p>Uses <a class="reference internal" href="#trisurface.instant_meshes" title="trisurface.instant_meshes"><code class="xref py py-func docutils literal notranslate"><span class="pre">instant_meshes()</span></code></a> to remesh a TriSurface into a
quality Tri3 or Quad4 Mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>S</strong> (<a class="reference internal" href="#trisurface.TriSurface" title="trisurface.TriSurface"><em>TriSurface</em></a>) – The TriSurface to be remeshed.</p></li>
<li><p><strong>infile</strong> (<a class="reference internal" href="../glossary.html#term-path_like"><span class="xref std std-term">path_like</span></a>) – The name of an .obj file where the TriSurface will be stored for
processing. If not provided, a temporary file is used.</p></li>
<li><p><strong>outfile</strong> (<a class="reference internal" href="../glossary.html#term-path_like"><span class="xref std std-term">path_like</span></a>) – The name of an .obj file for storing the output Mesh.
If not provided, it is generated from the infile
with the ‘.obj’ suffix replaced ‘with _remesh.obj’.</p></li>
<li><p><strong>nplex</strong> (<em>3 | 4</em>) – This is a convenient parameter to quickly create a quality mesh
of triangles or quads. It overwrites the parameters rosy and posy
with values 6 for nplex=3 and 4 for nplex=4.</p></li>
<li><p><strong>kargs</strong> – Other keyword arguments passed to <a class="reference internal" href="#trisurface.instant_meshes" title="trisurface.instant_meshes"><code class="xref py py-func docutils literal notranslate"><span class="pre">instant_meshes()</span></code></a>.
All the keyword parameters accepted by that function,
except for ‘dominant, can be specified here.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>Mesh | None</em> – A Mesh of eltype ‘tri3’ or ‘quad4’ if the conversion was
successful, or else None.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If neither scale, faces or vertices is provided, vertices
will be set equal to the number of vertices in the TriSurface.
This is because the default of <a class="reference internal" href="#trisurface.instant_meshes" title="trisurface.instant_meshes"><code class="xref py py-func docutils literal notranslate"><span class="pre">instant_meshes()</span></code></a> results in a
much too coarse Mesh.</p>
<p>If the boundaries parameter is not provided, it is set True
if the TriSurface is not a closed manifold.</p>
<p>As a side effect, if file names were specified, the .obj files
with the original TriSurface and remeshed surface remain available.</p>
</dd></dl>

</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="utils.html" title="43. utils — A collection of miscellaneous utility functions."
             >next</a> |</li>
        <li class="right" >
          <a href="track.html" title="41. track — track.py"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">pyFormex 3.3 documentation</a> &gt;</li>
          <li class="nav-item nav-item-1"><a href="../refman.html" >pyFormex reference manual</a> &gt;</li>
        <!--li class="nav-item nav-item-this"><a href=""><span class="section-number">42. </span><code class="xref py py-mod docutils literal notranslate"><span class="pre">trisurface</span></code> — Operations on triangulated surfaces.</a></li--> 
      </ul>
    </div>
    <div class="footer">
    <span class="left">
        &copy; Copyright 2004-2023, Benedict Verhegghe.
    </span>
      Last updated on Mar 27, 2023.
    <span class="right">
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 3.4.3.
    </span>
    </div>
  </body>
</html>