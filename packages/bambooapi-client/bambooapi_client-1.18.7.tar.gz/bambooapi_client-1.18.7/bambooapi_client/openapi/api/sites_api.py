"""
    Bamboo Flexibility API

     This API provides access to flexibility assets managed by Bamboo Energy: - Create and list flexibility sites & assets - Obtain activations for specific assets - Post and get measurements for specific assets   # noqa: E501

    The version of the OpenAPI document: 1.18.7
    Contact: development@bambooenergy.tech
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from bambooapi_client.openapi.api_client import ApiClient, Endpoint as _Endpoint
from bambooapi_client.openapi.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from bambooapi_client.openapi.model.availability_schedule_item import AvailabilityScheduleItem
from bambooapi_client.openapi.model.baseline_model import BaselineModel
from bambooapi_client.openapi.model.contract_schedule_item import ContractScheduleItem
from bambooapi_client.openapi.model.device_activation_list_item import DeviceActivationListItem
from bambooapi_client.openapi.model.device_measurements import DeviceMeasurements
from bambooapi_client.openapi.model.device_type_measurements_statistics import DeviceTypeMeasurementsStatistics
from bambooapi_client.openapi.model.flexibility_model import FlexibilityModel
from bambooapi_client.openapi.model.http400_bad_request import HTTP400BadRequest
from bambooapi_client.openapi.model.http401_unauthorized import HTTP401Unauthorized
from bambooapi_client.openapi.model.http403_forbidden import HTTP403Forbidden
from bambooapi_client.openapi.model.http404_not_found import HTTP404NotFound
from bambooapi_client.openapi.model.http405_method_not_allowed import HTTP405MethodNotAllowed
from bambooapi_client.openapi.model.http500_internal_server_error import HTTP500InternalServerError
from bambooapi_client.openapi.model.http501_not_implemented import HTTP501NotImplemented
from bambooapi_client.openapi.model.http_validation_error import HTTPValidationError
from bambooapi_client.openapi.model.response_list_devices_sites_site_id_devices_get import ResponseListDevicesSitesSiteIdDevicesGet
from bambooapi_client.openapi.model.response_read_device_activations_sites_site_id_devices_device_name_activations_get import ResponseReadDeviceActivationsSitesSiteIdDevicesDeviceNameActivationsGet
from bambooapi_client.openapi.model.response_read_device_sites_site_id_devices_device_name_get import ResponseReadDeviceSitesSiteIdDevicesDeviceNameGet
from bambooapi_client.openapi.model.site import Site
from bambooapi_client.openapi.model.site_activation_data_point import SiteActivationDataPoint
from bambooapi_client.openapi.model.site_activation_list_item import SiteActivationListItem
from bambooapi_client.openapi.model.site_availability_enum import SiteAvailabilityEnum
from bambooapi_client.openapi.model.site_availability_list_item import SiteAvailabilityListItem
from bambooapi_client.openapi.model.site_create import SiteCreate
from bambooapi_client.openapi.model.site_data_point import SiteDataPoint
from bambooapi_client.openapi.model.site_flexumer_statistics import SiteFlexumerStatistics
from bambooapi_client.openapi.model.site_list_item import SiteListItem
from bambooapi_client.openapi.model.site_measurements import SiteMeasurements
from bambooapi_client.openapi.model.site_reliability_index import SiteReliabilityIndex
from bambooapi_client.openapi.model.site_thresholds import SiteThresholds
from bambooapi_client.openapi.model.site_treatment_plant_costs import SiteTreatmentPlantCosts
from bambooapi_client.openapi.model.site_update import SiteUpdate
from bambooapi_client.openapi.model.site_with_is_load_distinct import SiteWithIsLoadDistinct
from bambooapi_client.openapi.model.thermal_zone import ThermalZone
from bambooapi_client.openapi.model.thermal_zone_setpoints import ThermalZoneSetpoints
from bambooapi_client.openapi.model.week_plan_data_point import WeekPlanDataPoint


class SitesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.create_site_endpoint = _Endpoint(
            settings={
                'response_type': (Site,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites',
                'operation_id': 'create_site',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_create',
                ],
                'required': [
                    'site_create',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_create':
                        (SiteCreate,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'site_create': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.delete_device_baseline_plan_endpoint = _Endpoint(
            settings={
                'response_type': ([WeekPlanDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/forecasts/baseline/plan',
                'operation_id': 'delete_device_baseline_plan',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                ],
                'required': [
                    'site_id',
                    'device_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_site_endpoint = _Endpoint(
            settings={
                'response_type': (Site,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}',
                'operation_id': 'delete_site',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                ],
                'required': [
                    'site_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_device_baseline_plan_endpoint = _Endpoint(
            settings={
                'response_type': ([WeekPlanDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/forecasts/baseline/plan',
                'operation_id': 'get_device_baseline_plan',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                ],
                'required': [
                    'site_id',
                    'device_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_site_devices_thresholds_endpoint = _Endpoint(
            settings={
                'response_type': (SiteThresholds,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thresholds',
                'operation_id': 'get_site_devices_thresholds',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                ],
                'required': [
                    'site_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_site_flexibility_forecast_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/forecasts/flexibility',
                'operation_id': 'get_site_flexibility_forecast',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'horizon',
                    'forecast_type',
                    'ramping',
                    'start_time',
                    'end_time',
                    'frequency',
                ],
                'required': [
                    'site_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'ramping':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'start_time':
                        (datetime,),
                    'end_time':
                        (datetime,),
                    'frequency':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                    'ramping': 'ramping',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                    'frequency': 'frequency',
                },
                'location_map': {
                    'site_id': 'path',
                    'horizon': 'query',
                    'forecast_type': 'query',
                    'ramping': 'query',
                    'start_time': 'query',
                    'end_time': 'query',
                    'frequency': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_site_id_by_name_endpoint = _Endpoint(
            settings={
                'response_type': (int,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/id/{site_name}',
                'operation_id': 'get_site_id_by_name',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_name',
                ],
                'required': [
                    'site_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_name':
                        (str,),
                },
                'attribute_map': {
                    'site_name': 'site_name',
                },
                'location_map': {
                    'site_name': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_site_statistics_endpoint = _Endpoint(
            settings={
                'response_type': (SiteFlexumerStatistics,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/statistics',
                'operation_id': 'get_site_statistics',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'start_time',
                    'end_time',
                ],
                'required': [
                    'site_id',
                    'start_time',
                    'end_time',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'start_time':
                        (datetime,),
                    'end_time':
                        (datetime,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                },
                'location_map': {
                    'site_id': 'path',
                    'start_time': 'query',
                    'end_time': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_thermal_zone_modes_in_range_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thermalZones/{zone_name}/mode',
                'operation_id': 'get_thermal_zone_modes_in_range',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'zone_name',
                    'start_time',
                    'end_time',
                    'frequency',
                ],
                'required': [
                    'site_id',
                    'zone_name',
                    'start_time',
                    'end_time',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'zone_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('zone_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'zone_name':
                        (str,),
                    'start_time':
                        (datetime,),
                    'end_time':
                        (datetime,),
                    'frequency':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'zone_name': 'zone_name',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                    'frequency': 'frequency',
                },
                'location_map': {
                    'site_id': 'path',
                    'zone_name': 'path',
                    'start_time': 'query',
                    'end_time': 'query',
                    'frequency': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_treatment_plant_cost_endpoint = _Endpoint(
            settings={
                'response_type': (SiteTreatmentPlantCosts,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/treatmentPlants/{plant_name}/costs',
                'operation_id': 'get_treatment_plant_cost',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'plant_name',
                    'start_time',
                    'end_time',
                    'spot_market_id',
                    'frequency',
                ],
                'required': [
                    'site_id',
                    'plant_name',
                    'start_time',
                    'end_time',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'plant_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('plant_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'plant_name':
                        (str,),
                    'start_time':
                        (datetime,),
                    'end_time':
                        (datetime,),
                    'spot_market_id':
                        (int,),
                    'frequency':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'plant_name': 'plant_name',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                    'spot_market_id': 'spot_market_id',
                    'frequency': 'frequency',
                },
                'location_map': {
                    'site_id': 'path',
                    'plant_name': 'path',
                    'start_time': 'query',
                    'end_time': 'query',
                    'spot_market_id': 'query',
                    'frequency': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.insert_device_baseline_forecasts_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/forecasts/baseline',
                'operation_id': 'insert_device_baseline_forecasts',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'site_data_point',
                    'horizon',
                    'forecast_type',
                ],
                'required': [
                    'site_id',
                    'device_name',
                    'site_data_point',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'site_data_point':
                        ([SiteDataPoint],),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'site_data_point': 'body',
                    'horizon': 'query',
                    'forecast_type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.insert_device_baseline_plan_endpoint = _Endpoint(
            settings={
                'response_type': ([WeekPlanDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/forecasts/baseline/plan',
                'operation_id': 'insert_device_baseline_plan',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'week_plan_data_point',
                ],
                'required': [
                    'site_id',
                    'device_name',
                    'week_plan_data_point',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'week_plan_data_point':
                        ([WeekPlanDataPoint],),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'week_plan_data_point': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.insert_device_flexibility_forecasts_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/forecasts/flexibility',
                'operation_id': 'insert_device_flexibility_forecasts',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'site_data_point',
                    'horizon',
                    'forecast_type',
                    'ramping',
                ],
                'required': [
                    'site_id',
                    'device_name',
                    'site_data_point',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'site_data_point':
                        ([SiteDataPoint],),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'ramping':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                    'ramping': 'ramping',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'site_data_point': 'body',
                    'horizon': 'query',
                    'forecast_type': 'query',
                    'ramping': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.insert_site_reliability_index_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/reliability',
                'operation_id': 'insert_site_reliability_index',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'site_reliability_index',
                ],
                'required': [
                    'site_id',
                    'site_reliability_index',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'site_reliability_index':
                        (SiteReliabilityIndex,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                    'site_reliability_index': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.insert_thermal_zone_flexibility_forecasts_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thermalZones/{zone_name}/forecasts/flexibility',
                'operation_id': 'insert_thermal_zone_flexibility_forecasts',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'zone_name',
                    'site_data_point',
                    'horizon',
                    'forecast_type',
                    'ramping',
                ],
                'required': [
                    'site_id',
                    'zone_name',
                    'site_data_point',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'zone_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('zone_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'zone_name':
                        (str,),
                    'site_data_point':
                        ([SiteDataPoint],),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'ramping':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'zone_name': 'zone_name',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                    'ramping': 'ramping',
                },
                'location_map': {
                    'site_id': 'path',
                    'zone_name': 'path',
                    'site_data_point': 'body',
                    'horizon': 'query',
                    'forecast_type': 'query',
                    'ramping': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.list_devices_endpoint = _Endpoint(
            settings={
                'response_type': ([ResponseListDevicesSitesSiteIdDevicesGet],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices',
                'operation_id': 'list_devices',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_type',
                ],
                'required': [
                    'site_id',
                ],
                'nullable': [
                ],
                'enum': [
                    'device_type',
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                    ('device_type',): {

                        "METERS": "meters",
                        "LOADS": "loads",
                        "SHIFTABLE_LOADS": "shiftable_loads",
                        "CURTAILABLE_LOADS": "curtailable_loads",
                        "PV_SYSTEMS": "pv_systems",
                        "EV_CHARGERS": "ev_chargers",
                        "BATTERIES": "batteries",
                        "THERMAL_ZONES_SWITCHES": "thermal_zones_switches",
                        "THERMAL_LOADS": "thermal_loads",
                        "THERMAL_COMFORT_DEVICES": "thermal_comfort_devices",
                        "TREATMENT_PLANTS": "treatment_plants"
                    },
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_type':
                        (str,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_type': 'device_type',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_sites_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteListItem],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites',
                'operation_id': 'list_sites',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_thermal_zones_endpoint = _Endpoint(
            settings={
                'response_type': ([ThermalZone],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thermalZones',
                'operation_id': 'list_thermal_zones',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                ],
                'required': [
                    'site_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.post_publish_pub_sub_site_device_measurements_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/measurements',
                'operation_id': 'post_publish_pub_sub_site_device_measurements',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'site_data_point',
                ],
                'required': [
                    'site_id',
                    'device_name',
                    'site_data_point',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'site_data_point':
                        ([SiteDataPoint],),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'site_data_point': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.post_publish_pub_sub_site_measurements_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteMeasurements],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/measurements',
                'operation_id': 'post_publish_pub_sub_site_measurements',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'site_measurements',
                ],
                'required': [
                    'site_id',
                    'site_measurements',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'site_measurements',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('site_measurements',): {

                        'min_items': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'site_measurements':
                        ([SiteMeasurements],),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                    'site_measurements': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.put_insert_device_measurements_private_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/measurements/private',
                'operation_id': 'put_insert_device_measurements_private',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'site_data_point',
                ],
                'required': [
                    'site_id',
                    'device_name',
                    'site_data_point',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'site_data_point':
                        ([SiteDataPoint],),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'site_data_point': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.put_insert_site_measurements_private_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteMeasurements],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/measurements/private',
                'operation_id': 'put_insert_site_measurements_private',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'site_measurements',
                ],
                'required': [
                    'site_id',
                    'site_measurements',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'site_measurements':
                        ([SiteMeasurements],),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                    'site_measurements': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.put_publish_pub_sub_site_device_measurements_endpoint = _Endpoint(
            settings={
                'response_type': (bool, date, datetime, dict, float, int, list, str, none_type,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/measurements',
                'operation_id': 'put_publish_pub_sub_site_device_measurements',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'site_data_point',
                ],
                'required': [
                    'site_id',
                    'device_name',
                    'site_data_point',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'site_data_point':
                        ([SiteDataPoint],),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'site_data_point': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.put_publish_pub_sub_site_measurements_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteMeasurements],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/measurements',
                'operation_id': 'put_publish_pub_sub_site_measurements',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'site_measurements',
                ],
                'required': [
                    'site_id',
                    'site_measurements',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'site_measurements',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('site_measurements',): {

                        'min_items': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'site_measurements':
                        ([SiteMeasurements],),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                    'site_measurements': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.put_site_devices_thresholds_endpoint = _Endpoint(
            settings={
                'response_type': (SiteThresholds,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thresholds',
                'operation_id': 'put_site_devices_thresholds',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'site_thresholds',
                ],
                'required': [
                    'site_id',
                    'site_thresholds',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'site_thresholds':
                        (SiteThresholds,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                    'site_thresholds': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.read_baseline_model_endpoint = _Endpoint(
            settings={
                'response_type': (BaselineModel,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/models/baseline',
                'operation_id': 'read_baseline_model',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'horizon',
                    'forecast_type',
                ],
                'required': [
                    'site_id',
                    'device_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'horizon': 'query',
                    'forecast_type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_device_endpoint = _Endpoint(
            settings={
                'response_type': (ResponseReadDeviceSitesSiteIdDevicesDeviceNameGet,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}',
                'operation_id': 'read_device',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                ],
                'required': [
                    'site_id',
                    'device_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_device_activations_endpoint = _Endpoint(
            settings={
                'response_type': (ResponseReadDeviceActivationsSitesSiteIdDevicesDeviceNameActivationsGet,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/activations',
                'operation_id': 'read_device_activations',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'end_time',
                ],
                'required': [
                    'site_id',
                    'device_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'end_time':
                        (datetime,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                    'end_time': 'end_time',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'end_time': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_device_baseline_forecasts_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/forecasts/baseline',
                'operation_id': 'read_device_baseline_forecasts',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'horizon',
                    'forecast_type',
                    'period',
                    'start_time',
                    'end_time',
                    'frequency',
                ],
                'required': [
                    'site_id',
                    'device_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'period':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'start_time':
                        (str,),
                    'end_time':
                        (str,),
                    'frequency':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                    'period': 'period',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                    'frequency': 'frequency',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'horizon': 'query',
                    'forecast_type': 'query',
                    'period': 'query',
                    'start_time': 'query',
                    'end_time': 'query',
                    'frequency': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_device_flexibility_forecasts_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/forecasts/flexibility',
                'operation_id': 'read_device_flexibility_forecasts',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'horizon',
                    'forecast_type',
                    'ramping',
                    'period',
                    'start_time',
                    'end_time',
                    'frequency',
                ],
                'required': [
                    'site_id',
                    'device_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'ramping':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'period':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'start_time':
                        (str,),
                    'end_time':
                        (str,),
                    'frequency':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                    'ramping': 'ramping',
                    'period': 'period',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                    'frequency': 'frequency',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'horizon': 'query',
                    'forecast_type': 'query',
                    'ramping': 'query',
                    'period': 'query',
                    'start_time': 'query',
                    'end_time': 'query',
                    'frequency': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_device_measurements_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/measurements',
                'operation_id': 'read_device_measurements',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'period',
                    'start_time',
                    'end_time',
                    'frequency',
                ],
                'required': [
                    'site_id',
                    'device_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'period':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'start_time':
                        (str,),
                    'end_time':
                        (str,),
                    'frequency':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                    'period': 'period',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                    'frequency': 'frequency',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'period': 'query',
                    'start_time': 'query',
                    'end_time': 'query',
                    'frequency': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_flexibility_model_endpoint = _Endpoint(
            settings={
                'response_type': (FlexibilityModel,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thermalZones/{zone_name}/models/flexibility',
                'operation_id': 'read_flexibility_model',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'zone_name',
                    'horizon',
                    'forecast_type',
                ],
                'required': [
                    'site_id',
                    'zone_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'zone_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('zone_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'zone_name':
                        (str,),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'zone_name': 'zone_name',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                },
                'location_map': {
                    'site_id': 'path',
                    'zone_name': 'path',
                    'horizon': 'query',
                    'forecast_type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_measurements_endpoint = _Endpoint(
            settings={
                'response_type': ([DeviceMeasurements],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/measurements',
                'operation_id': 'read_measurements',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_types',
                    'start_time',
                    'end_time',
                    'frequency',
                ],
                'required': [
                    'site_id',
                    'device_types',
                    'start_time',
                    'end_time',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_types':
                        ([str],),
                    'start_time':
                        (datetime,),
                    'end_time':
                        (datetime,),
                    'frequency':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_types': 'device_types',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                    'frequency': 'frequency',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_types': 'query',
                    'start_time': 'query',
                    'end_time': 'query',
                    'frequency': 'query',
                },
                'collection_format_map': {
                    'device_types': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_measurements_statistics_endpoint = _Endpoint(
            settings={
                'response_type': ([DeviceTypeMeasurementsStatistics],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/measurements/statistics',
                'operation_id': 'read_measurements_statistics',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_types',
                    'start_time',
                    'end_time',
                ],
                'required': [
                    'site_id',
                    'device_types',
                    'start_time',
                    'end_time',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_types',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_types',): {

                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_types':
                        ([str],),
                    'start_time':
                        (datetime,),
                    'end_time':
                        (datetime,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_types': 'device_types',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_types': 'query',
                    'start_time': 'query',
                    'end_time': 'query',
                },
                'collection_format_map': {
                    'device_types': 'multi',
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_site_endpoint = _Endpoint(
            settings={
                'response_type': (SiteWithIsLoadDistinct,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}',
                'operation_id': 'read_site',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                ],
                'required': [
                    'site_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_site_activations_endpoint = _Endpoint(
            settings={
                'response_type': ([DeviceActivationListItem],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/activations',
                'operation_id': 'read_site_activations',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'time',
                ],
                'required': [
                    'site_id',
                    'time',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'time':
                        (datetime,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'time': 'time',
                },
                'location_map': {
                    'site_id': 'path',
                    'time': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_site_activations_frontend_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteActivationDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/activations/timeseries',
                'operation_id': 'read_site_activations_frontend',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'start_time',
                    'end_time',
                ],
                'required': [
                    'site_id',
                    'start_time',
                    'end_time',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'start_time':
                        (datetime,),
                    'end_time':
                        (datetime,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                },
                'location_map': {
                    'site_id': 'path',
                    'start_time': 'query',
                    'end_time': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_site_availability_endpoint = _Endpoint(
            settings={
                'response_type': (SiteAvailabilityEnum,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/availability',
                'operation_id': 'read_site_availability',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                ],
                'required': [
                    'site_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_site_availability_schedule_endpoint = _Endpoint(
            settings={
                'response_type': ([AvailabilityScheduleItem],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/availability/schedule',
                'operation_id': 'read_site_availability_schedule',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'start_time',
                    'end_time',
                    'frequency',
                ],
                'required': [
                    'site_id',
                    'start_time',
                    'end_time',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'start_time':
                        (datetime,),
                    'end_time':
                        (datetime,),
                    'frequency':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                    'frequency': 'frequency',
                },
                'location_map': {
                    'site_id': 'path',
                    'start_time': 'query',
                    'end_time': 'query',
                    'frequency': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_site_contract_schedule_endpoint = _Endpoint(
            settings={
                'response_type': ([ContractScheduleItem],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/contracts/schedule',
                'operation_id': 'read_site_contract_schedule',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'start_time',
                    'end_time',
                ],
                'required': [
                    'site_id',
                    'start_time',
                    'end_time',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'start_time':
                        (datetime,),
                    'end_time':
                        (datetime,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                },
                'location_map': {
                    'site_id': 'path',
                    'start_time': 'query',
                    'end_time': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_site_reliability_index_endpoint = _Endpoint(
            settings={
                'response_type': (SiteReliabilityIndex,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/reliability',
                'operation_id': 'read_site_reliability_index',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'start_time',
                    'end_time',
                ],
                'required': [
                    'site_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'start_time':
                        (datetime,),
                    'end_time':
                        (datetime,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                },
                'location_map': {
                    'site_id': 'path',
                    'start_time': 'query',
                    'end_time': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_sites_activations_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteActivationListItem],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/activations',
                'operation_id': 'read_sites_activations',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'end_time',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'end_time':
                        (datetime,),
                },
                'attribute_map': {
                    'end_time': 'end_time',
                },
                'location_map': {
                    'end_time': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_sites_availability_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteAvailabilityListItem],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/availability',
                'operation_id': 'read_sites_availability',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_sites_statistics_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteFlexumerStatistics],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/statistics',
                'operation_id': 'read_sites_statistics',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                },
                'attribute_map': {
                },
                'location_map': {
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_thermal_zone_endpoint = _Endpoint(
            settings={
                'response_type': (ThermalZone,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thermalZones/{zone_name}',
                'operation_id': 'read_thermal_zone',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'zone_name',
                ],
                'required': [
                    'site_id',
                    'zone_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'zone_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('zone_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'zone_name':
                        (str,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'zone_name': 'zone_name',
                },
                'location_map': {
                    'site_id': 'path',
                    'zone_name': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_thermal_zone_flexibility_forecasts_endpoint = _Endpoint(
            settings={
                'response_type': ([SiteDataPoint],),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thermalZones/{zone_name}/forecasts/flexibility',
                'operation_id': 'read_thermal_zone_flexibility_forecasts',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'zone_name',
                    'horizon',
                    'forecast_type',
                    'ramping',
                    'period',
                    'start_time',
                    'end_time',
                    'frequency',
                ],
                'required': [
                    'site_id',
                    'zone_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'zone_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('zone_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'zone_name':
                        (str,),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'ramping':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'period':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'start_time':
                        (str,),
                    'end_time':
                        (str,),
                    'frequency':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'zone_name': 'zone_name',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                    'ramping': 'ramping',
                    'period': 'period',
                    'start_time': 'start_time',
                    'end_time': 'end_time',
                    'frequency': 'frequency',
                },
                'location_map': {
                    'site_id': 'path',
                    'zone_name': 'path',
                    'horizon': 'query',
                    'forecast_type': 'query',
                    'ramping': 'query',
                    'period': 'query',
                    'start_time': 'query',
                    'end_time': 'query',
                    'frequency': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.read_thermal_zone_setpoints_endpoint = _Endpoint(
            settings={
                'response_type': (ThermalZoneSetpoints,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thermalZones/{zone_name}/setpoints',
                'operation_id': 'read_thermal_zone_setpoints',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'zone_name',
                ],
                'required': [
                    'site_id',
                    'zone_name',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'zone_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('zone_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'zone_name':
                        (str,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'zone_name': 'zone_name',
                },
                'location_map': {
                    'site_id': 'path',
                    'zone_name': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.update_baseline_model_endpoint = _Endpoint(
            settings={
                'response_type': (BaselineModel,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/devices/{device_name}/models/baseline',
                'operation_id': 'update_baseline_model',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'device_name',
                    'baseline_model',
                    'horizon',
                    'forecast_type',
                ],
                'required': [
                    'site_id',
                    'device_name',
                    'baseline_model',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'device_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('device_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'device_name':
                        (str,),
                    'baseline_model':
                        (BaselineModel,),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'device_name': 'device_name',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                },
                'location_map': {
                    'site_id': 'path',
                    'device_name': 'path',
                    'baseline_model': 'body',
                    'horizon': 'query',
                    'forecast_type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.update_flexibility_model_endpoint = _Endpoint(
            settings={
                'response_type': (FlexibilityModel,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thermalZones/{zone_name}/models/flexibility',
                'operation_id': 'update_flexibility_model',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'zone_name',
                    'flexibility_model',
                    'horizon',
                    'forecast_type',
                ],
                'required': [
                    'site_id',
                    'zone_name',
                    'flexibility_model',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'zone_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('zone_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'zone_name':
                        (str,),
                    'flexibility_model':
                        (FlexibilityModel,),
                    'horizon':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                    'forecast_type':
                        (bool, date, datetime, dict, float, int, list, str, none_type,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'zone_name': 'zone_name',
                    'horizon': 'horizon',
                    'forecast_type': 'forecast_type',
                },
                'location_map': {
                    'site_id': 'path',
                    'zone_name': 'path',
                    'flexibility_model': 'body',
                    'horizon': 'query',
                    'forecast_type': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.update_site_endpoint = _Endpoint(
            settings={
                'response_type': (Site,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}',
                'operation_id': 'update_site',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'site_update',
                ],
                'required': [
                    'site_id',
                    'site_update',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'site_update':
                        (SiteUpdate,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                    'site_update': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.update_site_availability_endpoint = _Endpoint(
            settings={
                'response_type': (SiteAvailabilityEnum,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/availability',
                'operation_id': 'update_site_availability',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'body',
                ],
                'required': [
                    'site_id',
                    'body',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'body':
                        (SiteAvailabilityEnum,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                },
                'location_map': {
                    'site_id': 'path',
                    'body': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.update_thermal_zone_setpoints_endpoint = _Endpoint(
            settings={
                'response_type': (ThermalZoneSetpoints,),
                'auth': [
                    'BearerAuth'
                ],
                'endpoint_path': '/sites/{site_id}/thermalZones/{zone_name}/setpoints',
                'operation_id': 'update_thermal_zone_setpoints',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'site_id',
                    'zone_name',
                    'thermal_zone_setpoints',
                ],
                'required': [
                    'site_id',
                    'zone_name',
                    'thermal_zone_setpoints',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'site_id',
                    'zone_name',
                ]
            },
            root_map={
                'validations': {
                    ('site_id',): {

                        'inclusive_maximum': 99999,
                        'inclusive_minimum': 10000,
                    },
                    ('zone_name',): {

                        'min_length': 2,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'site_id':
                        (int,),
                    'zone_name':
                        (str,),
                    'thermal_zone_setpoints':
                        (ThermalZoneSetpoints,),
                },
                'attribute_map': {
                    'site_id': 'site_id',
                    'zone_name': 'zone_name',
                },
                'location_map': {
                    'site_id': 'path',
                    'zone_name': 'path',
                    'thermal_zone_setpoints': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )

    def create_site(
        self,
        site_create,
        **kwargs
    ):
        """Create a Site  # noqa: E501

        Create a Site with all the information.  - **site_name**: each site must have a name - **flexumer_id**: each site must be associated with a flexumer - **weather_id**: each site must be associated with a weather station - **tariff_id**: each site must be associated with an electricity tariff - **energy_injection**: If True, energy can be injected into the grid - **location**: a site can optionally have a location - **country**: a site can optionally have a country - **country_code**: each site must have an ISO 3166 country code - **timezone**: each site must have a time zone - **latitude**: a site can optionally have a latitude - **longitude**: a site can optionally have a longitude - **elevation**: a site can optionally have an elevation - **microgrid**: a site must have a microgrid JSON describing devices and sensors  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_site(site_create, async_req=True)
        >>> result = thread.get()

        Args:
            site_create (SiteCreate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            Site
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_create'] = \
            site_create
        return self.create_site_endpoint.call_with_http_info(**kwargs)

    def delete_device_baseline_plan(
        self,
        site_id,
        device_name,
        **kwargs
    ):
        """Delete an existing baseline week plan  # noqa: E501

        Delete the baseline week plan of the selected device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_device_baseline_plan(site_id, device_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [WeekPlanDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        return self.delete_device_baseline_plan_endpoint.call_with_http_info(**kwargs)

    def delete_site(
        self,
        site_id,
        **kwargs
    ):
        """Delete a Site  # noqa: E501

        Delete a Site.  **WARNING!: Site deletion is PERMANENT!** (no way to recover deleted site)  **WARNING!: Deleting a Site does not delete the associated measurements,  forecasts or tariffs!**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_site(site_id, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            Site
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        return self.delete_site_endpoint.call_with_http_info(**kwargs)

    def get_device_baseline_plan(
        self,
        site_id,
        device_name,
        **kwargs
    ):
        """Get baseline week plan for selected device  # noqa: E501

        Get the baseline week plan for the selected device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_device_baseline_plan(site_id, device_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [WeekPlanDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        return self.get_device_baseline_plan_endpoint.call_with_http_info(**kwargs)

    def get_site_devices_thresholds(
        self,
        site_id,
        **kwargs
    ):
        """Return devices thresholds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_site_devices_thresholds(site_id, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            SiteThresholds
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        return self.get_site_devices_thresholds_endpoint.call_with_http_info(**kwargs)

    def get_site_flexibility_forecast(
        self,
        site_id,
        **kwargs
    ):
        """Get flexibility forecast of a site  # noqa: E501

        Get flexibility forecast of a site.  The flexibility forecast of a site is a timeseries calculated by adding the flexibility forecasts of the devices and the thermal zones of the site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_site_flexibility_forecast(site_id, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): The option `best_available` shows the best forecast that is available for each timestamp, favoring intra-day over day-ahead.. [optional]
            ramping (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            start_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").. [optional]
            end_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").. [optional]
            frequency (bool, date, datetime, dict, float, int, list, str, none_type): Aggregate measurements to this frequency. The measurements will include data for whole periods.  For example, if _start_time_ = '2021-05-01T10:23:00Z', _end_time_ = '2021-05-01T10:49:00Z' and _frequency_ = 'quarter', the backend queries data from '2021-05-01T10:15:00Z' to '2021-05-01T11:00:00Z' (not included) and resamples it every 15 minutes.  . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        return self.get_site_flexibility_forecast_endpoint.call_with_http_info(**kwargs)

    def get_site_id_by_name(
        self,
        site_name,
        **kwargs
    ):
        """Retrieve Site ID given a Site Name  # noqa: E501

        Retrieve Site ID given a Site Name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_site_id_by_name(site_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_name (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            int
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_name'] = \
            site_name
        return self.get_site_id_by_name_endpoint.call_with_http_info(**kwargs)

    def get_site_statistics(
        self,
        site_id,
        start_time,
        end_time,
        **kwargs
    ):
        """Get summary statistics of a flexumer  # noqa: E501

        Get summary statistics of a flexumer for one site.  - `number_of_activations` of the site during the period of interest. - `reliability_index` of the site. This is the current reliability  index, it does not depend on the `start_time` and `end_time`  parameters. - **`co2_reduction` is not implemented yet, and returns null.**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_site_statistics(site_id, start_time, end_time, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            start_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").
            end_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            SiteFlexumerStatistics
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['start_time'] = \
            start_time
        kwargs['end_time'] = \
            end_time
        return self.get_site_statistics_endpoint.call_with_http_info(**kwargs)

    def get_thermal_zone_modes_in_range(
        self,
        site_id,
        zone_name,
        start_time,
        end_time,
        **kwargs
    ):
        """Return mode for selected thermal zone  # noqa: E501

        Returns the mode of a thermal zone in a time series.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_thermal_zone_modes_in_range(site_id, zone_name, start_time, end_time, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            zone_name (str):
            start_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). Make sure to specify the timezone either with \"Z\" or \"+00:00\"
            end_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). Make sure to specify the timezone either with \"Z\" or \"+00:00\"

        Keyword Args:
            frequency (bool, date, datetime, dict, float, int, list, str, none_type): Aggregate measurements to this frequency. The measurements will include data for whole periods.  For example, if _start_time_ = '2021-05-01T10:23:00Z', _end_time_ = '2021-05-01T10:49:00Z' and _frequency_ = 'quarter', the backend queries data from '2021-05-01T10:15:00Z' to '2021-05-01T11:00:00Z' (not included) and resamples it every 15 minutes.  . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['zone_name'] = \
            zone_name
        kwargs['start_time'] = \
            start_time
        kwargs['end_time'] = \
            end_time
        return self.get_thermal_zone_modes_in_range_endpoint.call_with_http_info(**kwargs)

    def get_treatment_plant_cost(
        self,
        site_id,
        plant_name,
        start_time,
        end_time,
        **kwargs
    ):
        """Get Treatment Plant Cost  # noqa: E501

        Get site and retailer average costs for treatment plant management.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_treatment_plant_cost(site_id, plant_name, start_time, end_time, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            plant_name (str):
            start_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").
            end_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").

        Keyword Args:
            spot_market_id (int): Identifier of spot market. [optional] if omitted the server will use the default value of 1002
            frequency (bool, date, datetime, dict, float, int, list, str, none_type): Aggregate measurements to this frequency.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            SiteTreatmentPlantCosts
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['plant_name'] = \
            plant_name
        kwargs['start_time'] = \
            start_time
        kwargs['end_time'] = \
            end_time
        return self.get_treatment_plant_cost_endpoint.call_with_http_info(**kwargs)

    def insert_device_baseline_forecasts(
        self,
        site_id,
        device_name,
        site_data_point,
        **kwargs
    ):
        """Insert/update baseline forecasts for selected device  # noqa: E501

        Insert/update baseline forecasts for selected device.  - **Timestamps don't need to be pushed in any particular order** - **Data points will be stored exactly as pushed** (no transformation applied)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.insert_device_baseline_forecasts(site_id, device_name, site_data_point, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):
            site_data_point ([SiteDataPoint]):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): If user role is Flexumer/SiteManager, the forecast type is automatically set as `user-given`, and this option has no effect.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        kwargs['site_data_point'] = \
            site_data_point
        return self.insert_device_baseline_forecasts_endpoint.call_with_http_info(**kwargs)

    def insert_device_baseline_plan(
        self,
        site_id,
        device_name,
        week_plan_data_point,
        **kwargs
    ):
        """Insert/update baseline week plan for selected device  # noqa: E501

        Insert/update the baseline week plan for the selected device.  **The values of each datapoint carry on until the next datapoint.**  The site's timezone will apply.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.insert_device_baseline_plan(site_id, device_name, week_plan_data_point, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):
            week_plan_data_point ([WeekPlanDataPoint]):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [WeekPlanDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        kwargs['week_plan_data_point'] = \
            week_plan_data_point
        return self.insert_device_baseline_plan_endpoint.call_with_http_info(**kwargs)

    def insert_device_flexibility_forecasts(
        self,
        site_id,
        device_name,
        site_data_point,
        **kwargs
    ):
        """Insert/update flexibility forecasts for selected device  # noqa: E501

        Insert/update flexibility forecasts for selected device.  - **Timestamps don't need to be pushed in any particular order** - **Data points will be stored exactly as pushed** (no transformation applied)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.insert_device_flexibility_forecasts(site_id, device_name, site_data_point, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):
            site_data_point ([SiteDataPoint]):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            ramping (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        kwargs['site_data_point'] = \
            site_data_point
        return self.insert_device_flexibility_forecasts_endpoint.call_with_http_info(**kwargs)

    def insert_site_reliability_index(
        self,
        site_id,
        site_reliability_index,
        **kwargs
    ):
        """Insert site reliability index  # noqa: E501

        Insert site reliability index.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.insert_site_reliability_index(site_id, site_reliability_index, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            site_reliability_index (SiteReliabilityIndex):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['site_reliability_index'] = \
            site_reliability_index
        return self.insert_site_reliability_index_endpoint.call_with_http_info(**kwargs)

    def insert_thermal_zone_flexibility_forecasts(
        self,
        site_id,
        zone_name,
        site_data_point,
        **kwargs
    ):
        """Insert/update flexibility forecasts for selected thermal zone  # noqa: E501

        Insert/update flexibility forecasts for selected thermal zone.  - **Timestamps don't need to be pushed in any particular order** - **Data points will be stored exactly as pushed** (no transformation applied)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.insert_thermal_zone_flexibility_forecasts(site_id, zone_name, site_data_point, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            zone_name (str):
            site_data_point ([SiteDataPoint]):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            ramping (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['zone_name'] = \
            zone_name
        kwargs['site_data_point'] = \
            site_data_point
        return self.insert_thermal_zone_flexibility_forecasts_endpoint.call_with_http_info(**kwargs)

    def list_devices(
        self,
        site_id,
        **kwargs
    ):
        """List active devices of a given device type in a site  # noqa: E501

        List active devices of a given device type in a site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_devices(site_id, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):

        Keyword Args:
            device_type (str): [optional] if omitted the server will use the default value of "meters"
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ResponseListDevicesSitesSiteIdDevicesGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        return self.list_devices_endpoint.call_with_http_info(**kwargs)

    def list_sites(
        self,
        **kwargs
    ):
        """List all Sites  # noqa: E501

        List all Sites.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_sites(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteListItem]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.list_sites_endpoint.call_with_http_info(**kwargs)

    def list_thermal_zones(
        self,
        site_id,
        **kwargs
    ):
        """List active thermal zones for a given Site  # noqa: E501

        List active thermal zones for a given Site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_thermal_zones(site_id, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [ThermalZone]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        return self.list_thermal_zones_endpoint.call_with_http_info(**kwargs)

    def post_publish_pub_sub_site_device_measurements(
        self,
        site_id,
        device_name,
        site_data_point,
        **kwargs
    ):
        """Insert/update measurements of a device  # noqa: E501

        Insert/update measurements for selected site and device.  - Timestamps don't need to be pushed in any particular order. - Data points will replace existing data points with the same timestamp.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_publish_pub_sub_site_device_measurements(site_id, device_name, site_data_point, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):
            site_data_point ([SiteDataPoint]):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        kwargs['site_data_point'] = \
            site_data_point
        return self.post_publish_pub_sub_site_device_measurements_endpoint.call_with_http_info(**kwargs)

    def post_publish_pub_sub_site_measurements(
        self,
        site_id,
        site_measurements,
        **kwargs
    ):
        """Insert/update measurements of a site  # noqa: E501

        Insert/update measurements for selected site.  - Timestamps don't need to be pushed in any particular order. - Data points will replace existing data points with the same timestamp.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_publish_pub_sub_site_measurements(site_id, site_measurements, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            site_measurements ([SiteMeasurements]):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteMeasurements]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['site_measurements'] = \
            site_measurements
        return self.post_publish_pub_sub_site_measurements_endpoint.call_with_http_info(**kwargs)

    def put_insert_device_measurements_private(
        self,
        site_id,
        device_name,
        site_data_point,
        **kwargs
    ):
        """Insert/update measurements for selected device (internal only)  # noqa: E501

        Put measurements directly into database (for private use only).  **Do not use this endpoint directly.** This endpoint should only be used by the DataFlow pipeline to save data after preprocessing. Use `sites/{site_id}/devices/{device_name}/measurements/` instead.  - Timestamps don't need to be pushed in any particular order. - Data points will be stored exactly as pushed (no transformation applied). - Data points will replace existing data points with the same timestamp.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_insert_device_measurements_private(site_id, device_name, site_data_point, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):
            site_data_point ([SiteDataPoint]):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        kwargs['site_data_point'] = \
            site_data_point
        return self.put_insert_device_measurements_private_endpoint.call_with_http_info(**kwargs)

    def put_insert_site_measurements_private(
        self,
        site_id,
        site_measurements,
        **kwargs
    ):
        """Insert/update measurements of a site (internal only)  # noqa: E501

        Put measurements directly into database (for private use only).  **Do not use this endpoint directly.** This endpoint should only be used by the DataFlow pipeline to save data after preprocessing. Use `sites/{site_id}/measurements/` instead.  - Data points will be stored exactly as pushed (no transformation applied). - Timestamps don't need to be pushed in any particular order. - Data points will replace existing data points with the same timestamp.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_insert_site_measurements_private(site_id, site_measurements, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            site_measurements ([SiteMeasurements]):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteMeasurements]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['site_measurements'] = \
            site_measurements
        return self.put_insert_site_measurements_private_endpoint.call_with_http_info(**kwargs)

    def put_publish_pub_sub_site_device_measurements(
        self,
        site_id,
        device_name,
        site_data_point,
        **kwargs
    ):
        """Insert/update measurements of a device  # noqa: E501

        Insert/update measurements for selected site and device.  - Timestamps don't need to be pushed in any particular order. - Data points will replace existing data points with the same timestamp.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_publish_pub_sub_site_device_measurements(site_id, device_name, site_data_point, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):
            site_data_point ([SiteDataPoint]):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            bool, date, datetime, dict, float, int, list, str, none_type
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        kwargs['site_data_point'] = \
            site_data_point
        return self.put_publish_pub_sub_site_device_measurements_endpoint.call_with_http_info(**kwargs)

    def put_publish_pub_sub_site_measurements(
        self,
        site_id,
        site_measurements,
        **kwargs
    ):
        """Insert/update measurements of a site  # noqa: E501

        Insert/update measurements for selected site.  - Timestamps don't need to be pushed in any particular order. - Data points will replace existing data points with the same timestamp.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_publish_pub_sub_site_measurements(site_id, site_measurements, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            site_measurements ([SiteMeasurements]):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteMeasurements]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['site_measurements'] = \
            site_measurements
        return self.put_publish_pub_sub_site_measurements_endpoint.call_with_http_info(**kwargs)

    def put_site_devices_thresholds(
        self,
        site_id,
        site_thresholds,
        **kwargs
    ):
        """Set/Update devices thresholds  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.put_site_devices_thresholds(site_id, site_thresholds, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            site_thresholds (SiteThresholds):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            SiteThresholds
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['site_thresholds'] = \
            site_thresholds
        return self.put_site_devices_thresholds_endpoint.call_with_http_info(**kwargs)

    def read_baseline_model(
        self,
        site_id,
        device_name,
        **kwargs
    ):
        """Return baseline model parameters for selected device  # noqa: E501

        Return baseline model parameters for selected device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_baseline_model(site_id, device_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            BaselineModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        return self.read_baseline_model_endpoint.call_with_http_info(**kwargs)

    def read_device(
        self,
        site_id,
        device_name,
        **kwargs
    ):
        """Return description of selected device  # noqa: E501

        Return description of selected device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_device(site_id, device_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ResponseReadDeviceSitesSiteIdDevicesDeviceNameGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        return self.read_device_endpoint.call_with_http_info(**kwargs)

    def read_device_activations(
        self,
        site_id,
        device_name,
        **kwargs
    ):
        """Return current activation for selected device  # noqa: E501

        Return activations with status scheduled or active activation.  If there is no active activation, return an empty response.  Returns HTTP400 if the device is not controllable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_device_activations(site_id, device_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):

        Keyword Args:
            end_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). If not provided, the default value is now.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ResponseReadDeviceActivationsSitesSiteIdDevicesDeviceNameActivationsGet
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        return self.read_device_activations_endpoint.call_with_http_info(**kwargs)

    def read_device_baseline_forecasts(
        self,
        site_id,
        device_name,
        **kwargs
    ):
        """Return baseline forecasts for selected device  # noqa: E501

        Return baseline forecasts for selected device.  - **Timestamps are ordered from oldest to newest** - **Data is returned with the same sign convention as when pushed** (not transformation applied)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_device_baseline_forecasts(site_id, device_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): The option `best_available` shows the best forecast that is available for each timestamp, favoring intra-day over day-ahead, and favoring user-given over the rest.. [optional]
            period (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            start_time (str): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). Make sure to specify the timezone either with \"Z\" or \"+00:00\". [optional]
            end_time (str): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). Make sure to specify the timezone either with \"Z\" or \"+00:00\". [optional]
            frequency (bool, date, datetime, dict, float, int, list, str, none_type): Aggregate measurements to this frequency. The measurements will include data for whole periods.  For example, if _start_time_ = '2021-05-01T10:23:00Z', _end_time_ = '2021-05-01T10:49:00Z' and _frequency_ = 'quarter', the backend queries data from '2021-05-01T10:15:00Z' to '2021-05-01T11:00:00Z' (not included) and resamples it every 15 minutes.  . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        return self.read_device_baseline_forecasts_endpoint.call_with_http_info(**kwargs)

    def read_device_flexibility_forecasts(
        self,
        site_id,
        device_name,
        **kwargs
    ):
        """Return flexibility forecasts for selected device  # noqa: E501

        Return flexibility forecasts for selected device.  - **Timestamps are ordered from oldest to newest** - **Data is returned with the same sign convention as when pushed** (not transformation applied)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_device_flexibility_forecasts(site_id, device_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): The option `best_available` shows the best forecast that is available for each timestamp, favoring intra-day over day-ahead.. [optional]
            ramping (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            period (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            start_time (str): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). Make sure to specify the timezone either with \"Z\" or \"+00:00\". [optional]
            end_time (str): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). Make sure to specify the timezone either with \"Z\" or \"+00:00\". [optional]
            frequency (bool, date, datetime, dict, float, int, list, str, none_type): Aggregate measurements to this frequency. The measurements will include data for whole periods.  For example, if _start_time_ = '2021-05-01T10:23:00Z', _end_time_ = '2021-05-01T10:49:00Z' and _frequency_ = 'quarter', the backend queries data from '2021-05-01T10:15:00Z' to '2021-05-01T11:00:00Z' (not included) and resamples it every 15 minutes.  . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        return self.read_device_flexibility_forecasts_endpoint.call_with_http_info(**kwargs)

    def read_device_measurements(
        self,
        site_id,
        device_name,
        **kwargs
    ):
        """Return measurements for selected device  # noqa: E501

        Return measurements for selected device.  - **Timestamps are ordered from oldest to newest**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_device_measurements(site_id, device_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):

        Keyword Args:
            period (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            start_time (str): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). Make sure to specify the timezone either with \"Z\" or \"+00:00\". [optional]
            end_time (str): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). Make sure to specify the timezone either with \"Z\" or \"+00:00\". [optional]
            frequency (bool, date, datetime, dict, float, int, list, str, none_type): Aggregate measurements to this frequency. The measurements will include data for whole periods.  For example, if _start_time_ = '2021-05-01T10:23:00Z', _end_time_ = '2021-05-01T10:49:00Z' and _frequency_ = 'quarter', the backend queries data from '2021-05-01T10:15:00Z' to '2021-05-01T11:00:00Z' (not included) and resamples it every 15 minutes.  . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        return self.read_device_measurements_endpoint.call_with_http_info(**kwargs)

    def read_flexibility_model(
        self,
        site_id,
        zone_name,
        **kwargs
    ):
        """Return flexibility model parameters for selected thermal zone  # noqa: E501

        Return flexibility model parameters for selected thermal zone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_flexibility_model(site_id, zone_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            zone_name (str):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            FlexibilityModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['zone_name'] = \
            zone_name
        return self.read_flexibility_model_endpoint.call_with_http_info(**kwargs)

    def read_measurements(
        self,
        site_id,
        device_types,
        start_time,
        end_time,
        **kwargs
    ):
        """Get devices measurements for selected device types  # noqa: E501

        Get devices measurements for selected device types.  The response list preserves the order of `device_types` query parameter.  - **Timestamps are ordered from oldest to newest**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_measurements(site_id, device_types, start_time, end_time, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_types ([str]):
            start_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").
            end_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").

        Keyword Args:
            frequency (bool, date, datetime, dict, float, int, list, str, none_type): Aggregate measurements to this frequency. The measurements will include data for whole periods.  For example, if _start_time_ = '2021-05-01T10:23:00Z', _end_time_ = '2021-05-01T10:49:00Z' and _frequency_ = 'quarter', the backend queries data from '2021-05-01T10:15:00Z' to '2021-05-01T11:00:00Z' (not included) and resamples it every 15 minutes.  . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [DeviceMeasurements]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_types'] = \
            device_types
        kwargs['start_time'] = \
            start_time
        kwargs['end_time'] = \
            end_time
        return self.read_measurements_endpoint.call_with_http_info(**kwargs)

    def read_measurements_statistics(
        self,
        site_id,
        device_types,
        start_time,
        end_time,
        **kwargs
    ):
        """Get statistics of a site by device type list  # noqa: E501

        Get a list of total energy (consumed or generated) by device type.  The response list preserves the order of `device_types` query parameter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_measurements_statistics(site_id, device_types, start_time, end_time, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_types ([str]):
            start_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").
            end_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [DeviceTypeMeasurementsStatistics]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_types'] = \
            device_types
        kwargs['start_time'] = \
            start_time
        kwargs['end_time'] = \
            end_time
        return self.read_measurements_statistics_endpoint.call_with_http_info(**kwargs)

    def read_site(
        self,
        site_id,
        **kwargs
    ):
        """Info about a specific Site  # noqa: E501

        Info about a specific Site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_site(site_id, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            SiteWithIsLoadDistinct
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        return self.read_site_endpoint.call_with_http_info(**kwargs)

    def read_site_activations(
        self,
        site_id,
        time,
        **kwargs
    ):
        """Get list of activations of a site  # noqa: E501

        List site activations with status scheduled or active.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_site_activations(site_id, time, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [DeviceActivationListItem]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['time'] = \
            time
        return self.read_site_activations_endpoint.call_with_http_info(**kwargs)

    def read_site_activations_frontend(
        self,
        site_id,
        start_time,
        end_time,
        **kwargs
    ):
        """Get time series of activations of a site  # noqa: E501

        Return the time series of activations of a site.  A Site is considered to be activated if any of its controllable devices are activated.  Return schema suits frontend needs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_site_activations_frontend(site_id, start_time, end_time, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            start_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").
            end_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteActivationDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['start_time'] = \
            start_time
        kwargs['end_time'] = \
            end_time
        return self.read_site_activations_frontend_endpoint.call_with_http_info(**kwargs)

    def read_site_availability(
        self,
        site_id,
        **kwargs
    ):
        """Read the site availability  # noqa: E501

        Read the site availability.  If `available`, site is available to offer flexibility. Else, the site will ignore activation messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_site_availability(site_id, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            SiteAvailabilityEnum
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        return self.read_site_availability_endpoint.call_with_http_info(**kwargs)

    def read_site_availability_schedule(
        self,
        site_id,
        start_time,
        end_time,
        **kwargs
    ):
        """Return a Site's availability schedule between two dates  # noqa: E501

        Return a Site's availability schedule between two dates.  `start_time`, `end_time` and `frequency` define a schedule made of consecutive periods. All periods have the same duration, determined by `frequency`, and for this reason the last period is considered to finish after `end_time` if necessary. The returned times correspond to the start of these periods. A period is considered unavailable if at any point in time during that period the site was unavailable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_site_availability_schedule(site_id, start_time, end_time, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            start_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").
            end_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").

        Keyword Args:
            frequency (bool, date, datetime, dict, float, int, list, str, none_type): Time resolution of availability schedule. . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [AvailabilityScheduleItem]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['start_time'] = \
            start_time
        kwargs['end_time'] = \
            end_time
        return self.read_site_availability_schedule_endpoint.call_with_http_info(**kwargs)

    def read_site_contract_schedule(
        self,
        site_id,
        start_time,
        end_time,
        **kwargs
    ):
        """Return contract schedule between two dates  # noqa: E501

        Return contract schedule of a site within the given dates.  The frequency of the data is hourly.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_site_contract_schedule(site_id, start_time, end_time, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            start_time (datetime): Either a timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").
            end_time (datetime): Either a timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\").

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [ContractScheduleItem]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['start_time'] = \
            start_time
        kwargs['end_time'] = \
            end_time
        return self.read_site_contract_schedule_endpoint.call_with_http_info(**kwargs)

    def read_site_reliability_index(
        self,
        site_id,
        **kwargs
    ):
        """Get last reliability index  # noqa: E501

        Get the last reliability index for a site in the given period.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_site_reliability_index(site_id, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):

        Keyword Args:
            start_time (datetime): If provided, start of the period of interest. It must be a timestamp in RFC3339 format (\"YYYY-MM-DDT00:00:00Z\"), with UTC timezone. By default, it is 366 days before end_time.. [optional]
            end_time (datetime): If provided, start of the period of interest. It must be a timestamp in RFC3339 format (\"YYYY-MM-DDT00:00:00Z\"), with UTC timezone. By default, it is the current datetime.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            SiteReliabilityIndex
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        return self.read_site_reliability_index_endpoint.call_with_http_info(**kwargs)

    def read_sites_activations(
        self,
        **kwargs
    ):
        """Return activation state of all sites  # noqa: E501

        Get activation state of all sites at the given `end_time`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_sites_activations(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            end_time (datetime): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). If not provided, the default value is now.. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteActivationListItem]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.read_sites_activations_endpoint.call_with_http_info(**kwargs)

    def read_sites_availability(
        self,
        **kwargs
    ):
        """Get availability of all sites  # noqa: E501

        Get availability of all sites.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_sites_availability(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteAvailabilityListItem]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.read_sites_availability_endpoint.call_with_http_info(**kwargs)

    def read_sites_statistics(
        self,
        **kwargs
    ):
        """Get summary statistics of all sites  # noqa: E501

        Get summary statistics of all sites.  It includes, for each site: - `reliability_index`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_sites_statistics(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteFlexumerStatistics]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.read_sites_statistics_endpoint.call_with_http_info(**kwargs)

    def read_thermal_zone(
        self,
        site_id,
        zone_name,
        **kwargs
    ):
        """Return description of selected thermal zone  # noqa: E501

        Return description of selected thermal zone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_thermal_zone(site_id, zone_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            zone_name (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ThermalZone
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['zone_name'] = \
            zone_name
        return self.read_thermal_zone_endpoint.call_with_http_info(**kwargs)

    def read_thermal_zone_flexibility_forecasts(
        self,
        site_id,
        zone_name,
        **kwargs
    ):
        """Return flexibility forecasts for selected thermal zone  # noqa: E501

        Return flexibility forecasts for selected thermal zone.  - **Timestamps are ordered from oldest to newest** - **Data is returned with the same sign convention as when pushed** (not transformation applied)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_thermal_zone_flexibility_forecasts(site_id, zone_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            zone_name (str):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): The option `best_available` shows the best forecast that is available for each timestamp, favoring intra-day over day-ahead.. [optional]
            ramping (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            period (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            start_time (str): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). Make sure to specify the timezone either with \"Z\" or \"+00:00\". [optional]
            end_time (str): A timestamp in RFC3339 format, in UTC timezone (\"YYYY-MM-DDT00:00:00Z\"). Make sure to specify the timezone either with \"Z\" or \"+00:00\". [optional]
            frequency (bool, date, datetime, dict, float, int, list, str, none_type): Aggregate measurements to this frequency. The measurements will include data for whole periods.  For example, if _start_time_ = '2021-05-01T10:23:00Z', _end_time_ = '2021-05-01T10:49:00Z' and _frequency_ = 'quarter', the backend queries data from '2021-05-01T10:15:00Z' to '2021-05-01T11:00:00Z' (not included) and resamples it every 15 minutes.  . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            [SiteDataPoint]
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['zone_name'] = \
            zone_name
        return self.read_thermal_zone_flexibility_forecasts_endpoint.call_with_http_info(**kwargs)

    def read_thermal_zone_setpoints(
        self,
        site_id,
        zone_name,
        **kwargs
    ):
        """Return setpoint parameters for selected thermal zone  # noqa: E501

        Return setpoint parameters for selected thermal zone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_thermal_zone_setpoints(site_id, zone_name, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            zone_name (str):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ThermalZoneSetpoints
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['zone_name'] = \
            zone_name
        return self.read_thermal_zone_setpoints_endpoint.call_with_http_info(**kwargs)

    def update_baseline_model(
        self,
        site_id,
        device_name,
        baseline_model,
        **kwargs
    ):
        """Set/update baseline model parameters for selected device  # noqa: E501

        Set/update baseline model parameters for selected device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_baseline_model(site_id, device_name, baseline_model, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            device_name (str):
            baseline_model (BaselineModel):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            BaselineModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['device_name'] = \
            device_name
        kwargs['baseline_model'] = \
            baseline_model
        return self.update_baseline_model_endpoint.call_with_http_info(**kwargs)

    def update_flexibility_model(
        self,
        site_id,
        zone_name,
        flexibility_model,
        **kwargs
    ):
        """Set/update flexibility model parameters for selected thermal zone  # noqa: E501

        Set/update flexibility model parameters for selected thermal zone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_flexibility_model(site_id, zone_name, flexibility_model, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            zone_name (str):
            flexibility_model (FlexibilityModel):

        Keyword Args:
            horizon (bool, date, datetime, dict, float, int, list, str, none_type): Deprecated, use `forecast_type` instead.. [optional]
            forecast_type (bool, date, datetime, dict, float, int, list, str, none_type): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            FlexibilityModel
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['zone_name'] = \
            zone_name
        kwargs['flexibility_model'] = \
            flexibility_model
        return self.update_flexibility_model_endpoint.call_with_http_info(**kwargs)

    def update_site(
        self,
        site_id,
        site_update,
        **kwargs
    ):
        """Update an existing Site  # noqa: E501

        Update information about a Site.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_site(site_id, site_update, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            site_update (SiteUpdate):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            Site
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['site_update'] = \
            site_update
        return self.update_site_endpoint.call_with_http_info(**kwargs)

    def update_site_availability(
        self,
        site_id,
        body,
        **kwargs
    ):
        """Set the site availability status  # noqa: E501

        Set the site availability.  Set to True if site is available to offer flexibility. Set to False if site must ignore activation messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_site_availability(site_id, body, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            body (SiteAvailabilityEnum):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            SiteAvailabilityEnum
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['body'] = \
            body
        return self.update_site_availability_endpoint.call_with_http_info(**kwargs)

    def update_thermal_zone_setpoints(
        self,
        site_id,
        zone_name,
        thermal_zone_setpoints,
        **kwargs
    ):
        """Set/Update setpoint parameters for selected thermal zone  # noqa: E501

        Set/Update setpoint parameters for selected thermal zone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_thermal_zone_setpoints(site_id, zone_name, thermal_zone_setpoints, async_req=True)
        >>> result = thread.get()

        Args:
            site_id (int):
            zone_name (str):
            thermal_zone_setpoints (ThermalZoneSetpoints):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ThermalZoneSetpoints
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['site_id'] = \
            site_id
        kwargs['zone_name'] = \
            zone_name
        kwargs['thermal_zone_setpoints'] = \
            thermal_zone_setpoints
        return self.update_thermal_zone_setpoints_endpoint.call_with_http_info(**kwargs)

