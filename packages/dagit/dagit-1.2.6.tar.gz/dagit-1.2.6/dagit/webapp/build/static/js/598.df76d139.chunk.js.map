{"version":3,"file":"static/js/598.df76d139.chunk.js","mappings":"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","sources":["../../core/src/app/browser.tsx","../../core/src/runs/RunTags.tsx","../../core/src/runs/RunsFilterInput.tsx","../../ui/src/components/TokenizingField.tsx"],"sourcesContent":["import * as React from 'react';\n\n/**\n * A hook that provides a mechanism for copying a string, triggered by user\n * behavior. If the Clipboard API is available, use it directly.\n *\n * The Clipboard can be undefined in an insecure context\n * (https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API), so we\n * also provide a fallback that uses an offscreen input and `execCommand` to\n * copy the contents. This is less ideal because it steals focus and is a DOM\n * hack, but it should still be effective enough for our needs.\n */\nexport const useCopyToClipboard = () => {\n  const clipboardAPI = navigator.clipboard;\n  const node = React.useRef<HTMLInputElement | null>(null);\n\n  React.useEffect(() => {\n    if (!clipboardAPI) {\n      node.current = document.createElement('input');\n      node.current.style.position = 'fixed';\n      node.current.style.top = '-10000px';\n      document.body.appendChild(node.current);\n    }\n\n    return () => {\n      node.current && document.body.removeChild(node.current);\n    };\n  }, [clipboardAPI]);\n\n  return React.useCallback(\n    (text: string) => {\n      if (clipboardAPI) {\n        clipboardAPI.writeText(text);\n      } else if (node.current) {\n        node.current.value = text;\n        node.current.select();\n        document.execCommand('copy');\n      }\n    },\n    [clipboardAPI],\n  );\n};\n","import {Box} from '@dagster-io/ui';\nimport * as React from 'react';\n\nimport {SharedToaster} from '../app/DomUtils';\nimport {useCopyToClipboard} from '../app/browser';\nimport {__ASSET_JOB_PREFIX} from '../asset-graph/Utils';\n\nimport {DagsterTag, RunTag, TagType} from './RunTag';\nimport {RunFilterToken} from './RunsFilterInput';\n\n// Sort these tags to the start of the list.\nexport const priorityTagSet = new Set([\n  DagsterTag.ScheduleName as string,\n  DagsterTag.SensorName as string,\n  DagsterTag.Backfill as string,\n]);\n\nconst renamedTags = {\n  [DagsterTag.SolidSelection]: DagsterTag.OpSelection,\n};\n\nexport const canAddTagToFilter = (key: string) => {\n  return key !== DagsterTag.SolidSelection && key !== DagsterTag.OpSelection;\n};\n\nexport const RunTags: React.FC<{\n  tags: TagType[];\n  mode: string | null;\n  onAddTag?: (token: RunFilterToken) => void;\n}> = React.memo(({tags, onAddTag, mode}) => {\n  const copy = useCopyToClipboard();\n\n  const copyAction = React.useMemo(\n    () => ({\n      label: 'Copy tag',\n      onClick: (tag: TagType) => {\n        copy(`${tag.key}:${tag.value}`);\n        SharedToaster.show({intent: 'success', message: 'Copied tag!'});\n      },\n    }),\n    [copy],\n  );\n\n  const addToFilterAction = React.useMemo(\n    () =>\n      onAddTag\n        ? {\n            label: 'Add tag to filter',\n            onClick: (tag: TagType) => {\n              onAddTag({token: 'tag', value: `${tag.key}=${tag.value}`});\n            },\n          }\n        : null,\n    [onAddTag],\n  );\n\n  const actionsForTag = (tag: TagType) => {\n    const list = [copyAction];\n    if (addToFilterAction && canAddTagToFilter(tag.key)) {\n      list.push(addToFilterAction);\n    }\n    return list.filter((item) => !!item);\n  };\n\n  const displayedTags = React.useMemo(() => {\n    const priority = [];\n    const others = [];\n    const copiedTags = tags.map(({key, value}) => ({key, value}));\n    for (const tag of copiedTags) {\n      const {key} = tag;\n      if (renamedTags.hasOwnProperty(key)) {\n        tag.key = renamedTags[key as keyof typeof renamedTags];\n      }\n\n      if (\n        tag.value.startsWith(__ASSET_JOB_PREFIX) &&\n        (key === DagsterTag.PartitionSet || key === DagsterTag.StepSelection)\n      ) {\n        continue;\n      } else if (priorityTagSet.has(key)) {\n        priority.push(tag);\n      } else {\n        others.push(tag);\n      }\n    }\n    return [...priority, ...others];\n  }, [tags]);\n\n  if (!tags.length) {\n    return null;\n  }\n\n  return (\n    <Box flex={{direction: 'row', wrap: 'wrap', gap: 4}}>\n      {mode ? <RunTag tag={{key: 'mode', value: mode}} /> : null}\n      {displayedTags.map((tag, idx) => (\n        <RunTag tag={tag} key={idx} actions={actionsForTag(tag)} />\n      ))}\n    </Box>\n  );\n});\n","import {gql, useLazyQuery} from '@apollo/client';\nimport {\n  SuggestionProvider,\n  TokenizingField,\n  TokenizingFieldValue,\n  tokensAsStringArray,\n  tokenizedValuesFromStringArray,\n} from '@dagster-io/ui';\nimport qs from 'qs';\nimport * as React from 'react';\n\nimport {RunsFilter, RunStatus} from '../graphql/types';\nimport {useQueryPersistedState} from '../hooks/useQueryPersistedState';\nimport {DagsterRepoOption, useRepositoryOptions} from '../workspace/WorkspaceContext';\n\nimport {\n  RunTagKeysQuery,\n  RunTagValuesQuery,\n  RunTagValuesQueryVariables,\n} from './types/RunsFilterInput.types';\n\ntype RunTags = Array<{\n  __typename: 'PipelineTagAndValues';\n  key: string;\n  values: Array<string>;\n}>;\n\nexport type RunFilterTokenType = 'id' | 'status' | 'pipeline' | 'job' | 'snapshotId' | 'tag';\n\nexport type RunFilterToken = {\n  token?: RunFilterTokenType;\n  value: string;\n};\n\nconst RUN_PROVIDERS_EMPTY = [\n  {\n    token: 'id',\n    values: () => [],\n  },\n  {\n    token: 'status',\n    values: () => [],\n  },\n  {\n    token: 'pipeline',\n    values: () => [],\n  },\n  {\n    token: 'job',\n    values: () => [],\n  },\n  {\n    token: 'tag',\n    values: () => [],\n  },\n  {\n    token: 'snapshotId',\n    values: () => [],\n  },\n];\n\n/**\n * This React hook provides run filtering state similar to React.useState(), but syncs\n * the value to the URL query string so that reloading the page / navigating \"back\"\n * maintains your view as expected.\n *\n * @param enabledFilters: This is useful if you want to ignore some filters that could\n * be provided (eg pipeline:, which is not relevant within pipeline scoped views.)\n */\nexport function useQueryPersistedRunFilters(enabledFilters?: RunFilterTokenType[]) {\n  return useQueryPersistedState<RunFilterToken[]>(\n    React.useMemo(\n      () => ({\n        encode: (tokens) => ({q: tokensAsStringArray(tokens), cursor: undefined}),\n        decode: ({q = []}) =>\n          tokenizedValuesFromStringArray(q, RUN_PROVIDERS_EMPTY).filter(\n            (t) =>\n              !t.token || !enabledFilters || enabledFilters.includes(t.token as RunFilterTokenType),\n          ) as RunFilterToken[],\n      }),\n      [enabledFilters],\n    ),\n  );\n}\n\nexport function runsPathWithFilters(filterTokens: RunFilterToken[]) {\n  return `/runs?${qs.stringify({q: tokensAsStringArray(filterTokens)}, {arrayFormat: 'brackets'})}`;\n}\n\nexport function runsFilterForSearchTokens(search: TokenizingFieldValue[]) {\n  if (!search[0]) {\n    return {};\n  }\n\n  const obj: RunsFilter = {};\n\n  for (const item of search) {\n    if (item.token === 'pipeline' || item.token === 'job') {\n      obj.pipelineName = item.value;\n    } else if (item.token === 'id') {\n      obj.runIds = obj.runIds || [];\n      obj.runIds.push(item.value);\n    } else if (item.token === 'status') {\n      obj.statuses = obj.statuses || [];\n      obj.statuses.push(item.value as RunStatus);\n    } else if (item.token === 'snapshotId') {\n      obj.snapshotId = item.value;\n    } else if (item.token === 'tag') {\n      const [key, value = ''] = item.value.split('=');\n      if (obj.tags) {\n        obj.tags.push({key, value});\n      } else {\n        obj.tags = [{key, value}];\n      }\n    }\n  }\n\n  return obj;\n}\n\nfunction searchSuggestionsForRuns(\n  repositoryOptions: DagsterRepoOption[],\n  runTagKeys?: string[],\n  selectedRunTagKey?: string,\n  runTagValues?: RunTags,\n  enabledFilters?: RunFilterTokenType[],\n): SuggestionProvider[] {\n  const pipelineNames = new Set<string>();\n  const jobNames = new Set<string>();\n\n  for (const option of repositoryOptions) {\n    const {repository} = option;\n    for (const pipeline of repository.pipelines) {\n      if (pipeline.isJob) {\n        jobNames.add(pipeline.name);\n      } else {\n        pipelineNames.add(pipeline.name);\n      }\n    }\n  }\n\n  const suggestions: {token: RunFilterTokenType; values: () => string[]; textOnly?: boolean}[] = [\n    {\n      token: 'id',\n      values: () => [],\n    },\n    {\n      token: 'status',\n      values: () => Object.keys(RunStatus),\n    },\n    {\n      token: 'pipeline',\n      values: () => Array.from(pipelineNames),\n    },\n    {\n      token: 'job',\n      values: () => Array.from(jobNames),\n    },\n    {\n      token: 'tag',\n      values: () => {\n        if (!selectedRunTagKey) {\n          return (runTagKeys || []).map((key) => `${key}`);\n        }\n        return (runTagValues || [])\n          .filter(({key}) => key === selectedRunTagKey)\n          .map(({values}) => values.map((value) => `${selectedRunTagKey}=${value}`))\n          .flat();\n      },\n      textOnly: !selectedRunTagKey,\n    },\n    {\n      token: 'snapshotId',\n      values: () => [],\n    },\n  ];\n\n  if (enabledFilters) {\n    return suggestions.filter((x) => enabledFilters.includes(x.token));\n  }\n\n  return suggestions;\n}\n\ninterface RunsFilterInputProps {\n  loading?: boolean;\n  tokens: RunFilterToken[];\n  onChange: (tokens: RunFilterToken[]) => void;\n  enabledFilters?: RunFilterTokenType[];\n}\n\nexport const RunsFilterInput: React.FC<RunsFilterInputProps> = ({\n  loading,\n  tokens,\n  onChange,\n  enabledFilters,\n}) => {\n  const {options} = useRepositoryOptions();\n  const [selectedTagKey, setSelectedTagKey] = React.useState<string | undefined>();\n  const [fetchTagKeys, {data: tagKeyData}] = useLazyQuery<RunTagKeysQuery>(RUN_TAG_KEYS_QUERY);\n  const [fetchTagValues, {data: tagValueData}] = useLazyQuery<\n    RunTagValuesQuery,\n    RunTagValuesQueryVariables\n  >(RUN_TAG_VALUES_QUERY, {\n    variables: {tagKeys: selectedTagKey ? [selectedTagKey] : []},\n  });\n\n  React.useEffect(() => {\n    if (selectedTagKey) {\n      fetchTagValues();\n    }\n  }, [selectedTagKey, fetchTagValues]);\n\n  const suggestions = searchSuggestionsForRuns(\n    options,\n    tagKeyData?.runTagKeysOrError?.__typename === 'RunTagKeys'\n      ? tagKeyData.runTagKeysOrError.keys\n      : [],\n    selectedTagKey,\n    tagValueData?.runTagsOrError?.__typename === 'RunTags' ? tagValueData.runTagsOrError.tags : [],\n    enabledFilters,\n  );\n\n  const search = tokenizedValuesFromStringArray(tokensAsStringArray(tokens), suggestions);\n  const refreshSuggestions = (text: string) => {\n    if (!text.startsWith('tag:')) {\n      return;\n    }\n    const tagKeyText = text.slice(4);\n    if (\n      tagKeyData?.runTagKeysOrError?.__typename === 'RunTagKeys' &&\n      tagKeyData.runTagKeysOrError.keys.includes(tagKeyText)\n    ) {\n      setSelectedTagKey(tagKeyText);\n    }\n  };\n\n  const suggestionProvidersFilter = (\n    suggestionProviders: SuggestionProvider[],\n    values: TokenizingFieldValue[],\n  ) => {\n    const tokens: string[] = [];\n    for (const {token} of values) {\n      if (token) {\n        tokens.push(token);\n      }\n    }\n\n    // If id is set, then no other filters can be set\n    if (tokens.includes('id')) {\n      return [];\n    }\n\n    // Can only have one filter value for pipeline or id\n    const limitedTokens = new Set<string>(['id', 'job', 'pipeline', 'snapshotId']);\n    const presentLimitedTokens = tokens.filter((token) => limitedTokens.has(token));\n\n    return suggestionProviders.filter(\n      (provider) => !provider.token || !presentLimitedTokens.includes(provider.token),\n    );\n  };\n\n  const onFocus = React.useCallback(() => fetchTagKeys(), [fetchTagKeys]);\n\n  return (\n    <TokenizingField\n      values={search}\n      onChange={(values) => onChange(values as RunFilterToken[])}\n      onFocus={onFocus}\n      onTextChange={refreshSuggestions}\n      suggestionProviders={suggestions}\n      suggestionProvidersFilter={suggestionProvidersFilter}\n      loading={loading}\n    />\n  );\n};\n\nconst RUN_TAG_KEYS_QUERY = gql`\n  query RunTagKeysQuery {\n    runTagKeysOrError {\n      ... on RunTagKeys {\n        keys\n      }\n    }\n  }\n`;\n\nconst RUN_TAG_VALUES_QUERY = gql`\n  query RunTagValuesQuery($tagKeys: [String!]!) {\n    runTagsOrError(tagKeys: $tagKeys) {\n      __typename\n      ... on RunTags {\n        tags {\n          key\n          values\n        }\n      }\n    }\n  }\n`;\n","// eslint-disable-next-line no-restricted-imports\nimport {TagInput} from '@blueprintjs/core';\nimport * as React from 'react';\nimport styled from 'styled-components/macro';\n\nimport {Box} from './Box';\nimport {Colors} from './Colors';\nimport {MenuItem, Menu} from './Menu';\nimport {Popover} from './Popover';\nimport {Spinner} from './Spinner';\n\nconst MAX_SUGGESTIONS = 100;\n\nexport interface SuggestionProvider {\n  token?: string;\n  values: () => string[];\n  suggestionFilter?: (query: string, suggestion: Suggestion) => boolean;\n  textOnly?: boolean;\n}\n\nexport interface Suggestion {\n  text: string;\n  final: boolean;\n}\n\ninterface ActiveSuggestionInfo {\n  text: string;\n  idx: number;\n}\n\nexport interface TokenizingFieldValue {\n  token?: string;\n  value: string;\n}\n\ninterface TokenizingFieldProps {\n  values: TokenizingFieldValue[];\n  maxValues?: number;\n  onChange: (values: TokenizingFieldValue[]) => void;\n  onChangeBeforeCommit?: boolean;\n  addOnBlur?: boolean;\n  onFocus?: () => void;\n\n  placeholder?: string;\n  loading?: boolean;\n  className?: string;\n  small?: boolean;\n\n  fullwidth?: boolean;\n\n  onTextChange?: (text: string) => void;\n  suggestionProviders: SuggestionProvider[];\n  suggestionRenderer?: (suggestion: Suggestion) => React.ReactNode;\n  suggestionProvidersFilter?: (\n    suggestionProvider: SuggestionProvider[],\n    values: TokenizingFieldValue[],\n  ) => SuggestionProvider[];\n}\n\nfunction findProviderByToken(token: string, providers: SuggestionProvider[]) {\n  return providers.find((p) => p.token && p.token.toLowerCase() === token.toLowerCase());\n}\n\nexport const tokenizedValuesFromString = (str: string, providers: SuggestionProvider[]) => {\n  if (str === '') {\n    return [];\n  }\n  const tokens = str.split(',');\n  return tokenizedValuesFromStringArray(tokens, providers);\n};\n\nexport const tokenizedValuesFromStringArray = (tokens: string[], providers: SuggestionProvider[]) =>\n  tokens.map((token) => tokenizedValueFromString(token, providers));\n\nexport const tokenizeString = (str: string): [string, string] => {\n  const colonAt = str.indexOf(':');\n  if (colonAt === -1) {\n    return [str, ''];\n  }\n  return [str.slice(0, colonAt), str.slice(colonAt + 1)];\n};\n\nexport function tokenizedValueFromString(\n  str: string,\n  providers: SuggestionProvider[],\n): TokenizingFieldValue {\n  const [token, value] = tokenizeString(str);\n  if (findProviderByToken(token, providers)) {\n    if (token && value) {\n      return {token, value};\n    }\n  }\n\n  return {value: str};\n}\n\nexport const tokenToString = (v: TokenizingFieldValue) =>\n  v.token ? `${v.token}:${v.value}` : v.value;\n\nexport const tokensAsStringArray = (value: TokenizingFieldValue[]) =>\n  value.filter((v) => v.value !== '').map(tokenToString);\n\nexport const stringFromValue = (value: TokenizingFieldValue[]) =>\n  tokensAsStringArray(value).join(',');\n\nconst isEqual = (a: TokenizingFieldValue, b?: TokenizingFieldValue) =>\n  b && a.token === b.token && a.value === b.value;\n\n/** Provides a text field with typeahead autocompletion.\n *  This completion either provides a list of standalone tokens\n *  sourced from the `tokens` param, or a set of key value pairs,\n *  sourced from the `suggestionProviders` param. In the latter case, the\n *  key is one of a known set of \"suggestion provider tokens\".\n *\n *  Provide one or more SuggestionProviders or a list of tokens\n *  to build the tree of autocompletions.\n *\n *  The input also allows for freeform typing (`value` items with no token value) */\nexport const TokenizingField: React.FC<TokenizingFieldProps> = ({\n  suggestionProviders,\n  suggestionProvidersFilter,\n  values: externalValues,\n  maxValues,\n  onChange,\n  onChangeBeforeCommit,\n  onFocus,\n  onTextChange,\n  placeholder,\n  addOnBlur,\n  loading,\n  className,\n  fullwidth,\n  suggestionRenderer,\n}) => {\n  const [open, setOpen] = React.useState<boolean>(false);\n  const [active, setActive] = React.useState<ActiveSuggestionInfo | null>(null);\n  const [typed, setTyped] = React.useState<string>('');\n\n  const values = React.useMemo(() => [...externalValues], [externalValues]);\n  const typedValue = tokenizedValueFromString(typed, suggestionProviders);\n  if (isEqual(typedValue, values[values.length - 1])) {\n    values.pop();\n  }\n\n  const atMaxValues = maxValues !== undefined && values.length >= maxValues;\n\n  const filteredSuggestionProviders = suggestionProvidersFilter\n    ? suggestionProvidersFilter(suggestionProviders, values)\n    : suggestionProviders;\n\n  // Build the set of suggestions that should be displayed for the current input value.\n  // Note: \"typed\" is the text that has not yet been submitted, separate from values[].\n  const parts = typed.split(':');\n  const lastPart = (parts[parts.length - 1] || '').toLowerCase();\n\n  const suggestions = React.useMemo(() => {\n    if (atMaxValues) {\n      return [];\n    }\n\n    let suggestionsArr: Suggestion[] = [];\n\n    const matchesTypedText = (query: string, s: Suggestion) =>\n      !query ||\n      s.text\n        .toLowerCase()\n        .split(':')\n        .some((c) => c.includes(query));\n\n    const availableSuggestionsForProvider = (provider: SuggestionProvider) => {\n      const suggestionNotUsed = (v: string) =>\n        !values.some((e) => e.token === provider.token && e.value === v);\n\n      const suggestionFilter = provider.suggestionFilter || matchesTypedText;\n\n      return provider\n        .values()\n        .filter(suggestionNotUsed)\n        .map((v) => ({\n          text: provider?.token ? `${provider.token}:${v}` : v,\n          final: !provider.textOnly,\n        }))\n        .filter((s) => suggestionFilter(lastPart, s))\n        .slice(0, MAX_SUGGESTIONS); // never show too many suggestions for one provider\n    };\n\n    if (parts.length === 1) {\n      // Suggest providers (eg: `pipeline:`) so users can discover the search space\n\n      suggestionsArr = filteredSuggestionProviders\n        .reduce(\n          (accum: Suggestion[], s) =>\n            s.token ? [...accum, {text: `${s.token}:`, final: false}] : accum,\n          [],\n        )\n        .filter((s) => matchesTypedText(lastPart, s));\n\n      // Suggest value completions so users can type \"airline_\" without the \"pipeline\"\n      // prefix and get the correct suggestion.\n      for (const p of filteredSuggestionProviders) {\n        if (!p.token || typed.length > 0) {\n          suggestionsArr.push(...availableSuggestionsForProvider(p));\n        }\n      }\n    }\n\n    if (parts.length === 2) {\n      const firstPart = parts[0];\n      if (firstPart) {\n        // Suggest values from the chosen provider (eg: `pipeline:abc`)\n        const provider = findProviderByToken(firstPart, filteredSuggestionProviders);\n        suggestionsArr = provider ? availableSuggestionsForProvider(provider) : [];\n      }\n    }\n\n    // Truncate suggestions to the ones currently matching the typed text,\n    // and always sort them in alphabetical order.\n    suggestionsArr.sort((a, b) => a.text.localeCompare(b.text));\n\n    return suggestionsArr;\n  }, [atMaxValues, filteredSuggestionProviders, lastPart, parts, typed.length, values]);\n\n  const _onTextChange = (text: string) => {\n    setTyped(text);\n    onTextChange && onTextChange(text);\n  };\n\n  // We need to manage selection in the dropdown by ourselves. To ensure the\n  // best behavior we store the active item's index and text (the text allows\n  // us to relocate it if it's moved and the index allows us to keep selection\n  // at the same location if the previous item is gone.)\n\n  // This hook keeps the active row state in sync with the suggestions, which\n  // are derived from the current input value.\n\n  React.useEffect(() => {\n    // If suggestions are present, autoselect the first one so the user can press\n    // enter to complete their search. (Esc + enter is how you enter your raw text.)\n    if (!active && suggestions.length) {\n      const item = suggestions[0];\n      if (item) {\n        setActive({text: item.text, idx: 0});\n      }\n      return;\n    }\n    if (!active) {\n      return;\n    }\n    if (suggestions.length === 0) {\n      setActive(null);\n      return;\n    }\n\n    // Relocate the currently active item in the latest suggestions list\n    const pos = suggestions.findIndex((a) => a.text === active.text);\n\n    // The new index is the index of the active item, or whatever item\n    // is now at it's location if it's gone, bounded to the array.\n    let nextIdx = pos !== -1 ? pos : active.idx;\n    nextIdx = Math.max(0, Math.min(suggestions.length - 1, nextIdx));\n    const nextItem = suggestions[nextIdx];\n\n    if (nextItem && (nextIdx !== active.idx || nextItem.text !== active.text)) {\n      setActive({text: nextItem.text, idx: nextIdx});\n    }\n  }, [active, suggestions]);\n\n  const onConfirmSuggestion = (suggestion: Suggestion) => {\n    if (atMaxValues) {\n      return;\n    }\n\n    if (suggestion.final) {\n      // The user has finished a key-value pair\n      onConfirmText(suggestion.text);\n      _onTextChange('');\n      setActive(null);\n      setOpen(false);\n    } else {\n      // The user has finished a key\n      _onTextChange(suggestion.text);\n    }\n  };\n\n  const onConfirmText = (str: string) => {\n    if (atMaxValues) {\n      return;\n    }\n    if (str.endsWith(':')) {\n      return;\n    }\n    if (str === '') {\n      return;\n    }\n\n    _onTextChange('');\n    onChange([...values, tokenizedValueFromString(str, filteredSuggestionProviders)]);\n  };\n\n  const onKeyDown = (e: React.KeyboardEvent<any>) => {\n    if (atMaxValues && e.key !== 'Delete' && e.key !== 'Backspace') {\n      e.preventDefault();\n      e.stopPropagation();\n      return;\n    }\n    // Enter and Return confirm the currently selected suggestion or\n    // confirm the freeform text you've typed if no suggestions are shown.\n    if (e.key === 'Enter' || e.key === 'Return' || e.key === 'Tab') {\n      if (active) {\n        const picked = suggestions.find((s) => s.text === active.text);\n        if (!picked) {\n          throw new Error('Selection out of sync with suggestions');\n        }\n        onConfirmSuggestion(picked);\n        e.preventDefault();\n        e.stopPropagation();\n      } else if (typed.length) {\n        onConfirmText(typed);\n        e.preventDefault();\n        e.stopPropagation();\n      }\n      return;\n    }\n\n    // Typing space confirms your freeform text\n    if (e.key === ' ') {\n      e.preventDefault();\n      onConfirmText(typed);\n      return;\n    }\n\n    // Escape closes the options. The options re-open if you type another char or click.\n    if (e.key === 'Escape') {\n      setActive(null);\n      setOpen(false);\n      return;\n    }\n\n    if (!open && e.key !== 'Delete' && e.key !== 'Backspace') {\n      setOpen(true);\n    }\n\n    // The up/down arrow keys shift selection in the dropdown.\n    // Note: The first down arrow press activates the first item.\n    const shift = {ArrowDown: 1, ArrowUp: -1}[e.key];\n    if (shift && suggestions.length > 0) {\n      e.preventDefault();\n      let idx = (active ? active.idx : -1) + shift;\n      idx = Math.max(0, Math.min(idx, suggestions.length - 1));\n      const item = suggestions[idx];\n      if (item) {\n        setActive({text: item.text, idx});\n      }\n    }\n  };\n\n  const menuRef = React.createRef<HTMLDivElement>();\n  React.useEffect(() => {\n    if (menuRef.current && active) {\n      const el = menuRef.current.querySelector(`[data-idx='${active.idx}']`);\n      if (el && el instanceof HTMLElement && 'scrollIntoView' in el) {\n        el.scrollIntoView({block: 'nearest'});\n      }\n    }\n  }, [menuRef, active]);\n\n  const renderSuggestion = suggestionRenderer || ((suggestion) => suggestion.text);\n\n  return (\n    <Popover\n      isOpen={open && suggestions.length > 0 && !atMaxValues}\n      position=\"bottom-left\"\n      content={\n        suggestions.length > 0 ? (\n          <div style={{maxHeight: 235, overflowY: 'scroll'}} ref={menuRef}>\n            <StyledMenu>\n              {suggestions.map((suggestion, idx) => (\n                <MenuItem\n                  data-idx={idx}\n                  key={suggestion.text}\n                  text={renderSuggestion(suggestion)}\n                  shouldDismissPopover={false}\n                  active={active?.idx === idx}\n                  onMouseDown={(e: React.MouseEvent<any>) => {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    onConfirmSuggestion(suggestion);\n                    setActive(null);\n                  }}\n                />\n              ))}\n            </StyledMenu>\n          </div>\n        ) : (\n          <div />\n        )\n      }\n    >\n      <StyledTagInput\n        className={className}\n        values={values.map((v) => (v.token ? `${v.token}:${v.value}` : v.value))}\n        inputValue={typed}\n        onRemove={(_, idx) => {\n          const next = [...values];\n          next.splice(idx, 1);\n          onChange(next);\n        }}\n        onInputChange={(e) => {\n          _onTextChange(e.currentTarget.value);\n\n          if (onChangeBeforeCommit) {\n            const tokenized = tokenizedValueFromString(\n              e.currentTarget.value,\n              filteredSuggestionProviders,\n            );\n            onChange([...values, tokenized]);\n          }\n        }}\n        inputProps={{\n          onFocus: () => {\n            setOpen(true);\n            onFocus && onFocus();\n          },\n          onBlur: () => {\n            // Emulate behavior of addOnBlur for TagInput\n            // When a user clicks outside of the input, finish the current token\n            if (addOnBlur) {\n              onConfirmText(typed);\n            }\n            setOpen(false);\n          },\n        }}\n        $maxWidth={fullwidth ? '100%' : undefined}\n        onAdd={() => false}\n        onKeyDown={onKeyDown}\n        tagProps={{minimal: true}}\n        placeholder={placeholder || 'Filterâ€¦'}\n        rightElement={\n          loading && open ? (\n            <Box style={{alignSelf: 'center'}} margin={{right: 4}}>\n              <Spinner purpose=\"body-text\" />\n            </Box>\n          ) : undefined\n        }\n      />\n    </Popover>\n  );\n};\n\nexport const StyledTagInput = styled(TagInput)<{$maxWidth?: any}>`\n  border: none;\n  border-radius: 8px;\n  box-shadow: ${Colors.Gray300} inset 0px 0px 0px 1px, ${Colors.KeylineGray} inset 2px 2px 1.5px;\n  min-width: 400px;\n  max-width: ${(p) => (p.$maxWidth ? p.$maxWidth : '600px')};\n  transition: box-shadow 150ms;\n\n  &.bp4-active {\n    box-shadow: ${Colors.Gray300} inset 0px 0px 0px 1px, ${Colors.KeylineGray} inset 2px 2px 1.5px,\n      rgba(58, 151, 212, 0.6) 0 0 0 3px;\n  }\n\n  input {\n    font-size: 14px;\n    font-weight: 400;\n    padding-left: 4px;\n    padding-bottom: 2px;\n    padding-top: 2px;\n  }\n\n  && .bp4-tag-input-values:first-child .bp4-input-ghost:first-child {\n    padding-left: 8px;\n  }\n\n  && .bp4-tag-input-values {\n    margin-right: 4px;\n    margin-top: 4px;\n  }\n\n  && .bp4-tag-input-values > * {\n    margin-bottom: 4px;\n  }\n\n  .bp4-tag {\n    border-radius: 6px;\n    display: inline-flex;\n    flex-direction: row;\n    font-size: 12px;\n    line-height: 16px;\n    align-items: center;\n    max-width: 400px;\n    overflow: hidden;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    padding: 4px 8px;\n    user-select: none;\n  }\n\n  .bp4-tag.bp4-minimal:not([class*='bp4-intent-']) {\n    background-color: ${Colors.Gray100};\n    color: ${Colors.Gray900};\n  }\n\n  .bp4-tag.bp4-minimal.bp4-intent-success {\n    background-color: ${Colors.Green50};\n    color: ${Colors.Green700};\n  }\n\n  .bp4-tag.bp4-minimal.bp4-intent-warning {\n    background-color: ${Colors.Yellow50};\n    color: ${Colors.Yellow700};\n  }\n\n  .bp4-tag.bp4-minimal.bp4-intent-danger {\n    background-color: ${Colors.Red50};\n    color: ${Colors.Red700};\n  }\n`;\n\nconst StyledMenu = styled(Menu)`\n  width: 400px;\n`;\n"],"names":["useCopyToClipboard","clipboardAPI","navigator","clipboard","node","React","current","document","createElement","style","position","top","body","appendChild","removeChild","text","writeText","value","select","execCommand","priorityTagSet","Set","DagsterTag","renamedTags","RunTags","tags","onAddTag","mode","copy","copyAction","label","onClick","tag","key","SharedToaster","intent","message","addToFilterAction","token","actionsForTag","list","push","filter","item","displayedTags","priority","others","copiedTags","map","hasOwnProperty","startsWith","__ASSET_JOB_PREFIX","has","length","flex","direction","wrap","gap","idx","actions","RUN_PROVIDERS_EMPTY","values","useQueryPersistedRunFilters","enabledFilters","useQueryPersistedState","encode","tokens","q","tokensAsStringArray","cursor","undefined","decode","tokenizedValuesFromStringArray","t","includes","runsPathWithFilters","filterTokens","qs","arrayFormat","runsFilterForSearchTokens","search","obj","pipelineName","runIds","statuses","snapshotId","split","RunsFilterInput","loading","onChange","options","useRepositoryOptions","selectedTagKey","setSelectedTagKey","useLazyQuery","RUN_TAG_KEYS_QUERY","fetchTagKeys","tagKeyData","data","RUN_TAG_VALUES_QUERY","variables","tagKeys","fetchTagValues","tagValueData","suggestions","repositoryOptions","runTagKeys","selectedRunTagKey","runTagValues","pipelineNames","jobNames","repository","pipelines","pipeline","isJob","add","name","Object","keys","RunStatus","Array","from","flat","textOnly","x","searchSuggestionsForRuns","runTagKeysOrError","__typename","runTagsOrError","onFocus","onTextChange","tagKeyText","slice","suggestionProviders","suggestionProvidersFilter","limitedTokens","presentLimitedTokens","provider","gql","findProviderByToken","providers","find","p","toLowerCase","tokenizedValuesFromString","str","tokenizedValueFromString","colonAt","indexOf","tokenizeString","tokenToString","v","stringFromValue","join","TokenizingField","a","b","externalValues","maxValues","onChangeBeforeCommit","placeholder","addOnBlur","className","fullwidth","suggestionRenderer","open","setOpen","active","setActive","typed","setTyped","typedValue","pop","atMaxValues","filteredSuggestionProviders","parts","lastPart","suggestionsArr","matchesTypedText","query","s","some","c","availableSuggestionsForProvider","suggestionFilter","e","final","reduce","accum","firstPart","sort","localeCompare","_onTextChange","pos","findIndex","nextIdx","Math","max","min","nextItem","onConfirmSuggestion","suggestion","onConfirmText","endsWith","menuRef","el","querySelector","HTMLElement","scrollIntoView","block","renderSuggestion","isOpen","content","maxHeight","overflowY","ref","StyledMenu","shouldDismissPopover","onMouseDown","preventDefault","stopPropagation","StyledTagInput","inputValue","onRemove","_","next","splice","onInputChange","currentTarget","tokenized","inputProps","onBlur","$maxWidth","onAdd","onKeyDown","shift","ArrowDown","ArrowUp","picked","Error","tagProps","minimal","rightElement","alignSelf","margin","right","purpose","styled","TagInput","Colors","Menu"],"sourceRoot":""}