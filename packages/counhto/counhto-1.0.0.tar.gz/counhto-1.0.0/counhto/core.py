import logging
import scipy

import pysam as ps
import multiprocessing as mp

import scipy.sparse

from .utils import (
    count_dict_to_csr_matrix,
    subset_called_cells,
    check_input_lengths
)
from .io import (
    read_hto_file,
    read_called_barcodes,
    write_counts
)

from collections import defaultdict


def count_capture_per_cell_barcode(
        path_to_bamfile: str,
        htos: list[tuple[str]]
) -> tuple[scipy.sparse.csr_matrix, list[str], list[str]]:
    """
    parses a bamfile generated by cellranger and counts UMIs per HTO for each cell barcode
    assumes cepture library reads are unaligned reads in the given bamfile

    :param path_to_bamfile:     path to possorted_bam.bam as generated by cellranger
    :param htos:                list of key, value tuples where key is the HTO sequence and value is the HTO name

    :return:                    sparse count matrix,
                                cell barcodes corresponding to rows in counts,
                                HTO names corresponding to columns in counts
    """
    log_msg = f'processing bam_file for HTO counts: {path_to_bamfile}'
    logging.info(f'start {log_msg}')

    bam = ps.AlignmentFile(path_to_bamfile, 'rb')
    feature_umis_per_cell_barcode: dict[str, dict[str, set]] = defaultdict(lambda: defaultdict(set))
    for capture_read in bam.fetch('*'):
        barcodes = {}
        for tag, alternative_tag, tag_label in zip(
                ['CB', 'fb', 'UB'],
                ['CR', 'fr', 'UR'],
                ['cell', 'feature', 'umi']
        ):
            corrected = capture_read.has_tag(tag)
            tag_to_fetch = tag if corrected else alternative_tag

            if not capture_read.has_tag(tag_to_fetch):
                continue

            barcode = capture_read.get_tag(tag_to_fetch)

            if tag_label == 'CB' and not corrected:
                barcode = barcode + '-1'

            barcodes[tag_label] = barcode

        if 'feature' not in barcodes:
            continue

        feature_umis_per_cell_barcode[barcodes['cell']][barcodes['feature']].add(barcodes['umi'])

    bam.close()

    count_matrix, cell_barcodes, feature_names = count_dict_to_csr_matrix(
        feature_umis_per_cell_barcode,
        htos
    )

    logging.info(f'done {log_msg}')

    return count_matrix, cell_barcodes, feature_names


def make_hto_count_matrix(path_dict: dict[str, str]) -> None:
    """
    takes a dictionary containing paths to bam file, hto file, the filtered barcodes file and
    an output directory and generates an HTO count matrix per filtered cell barcode. The results
    are then written to the output directory

    :param path_dict:   dictionary with keys: 'bam_file', 'hto_file', 'barcode_file', output_directory
                        containing the path bam file, hto file, filtered barcode file and output directory respectively
    :return:            None
    """
    path_to_bam_file = path_dict['bam_file']
    path_to_hto_file = path_dict['hto_file']
    path_to_called_barcodes_file = path_dict['barcode_file']
    output_path_prefix = path_dict['output_directory']

    htos = read_hto_file(path_to_hto_file)
    counts, barcodes, features = count_capture_per_cell_barcode(
        path_to_bam_file,
        htos
    )

    compressed = True if path_to_called_barcodes_file.endswith('gz') else False
    called_barcodes = read_called_barcodes(
        path_to_called_barcodes_file,
        compressed=compressed
    )
    subset_counts, subset_barcodes = subset_called_cells(
        counts,
        barcodes,
        called_barcodes
    )
    write_counts(
        subset_counts,
        subset_barcodes,
        features,
        output_path_prefix
    )


def run_hto_counting(
        bam_files,
        hto_files,
        barcode_files,
        output_directories,
        n_processes=1
):
    """
    runs the algorithm for each sample in the input lists. all lists must have the same length

    :param bam_files:           list of bam files to process
    :param hto_files:           list of hto files corresponding to bam files
    :param barcode_files:       list of filtered barcode files corresponding to bam files
    :param output_directories:  list of output directories corresponding to bam files
    :param n_processes:

    :return:                    None
    """
    iterable = [
        {'bam_file': bam_file, 'hto_file': hto_file, 'barcode_file': barcode_file, 'output_directory': output_directory}
        for bam_file, hto_file, barcode_file, output_directory in
        zip(bam_files, hto_files, barcode_files, output_directories)
    ]
    if n_processes > 1:
        p = mp.Pool(n_processes)
        _map = p.map

    else:
        _map = lambda func, iterable: list(map(func, iterable))  # necessary to invoke map

    _map(make_hto_count_matrix, iterable)

    if n_processes > 1:
        p.close()
