<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fitk.fisher_matrix API documentation</title>
<meta name="description" content="Package for performing operations on Fisher objects.
See here for documentation of `FisherMatrix`." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fitk.fisher_matrix</code></h1>
</header>
<section id="section-intro">
<p>Package for performing operations on Fisher objects.
See here for documentation of <code><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Package for performing operations on Fisher objects.
See here for documentation of `FisherMatrix`.
&#34;&#34;&#34;

# needed for compatibility with Python 3.7
from __future__ import annotations

# standard library imports
from collections import abc
import copy
from itertools import \
    permutations, \
    product
import json
from numbers import Number
import os
from typing import \
    Mapping, \
    Collection, \
    Optional, \
    Union, \
    Tuple

# third party imports
import numpy as np
from scipy.special import erfinv # pylint: disable=no-name-in-module
import matplotlib.pyplot as plt
from matplotlib.patheffects import Stroke, Normal
from matplotlib import colors

# first party imports
from fitk.fisher_utils import \
    float_to_latex, \
    ParameterNotFoundError, \
    MismatchingSizeError, \
    make_default_names, \
    is_square, \
    is_symmetric, \
    is_positive_semidefinite, \
    get_index_of_other_array, \
    reindex_array, \
    get_default_rcparams, \
    jsonify



def _process_fisher_mapping(value : abc.Mapping):
    &#34;&#34;&#34;
    Processes a mapping/dict and returns the sanitized output.
    &#34;&#34;&#34;
    if &#39;name&#39; not in value:
        raise ValueError(
            &#39;The mapping/dict must contain at least the key `name`&#39;
        )

    name = value[&#39;name&#39;]
    latex_name = value.get(&#39;latex_name&#39;, name)
    fiducial = value.get(&#39;fiducial&#39;, 0)

    return dict(
        name=name,
        latex_name=latex_name,
        fiducial=fiducial,
    )



class FisherMatrix:
    r&#34;&#34;&#34;
    Class for handling Fisher objects.

    Examples
    --------
    Specify a Fisher object with default names and fiducials:
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]))

    The object has a friendly representation in the interactive session:
    &gt;&gt;&gt; fm
    FisherMatrix(array([[5., 0.],
           [0., 4.]]), names=array([&#39;p1&#39;, &#39;p2&#39;], dtype=object), latex_names=array([&#39;p1&#39;, &#39;p2&#39;], dtype=object), fiducial=array([0., 0.]))

    The string representation is probably more readable:
    &gt;&gt;&gt; print(fm)
    FisherMatrix([[5. 0.]
     [0. 4.]], names=[&#39;p1&#39; &#39;p2&#39;], latex_names=[&#39;p1&#39; &#39;p2&#39;], fiducial=[0. 0.])

    List the names:
    &gt;&gt;&gt; fm.names
    array([&#39;p1&#39;, &#39;p2&#39;], dtype=object)

    List the values of the Fisher object:
    &gt;&gt;&gt; fm.values
    array([[5., 0.],
           [0., 4.]])

    List the values of the fiducials:
    &gt;&gt;&gt; fm.fiducial
    array([0., 0.])

    Names can be changed in bulk (ditto for fiducial and values; dimension must of course match the original):
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]))
    &gt;&gt;&gt; fm.names = [&#39;x&#39;, &#39;y&#39;]
    &gt;&gt;&gt; fm.latex_names = [r&#39;$\mathbf{X}$&#39;, r&#39;$\mathbf{Y}$&#39;]
    &gt;&gt;&gt; fm
    FisherMatrix(array([[5., 0.],
           [0., 4.]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0., 0.]))

    We can get and set individual elements of the matrix using dict-like notation:
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]), names=[&#39;x&#39;, &#39;y&#39;])
    &gt;&gt;&gt; fm[&#39;x&#39;, &#39;x&#39;]
    5.0

    The off-diagonal elements are automatically updated when using the setter:
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]), names=[&#39;x&#39;, &#39;y&#39;])
    &gt;&gt;&gt; fm[&#39;x&#39;, &#39;y&#39;] = -2
    &gt;&gt;&gt; fm
    FisherMatrix(array([[ 5., -2.],
           [-2.,  4.]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), fiducial=array([0., 0.]))

    We can select submatrices by index:
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 3]), names=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])
    &gt;&gt;&gt; fm[1:]
    FisherMatrix(array([[2., 0.],
           [0., 3.]]), names=array([&#39;y&#39;, &#39;z&#39;], dtype=object), latex_names=array([&#39;y&#39;, &#39;z&#39;], dtype=object), fiducial=array([0., 0.]))

    Fisher object with parameter names:
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]), names=[&#39;x&#39;, &#39;y&#39;], latex_names=[&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;])
    &gt;&gt;&gt; fm_with_names = FisherMatrix(np.diag([1, 2]), names=[&#39;x&#39;, &#39;y&#39;])

    We can add Fisher objects (ordering of names is taken care of):
    &gt;&gt;&gt; fm + fm_with_names # doctest: +SKIP
    FisherMatrix(array([[6., 0.],
           [0., 6.]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0., 0.]))

    We can also do element-wise multiplication or division:
    &gt;&gt;&gt; fm * fm_with_names
    FisherMatrix(array([[5., 0.],
           [0., 8.]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0., 0.]))

    Furthermore, we can do matrix multiplication:
    &gt;&gt;&gt; fm @ fm_with_names
    FisherMatrix(array([[5., 0.],
           [0., 8.]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0., 0.]))

    We can also perform standard matrix operations like the trace, eigenvalues, determinant:
    &gt;&gt;&gt; fm.trace()
    9.0
    &gt;&gt;&gt; fm.eigenvalues()
    array([4., 5.])
    &gt;&gt;&gt; fm.determinant()
    19.999999999999996

    We can also take the matrix inverse:
    &gt;&gt;&gt; fm.inverse()
    FisherMatrix(array([[0.2 , 0.  ],
           [0.  , 0.25]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0., 0.]))

    We can drop parameters from the object:
    &gt;&gt;&gt; fm.drop(&#39;x&#39;)
    FisherMatrix(array([[4.]]), names=array([&#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0.]))

    We can save it to a file (the returned value is the dictionary that was saved):
    &gt;&gt;&gt; fm.to_file(&#39;example_matrix.json&#39;, overwrite=True)
    {&#39;values&#39;: [[5.0, 0.0], [0.0, 4.0]], &#39;names&#39;: [&#39;x&#39;, &#39;y&#39;], &#39;latex_names&#39;: [&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], &#39;fiducial&#39;: [0.0, 0.0]}

    Loading is performed by a class method `from_file`:
    &gt;&gt;&gt; fm_new = FisherMatrix.from_file(&#39;example_matrix.json&#39;)
    &#34;&#34;&#34;

    def __init__(
        self,
        values : Collection,
        names : Optional[Collection[str]] = None,
        latex_names : Optional[str] = None,
        fiducial : Optional[Collection[float]] = None,
    ):
        r&#34;&#34;&#34;
        Constructor for Fisher object.

        Parameters
        ----------
        values : array-like
            The values of the Fisher object.

        names : array-like iterable of `str`, default = None
            The names of the parameters.
            If not specified, defaults to `p1, ..., pn`.

        latex_names : array-like iterable of `str`, default = None
            The LaTeX names of the parameters.
            If not specified, defaults to `names`.

        fiducial : array-like iterable of `float`, default = None
            The fiducial values of the parameters. If not specified, default to
            0 for all parameters.

        metadata : Optional[dict], default = None
            any metadata associated with the Fisher object

        Raises
        ------
        * `ValueError` if the input array has the wrong dimensionality (not 2)
        * `ValueError` if the object is not square-like
        * `MismatchingSizeError` if the sizes of the array of names, values, LaTeX names and fiducials do not match

        Examples
        --------
        Specify a Fisher object without names:
        &gt;&gt;&gt; FisherMatrix(np.diag([1, 2, 3]))
        FisherMatrix(array([[1., 0., 0.],
               [0., 2., 0.],
               [0., 0., 3.]]), names=array([&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;], dtype=object), latex_names=array([&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;], dtype=object), fiducial=array([0., 0., 0.]))

        Specify a Fisher object with names, LaTeX names, and fiducials:
        &gt;&gt;&gt; FisherMatrix(np.diag([1, 2]), names=[&#39;alpha&#39;, &#39;beta&#39;],
        ... latex_names=[r&#39;$\alpha$&#39;, r&#39;$\beta$&#39;], fiducial=[-3, 2])
        FisherMatrix(array([[1., 0.],
               [0., 2.]]), names=array([&#39;alpha&#39;, &#39;beta&#39;], dtype=object), latex_names=array([&#39;$\\alpha$&#39;, &#39;$\\beta$&#39;], dtype=object), fiducial=array([-3.,  2.]))
        &#34;&#34;&#34;

        if np.ndim(values) != 2:
            raise ValueError(
                f&#39;The object {values} is not 2-dimensional&#39;
            )

        if not is_square(values):
            raise ValueError(
                f&#39;The object {values} is not square-like&#39;
            )

        # try to treat it as an array-like object
        self._values = np.array(values, dtype=float)

        self._size = np.shape(self._values)[0]
        self._ndim = np.ndim(self._values)

        # setting the fiducial
        if fiducial is None:
            self._fiducial = np.zeros(self._size, dtype=float)
        else:
            self._fiducial = np.array(fiducial, dtype=float)

        # setting the names
        if names is None:
            self._names = make_default_names(self._size)
        else:
            # check they&#39;re unique
            if len(set(names)) != len(names):
                raise MismatchingSizeError(set(names), names)

            self._names = np.array(names, dtype=object)

        # setting the pretty names (LaTeX)
        if latex_names is None:
            self._latex_names = copy.deepcopy(self._names)
        else:
            self._latex_names = np.array(latex_names, dtype=object)

        # check sizes of inputs
        if not all(
            len(_) == self._size \
            for _ in (self._names, self._fiducial, self._latex_names)
        ):
            raise MismatchingSizeError(
                self._values[0],
                self._names,
                self._fiducial,
                self._latex_names,
            )


    def rename(
        self,
        names : Mapping[str, Union[str, abc.Mapping]],
        ignore_errors : bool = False,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns a Fisher object with new names.

        Parameters
        ----------
        names : Mapping[str, Union[str, abc.Mapping]]
            a mapping (dictionary-like object) between the old names and the
            new ones. The values it maps to can either be a string (the new name), or a dict
            with keys `name`, `latex_name`, and `fiducial` (only `name` is mandatory).

        ignore_errors : bool, default = False
            if set to True, will not raise an error if a parameter doesn&#39;t exist

        Returns
        -------
        Instance of `FisherMatrix`.

        Examples
        --------
        &gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
        &gt;&gt;&gt; m.rename({&#39;p1&#39; : &#39;a&#39;, &#39;p2&#39; : dict(name=&#39;b&#39;, latex_name=&#39;$b$&#39;, fiducial=2)})
        FisherMatrix(array([[1., 0., 0.],
               [0., 2., 0.],
               [0., 0., 3.]]), names=array([&#39;a&#39;, &#39;b&#39;, &#39;p3&#39;], dtype=object), latex_names=array([&#39;a&#39;, &#39;$b$&#39;, &#39;p3&#39;], dtype=object), fiducial=array([0., 2., 0.]))
        &#34;&#34;&#34;
        # check uniqueness and size
        if len(set(names)) != len(names):
            raise MismatchingSizeError(set(names), names)

        if not ignore_errors:
            for name in names:
                if name not in self.names:
                    raise ParameterNotFoundError(name, self.names)

        names_new = copy.deepcopy(self.names)
        latex_names_new = copy.deepcopy(self.latex_names)
        fiducial_new = copy.deepcopy(self.fiducial)

        for name, value in names.items():
            index = np.where(names_new == name)
            # it&#39;s a mapping
            if isinstance(value, abc.Mapping):
                value = _process_fisher_mapping(value)
                latex_names_new[index] = value[&#39;latex_name&#39;]
                fiducial_new[index] = value[&#39;fiducial&#39;]
                names_new[index] = value[&#39;name&#39;]
            # otherwise, it&#39;s a string
            else:
                names_new[index] = value
                latex_names_new[index] = value

        return self.__class__(
            self.values,
            names=names_new,
            latex_names=latex_names_new,
            fiducial=fiducial_new,
        )


    def _repr_html_(self):
        &#34;&#34;&#34;
        Representation of the Fisher object suitable for viewing in Jupyter
        notebook environments.
        &#34;&#34;&#34;
        header_matrix = &#39;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&#39; + (
            &#39;&lt;th&gt;{}&lt;/th&gt;&#39; * len(self)
        ).format(*self.latex_names) + &#39;&lt;/tr&gt;&lt;/thead&gt;&#39;

        body_matrix = &#39;&lt;tbody&gt;&#39;
        for index, name in enumerate(self.latex_names):
            body_matrix += f&#39;&lt;tr&gt;&lt;th&gt;{name}&lt;/th&gt;&#39; + (
                &#39;&lt;td&gt;{:.3f}&lt;/td&gt;&#39; * len(self)
            ).format(*(self.values[:, index])) + &#39;&lt;/tr&gt;&#39;
        body_matrix += &#39;&lt;/tbody&gt;&#39;

        html_matrix = f&#39;&lt;table&gt;{header_matrix}{body_matrix}&lt;/table&gt;&#39;

        return html_matrix


    def __repr__(self):
        &#34;&#34;&#34;
        Representation of the Fisher object for non-Jupyter interfaces.
        &#34;&#34;&#34;
        return &#39;FisherMatrix(&#39; \
            f&#39;{repr(self.values)}, &#39; \
            f&#39;names={repr(self.names)}, &#39; \
            f&#39;latex_names={repr(self.latex_names)}, &#39; \
            f&#39;fiducial={repr(self.fiducial)})&#39;


    def __str__(self):
        &#34;&#34;&#34;
        String representation of the Fisher object.
        &#34;&#34;&#34;
        return &#39;FisherMatrix(&#39; \
            f&#39;{self.values}, &#39; \
            f&#39;names={self.names}, &#39; \
            f&#39;latex_names={self.latex_names}, &#39; \
            f&#39;fiducial={self.fiducial})&#39;



    def __getitem__(
        self,
        keys : Union[Tuple[str], slice],
    ):
        &#34;&#34;&#34;
        Implements access to elements in the Fisher object.
        Has support for slicing.
        &#34;&#34;&#34;
        # the object can be sliced
        if isinstance(keys, slice):
            start, stop, step = keys.indices(len(self))
            indices = (slice(start, stop, step),) * self.ndim
            sl = slice(start, stop, step)
            values = self.values[indices]
            names = self.names[sl]
            latex_names = self.latex_names[sl]
            fiducial = self.fiducial[sl]

            return self.__class__(
                values,
                names=names,
                latex_names=latex_names,
                fiducial=fiducial,
            )

        try:
            _ = iter(keys)
        except TypeError as err:
            raise TypeError(err) from err

        # the keys can be a tuple
        if isinstance(keys, tuple):
            if len(keys) != self.ndim:
                raise ValueError(
                    f&#39;Expected {self.ndim} arguments, got {len(keys)}&#39;
                )

            # error checking
            for key in keys:
                if key not in self.names:
                    raise ParameterNotFoundError(key, self.names)

            indices = tuple(np.where(self.names == key) for key in keys)

        # otherwise, it&#39;s some generic object
        else:
            if keys not in self.names:
                raise ParameterNotFoundError(keys, self.names)

            indices = (np.where(self.names == keys),)

        return self._values[indices][0, 0]


    def __setitem__(
        self,
        keys : Tuple[str],
        value : float,
    ):
        &#34;&#34;&#34;
        Implements setting of elements in the Fisher object.
        Does not support slicing.
        &#34;&#34;&#34;
        try:
            _ = iter(keys)
        except TypeError as err:
            raise err

        if len(keys) != self.ndim:
            raise ValueError(f&#39;Got length {len(keys)}&#39;)

        # automatically raises a value error
        indices = tuple(np.where(self.names == key) for key in keys)

        temp_data = copy.deepcopy(self._values)

        if not all(index == indices[0] for index in indices):
            for permutation in list(permutations(indices)):
                # update all symmetric parts
                temp_data[permutation] = value
        else:
            temp_data[indices] = value

        self._values = copy.deepcopy(temp_data)


    def is_valid(self):
        &#34;&#34;&#34;
        Checks whether the values make a valid Fisher object.
        A (square) matrix is a Fisher matrix if it satisifies the following two
        criteria:

        * it is symmetric
        * it is positive semi-definite

        Returns
        -------
        `True` or `False`

        Examples
        --------
        &gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
        &gt;&gt;&gt; m.is_valid()
        True
        &gt;&gt;&gt; FisherMatrix(np.diag([-1, 3])).is_valid()
        False
        &#34;&#34;&#34;
        return \
            is_symmetric(self.values) and \
            is_positive_semidefinite(self.values)


    def imshow(
        self,
        colorbar : bool = False,
        show_values : bool = False,
        normalized : bool = False,
        colorbar_space : float = 0.02,
        colorbar_width : float = 0.05,
        colorbar_orientation : str = &#39;vertical&#39;,
        rc : abc.Mapping = get_default_rcparams(),
        **kwargs,
    ):
        &#34;&#34;&#34;
        Returns the image of the Fisher object.
        &#34;&#34;&#34;
        # TODO should only work with 2D data.
        with plt.rc_context(rc):
            fig, ax = plt.subplots(figsize=(len(self), len(self)))
            img = ax.imshow(
                self.values,
                interpolation=&#39;none&#39;,
                norm=colors.CenteredNorm(),
                **kwargs,
            )

            ax.set_xticks(np.arange(len(self)))
            ax.set_yticks(np.arange(len(self)))
            ax.set_xticklabels(self.latex_names)
            ax.set_yticklabels(self.latex_names)

            if colorbar:
                allowed_orientations = (&#39;vertical&#39;, &#39;horizontal&#39;)
                if colorbar_orientation not in allowed_orientations:
                    raise ValueError(
                        f&#39;\&#39;{colorbar_orientation}\&#39; is not one of: {allowed_orientations}&#39;
                    )

                if colorbar_orientation == &#39;vertical&#39;:
                    cax = fig.add_axes(
                        [ax.get_position().x1 + colorbar_space,
                        ax.get_position().y0 * 0.997,
                        colorbar_width,
                        ax.get_position().height]
                    )
                    fig.colorbar(img, cax=cax, orientation=colorbar_orientation)
                    cax.set_yticklabels(
                        [f&#39;${float_to_latex(_)}$&#39; for _ in cax.get_yticks()]
                    )
                else:
                    cax = fig.add_axes(
                        [ax.get_position().x0,
                        ax.get_position().y1 + colorbar_space,
                        ax.get_position().width,
                        colorbar_width]
                    )
                    fig.colorbar(img, cax=cax, orientation=colorbar_orientation)
                    cax.xaxis.set_ticks_position(&#39;top&#39;)
                    cax.set_xticklabels(
                        [f&#39;${float_to_latex(_)}$&#39; for _ in cax.get_xticks()]
                    )

            # whether or not we want to display the actual values inside the
            # matrix
            if show_values:
                mid_coords = np.arange(len(self))
                for index1, index2 in product(range(len(self)), range(len(self))):
                    x = mid_coords[index1]
                    y = mid_coords[index2]
                    value = self.values[index1, index2] / \
                        np.sqrt(
                            self.values[index1, index1] \
                           *self.values[index2, index2]
                        ) if normalized \
                        else self.values[index1, index2]
                    text = ax.text(
                            x, y, f&#39;${float_to_latex(value)}$&#39;,
                            ha=&#39;center&#39;, va=&#39;center&#39;, color=&#39;white&#39;,
                    )
                    text.set_path_effects(
                        [Stroke(linewidth=1, foreground=&#34;black&#34;), Normal()]
                    )

        return fig


    def sort(
        self,
        **kwargs,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Sorts the Fisher object by name according to some criterion.

        Parameters
        ----------
        **kwargs
            all of the other keyword arguments for the Python builtin `sorted`.
            If none are specified, will sort according to the names of the parameters.
            In the special case that the value of the keyword `key` is set to
            either &#39;fiducial&#39; or &#39;latex_names&#39;, it will sort according to those.
            In the second special case that the value of the keyword `key` is
            set to an array of integers of equal size as the Fisher object, sorts them
            according to those instead.

        Returns
        -------
        Instance of `FisherMatrix`.

        Examples
        --------
        &gt;&gt;&gt; m = FisherMatrix(np.diag([3, 1, 2]), names=list(&#39;sdf&#39;),
        ... latex_names=[&#39;hjkl&#39;, &#39;qwe&#39;, &#39;ll&#39;], fiducial=[8, 7, 3])
        &gt;&gt;&gt; m.sort(key=&#39;fiducial&#39;)
        FisherMatrix(array([[2., 0., 0.],
               [0., 1., 0.],
               [0., 0., 3.]]), names=array([&#39;f&#39;, &#39;d&#39;, &#39;s&#39;], dtype=object), latex_names=array([&#39;ll&#39;, &#39;qwe&#39;, &#39;hjkl&#39;], dtype=object), fiducial=array([3., 7., 8.]))
        &gt;&gt;&gt; m.sort(key=&#39;latex_names&#39;)
        FisherMatrix(array([[3., 0., 0.],
               [0., 2., 0.],
               [0., 0., 1.]]), names=array([&#39;s&#39;, &#39;f&#39;, &#39;d&#39;], dtype=object), latex_names=array([&#39;hjkl&#39;, &#39;ll&#39;, &#39;qwe&#39;], dtype=object), fiducial=array([8., 3., 7.]))
        &#34;&#34;&#34;
        allowed_keys = (&#39;fiducial&#39;, &#39;latex_names&#39;)
        # an integer index
        if &#39;key&#39; in kwargs and all(hasattr(_, &#39;__index__&#39;) for _ in kwargs[&#39;key&#39;]):
            index = np.array(kwargs[&#39;key&#39;], dtype=int)
            names = self.names[index]
        # either &#39;fiducial&#39; or &#39;latex_names&#39;
        elif &#39;key&#39; in kwargs and kwargs[&#39;key&#39;] in allowed_keys:
            index = np.argsort(getattr(self, kwargs[&#39;key&#39;]))
            if &#39;reversed&#39; in kwargs and kwargs[&#39;reversed&#39;] is True:
                index = np.flip(index)
            names = self.names[index]
        # something that can be passed to `sorted`
        else:
            names = sorted(self.names, **kwargs)
            index = get_index_of_other_array(self.names, names)

        latex_names = self.latex_names[index]
        fiducial = self.fiducial[index]
        values = reindex_array(self.values, index)

        return self.__class__(
            values,
            names=names,
            latex_names=latex_names,
            fiducial=fiducial,
        )


    def __eq__(self, other):
        &#34;&#34;&#34;
        The equality operator.
        Returns `True` if the operands have the following properties:

        * are instances of FisherMatrix
        * have same names (potentially shuffled)
        * have same dimensionality
        * have same fiducials (potentially shuffled)
        * have same values (potentially shuffled)
        &#34;&#34;&#34;
        if set(self.names) != set(other.names):
            return False

        # index for re-shuffling parameters
        index = get_index_of_other_array(self.names, other.names)

        return isinstance(other, self.__class__) \
        and self.ndim == other.ndim \
        and len(self) == len(other) \
        and set(self.names) == set(other.names) \
        and np.allclose(
            self.fiducial,
            other.fiducial[index],
        ) \
        and np.allclose(
            self.values,
            reindex_array(other.values, index),
        )


    @property
    def ndim(self):
        &#34;&#34;&#34;
        Returns the number of dimensions of the Fisher object (for now always 2).
        &#34;&#34;&#34;
        return np.ndim(self._values)


    def __len__(self):
        &#34;&#34;&#34;
        Returns the number of parameters in the Fisher object.
        &#34;&#34;&#34;
        return self._size


    @property
    def values(self):
        &#34;&#34;&#34;
        Returns the values in the Fisher object as a numpy array.
        &#34;&#34;&#34;
        return self._values


    @values.setter
    def values(
        self,
        value,
    ):
        &#34;&#34;&#34;
        Setter for the values of the Fisher object.
        &#34;&#34;&#34;
        if self.ndim != np.ndim(value):
            raise ValueError(
                f&#39;The dimensionality of the matrices do not match: {self.ndim} and {np.ndim(value)}&#39;
            )
        if len(self) != len(value):
            raise MismatchingSizeError(self, value)

        if not is_square(value):
            raise ValueError(
                f&#39;{value} is not a square object&#39;
            )

        self._values = np.array(value, dtype=float)


    def is_diagonal(self):
        &#34;&#34;&#34;
        Checks whether the Fisher matrix is diagonal.

        Returns
        -------
        `True` or `False`
        &#34;&#34;&#34;
        return np.all(self.values == np.diag(np.diagonal(self.values)))


    def diagonal(self, **kwargs):
        &#34;&#34;&#34;
        Returns the diagonal elements of the Fisher object as a numpy array.

        Returns
        -------
        array-like of floats
        &#34;&#34;&#34;
        return np.diag(self.values, **kwargs)


    def drop(
        self,
        *names : str,
        invert : bool = False,
        ignore_errors : bool = False,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Removes parameters from the Fisher object.

        Parameters
        ----------
        names : string-like
            the names of the parameters to drop.
            If passing a list or a tuple, make sure to unpack it using the
            asterisk (*).

        invert : bool, default = False
            whether to drop all the parameters NOT in names (the complement)

        ignore_errors : bool, default = False
            should non-existing parameters be ignored

        Returns
        -------
        Instance of `FisherMatrix`

        Examples
        --------
        &gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
        &gt;&gt;&gt; m.drop(&#39;p1&#39;, &#39;p3&#39;)
        FisherMatrix(array([[2.]]), names=array([&#39;p2&#39;], dtype=object), latex_names=array([&#39;p2&#39;], dtype=object), fiducial=array([0.]))
        &#34;&#34;&#34;
        if not ignore_errors and not set(names).issubset(set(self.names)):
            raise ValueError(
                f&#39;The names ({list(names)}) are not a strict subset &#39; \
                f&#39;of the parameter names in the Fisher object ({self.names}); &#39; \
                &#39;you can pass `ignore_errors=True` to ignore this error&#39;
            )

        if ignore_errors:
            names = np.array([name for name in names if name in self.names])

        if invert is True:
            names = set(names) ^ set(self.names)

        # TODO should we remove this?
        if set(names) == set(self.names):
            raise ValueError(&#39;Unable to remove all parameters&#39;)

        index = [np.array(np.where(self.names == name), dtype=int) for name in names]

        values = self.values
        for dim in range(self.ndim):
            values = np.delete(
                values,
                index,
                axis=dim,
            )

        fiducial = np.delete(self.fiducial, index)
        latex_names = np.delete(self.latex_names, index)
        names = np.delete(self.names, index)

        return self.__class__(
            values,
            names=names,
            latex_names=latex_names,
            fiducial=fiducial,
        )


    def trace(
        self,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Returns the trace of the Fisher object as a numpy array.
        &#34;&#34;&#34;
        return np.trace(self.values, **kwargs)


    def eigenvalues(self):
        &#34;&#34;&#34;
        Returns the eigenvalues of the Fisher object as a numpy array.
        &#34;&#34;&#34;
        return np.linalg.eigvalsh(self.values)


    def eigenvectors(self):
        &#34;&#34;&#34;
        Returns the right eigenvectors of the Fisher object as a numpy array.
        &#34;&#34;&#34;
        return np.linalg.eigh(self.values)[-1]


    def condition_number(self):
        r&#34;&#34;&#34;
        Returns the condition number of the matrix with respect to the \(L^2\) norm.

        Examples
        --------
        &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 3]))
        &gt;&gt;&gt; fm.condition_number()
        3.0
        &#34;&#34;&#34;
        values = np.abs(self.eigenvalues())
        return np.max(values) / np.min(values)


    def inverse(self) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the inverse of the Fisher matrix.

        Returns
        -------
        Instance of `FisherMatrix`

        Examples
        --------
        &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 5]))
        &gt;&gt;&gt; fm.inverse()
        FisherMatrix(array([[1. , 0. , 0. ],
               [0. , 0.5, 0. ],
               [0. , 0. , 0.2]]), names=array([&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;], dtype=object), latex_names=array([&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;], dtype=object), fiducial=array([0., 0., 0.]))
        &#34;&#34;&#34;
        # inverse satisfies properties of Fisher matrix, see:
        # https://math.stackexchange.com/a/26200
        return self.__class__(
            np.linalg.inv(self.values),
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def determinant(self):
        &#34;&#34;&#34;
        Returns the determinant of the matrix.

        Returns
        -------
        float
        &#34;&#34;&#34;
        return np.linalg.det(self.values)


    def constraints(
        self,
        name : Optional[str] = None,
        marginalized : bool = True,
        sigma : Optional[float] = None,
        p : Optional[float] = None,
    ):
        r&#34;&#34;&#34;
        Returns the constraints on a parameter as a float, or on all of them
        as a numpy array if `name` is not specified.

        Parameters
        ----------
        name : Optional[str] = None
            the name of the parameter for which we we want the constraints

        marginalized : bool, default = True
            whether we want the marginalized or the unmarginalized
            constraints.

        sigma : Optional[float], default = None
            how many sigmas away.

        p : Optional[float], default = None
            the confidence interval (p-value).
            The relationship between `p` and `sigma` is defined via:
            \[
                p(\sigma) = \int\limits_{\mu - \sigma}^{\mu + \sigma}
                            f(x, \mu, 1)\, \mathrm{d}x
                          = \mathrm{Erf}(\sigma / \sqrt{2})
            \]
            and therefore the inverse is simply:
            \[
                \sigma(p) = \sqrt{2}\, \mathrm{Erf}^{-1}(p)
            \]
            The values of `p` corresponding to 1, 2, 3 `sigma` are roughly
            0.683, 0.954, and 0.997, respectively.

        Returns
        -------
        array-like of floats or single float

        Notes
        -----
        The user should specify either `sigma` or `p`, but not both
        simultaneously.
        If neither are specified, defaults to `sigma=1`.

        Examples
        --------
        Get (marginalized by default) constraints for all parameters:
        &gt;&gt;&gt; m = FisherMatrix([[3, -2], [-2, 5]])
        &gt;&gt;&gt; m.constraints()
        array([0.67419986, 0.52223297])

        Get the unmarginalized constraints instead:
        &gt;&gt;&gt; m.constraints(marginalized=False)
        array([0.57735027, 0.4472136 ])

        Get the unmarginalized constraints for a single parameter:
        &gt;&gt;&gt; m.constraints(&#39;p1&#39;, marginalized=False)
        array([0.57735027])

        Get the marginalized constraints for a single parameter:
        &gt;&gt;&gt; m.constraints(&#39;p1&#39;, p=0.682689) # p-value roughly equal to 1 sigma
        array([0.67419918])
        &#34;&#34;&#34;
        if sigma is not None and p is not None:
            raise ValueError(
                &#39;Cannot specify both `p` and `sigma` simultaneously&#39;
            )

        if p is not None:
            if not 0 &lt; p &lt; 1:
                raise ValueError(
                    f&#39;The value of `p` {p} is outside of the allowed range (0, 1)&#39;
                )
            sigma = np.sqrt(2) * erfinv(p)
        elif sigma is None:
            sigma = 1

        if sigma &lt;= 0:
            raise ValueError(
                f&#39;The value of `sigma` {sigma} is outside of the allowed range (0, infinify)&#39;
            )

        if marginalized:
            inv = self.inverse()
            result = np.sqrt(np.diag(inv.values)) * sigma
        else:
            result = 1. / np.sqrt(np.diag(self.values)) * sigma

        if name is not None:
            if name in self.names:
                return result[np.where(self.names == name)]
            raise ParameterNotFoundError(name, self.names)

        return result


    @property
    def fiducial(self):
        &#34;&#34;&#34;
        Returns the fiducial values of the Fisher object as a numpy array.
        &#34;&#34;&#34;
        return self._fiducial


    @fiducial.setter
    def fiducial(
        self,
        value,
    ):
        &#34;&#34;&#34;
        The setter for the fiducial values of the Fisher object.
        &#34;&#34;&#34;
        if len(value) != len(self):
            raise MismatchingSizeError(value, self)
        try:
            self._fiducial = np.array([float(_) for _ in value])
        except TypeError as err:
            raise TypeError(err) from err


    @property
    def names(self):
        &#34;&#34;&#34;
        Returns the parameter names of the Fisher object.
        &#34;&#34;&#34;
        return self._names


    @names.setter
    def names(
        self,
        value,
    ):
        &#34;&#34;&#34;
        The bulk setter for the names.
        The length of the names must be the same as the one of the original
        object.
        &#34;&#34;&#34;
        if len(set(value)) != len(self):
            raise MismatchingSizeError(set(value), self)
        self._names = np.array(value, dtype=object)


    @property
    def latex_names(self):
        &#34;&#34;&#34;
        Returns the LaTeX names of the parameters of the Fisher object.
        &#34;&#34;&#34;
        return self._latex_names


    @latex_names.setter
    def latex_names(
        self,
        value,
    ):
        &#34;&#34;&#34;
        The bulk setter for the LaTeX names.
        The length of the names must be the same as the one of the original
        object.
        &#34;&#34;&#34;
        if len(set(value)) != len(self):
            raise MismatchingSizeError(set(value), self)
        self._latex_names = np.array(value, dtype=object)


    def __add__(
        self,
        other : FisherMatrix,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the result of adding two Fisher objects.
        &#34;&#34;&#34;
        try:
            other = float(other)
        except TypeError as err:
            # make sure the dimensions match
            if other.ndim != self.ndim:
                raise ValueError(
                    f&#39;The dimensions of the objects do not match: {other.ndim} and {self.ndim}&#39;
                ) from err

            # make sure they have the right parameters
            if set(other.names) != set(self.names):
                raise ValueError(
                    f&#39;Incompatible parameter names: {other.names} and {self.names}&#39;
                ) from err

            index = get_index_of_other_array(self.names, other.names)

            # make sure the fiducials match
            fiducial = other.fiducial[index]

            if not np.allclose(fiducial, self.fiducial):
                raise ValueError(
                    f&#39;Incompatible fiducial values: {fiducial} and {self.fiducial}&#39;
                ) from err

            values = self.values + reindex_array(other.values, index)

            return self.__class__(
                values,
                names=self.names,
                latex_names=self.latex_names,
                fiducial=self.fiducial,
            )

        return self.__class__(
            self.values + other,
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __radd__(
        self,
        other : Union[FisherMatrix, float],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Addition when the Fisher object is the right operand.
        &#34;&#34;&#34;
        return self.__add__(other)


    def __neg__(self) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the negation of the Fisher object.
        &#34;&#34;&#34;
        return self.__class__(
            -self.values,
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __sub__(
        self,
        other : Union[FisherMatrix, float],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the result of subtracting two Fisher objects.
        &#34;&#34;&#34;
        return self.__add__(-other)


    def __rsub__(
        self,
        other : Union[FisherMatrix, float],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Subtraction when the Fisher object is the right operand.
        &#34;&#34;&#34;
        # this will never be called if we subtract two FisherMatrix instances,
        # so we just need to handle floats
        return -self.__add__(-other)


    def __array_ufunc__(
        self,
        ufunc,
        method,
        *inputs,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Handles numpy&#39;s universal functions.
        For a complete list and explanation, see:
        https://numpy.org/doc/stable/reference/ufuncs.html
        &#34;&#34;&#34;
        if method == &#39;__call__&#39;:
            scalars = []
            for i in inputs:
                if isinstance(i, Number):
                    scalars.append(i)
                elif isinstance(i, self.__class__):
                    scalars.append(i.values)
                else:
                    return NotImplemented

            names = [_.names for _ in inputs if isinstance(_, self.__class__)]

            if not np.all([set(names[0]) == set(_) for _ in names]):
                raise ValueError(
                    &#39;Mismatching names&#39;
                )

            # make sure the names have the same _ordering_
            for index, _ in enumerate(inputs):
                if isinstance(_, self.__class__):
                    scalars[index] = _.sort(
                        key=get_index_of_other_array(
                            names[0],
                            _.names,
                        )
                    ).values

            return self.__class__(
                ufunc(*scalars, **kwargs),
                names=self.names,
                latex_names=self.latex_names,
                fiducial=self.fiducial,
            )

        return NotImplemented


    def __pow__(
        self,
        other : float,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Raises the Fisher object to some power.
        &#34;&#34;&#34;
        return self.__class__(
            np.power(self.values, other),
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __matmul__(
        self,
        other : FisherMatrix,
    ):
        &#34;&#34;&#34;
        Matrix multiplies two Fisher objects.
        &#34;&#34;&#34;
        # make sure the dimensions match
        if other.ndim != self.ndim:
            raise ValueError(
                f&#39;The dimensions of the objects do not match: {other.ndim} and {self.ndim}&#39;
            )

        # make sure they have the right parameters
        if set(other.names) != set(self.names):
            raise ValueError(
                f&#39;Incompatible parameter names: {other.names} and {self.names}&#39;
            )

        index = get_index_of_other_array(self.names, other.names)

        # make sure the fiducials match
        fiducial = other.fiducial[index]

        if not np.allclose(fiducial, self.fiducial):
            raise ValueError(
                f&#39;Incompatible fiducial values: {fiducial} and {self.fiducial}&#39;
            )

        values = self.values @ reindex_array(other.values, index)

        return self.__class__(
            values,
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __truediv__(
        self,
        other : Union[FisherMatrix, float, int],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the result of dividing a Fisher object by a number, or another
        Fisher object (element-wise).
        &#34;&#34;&#34;
        # we can only divide two objects if they have the same dimensions and sizes
        try:
            other = float(other)
        except TypeError as err:
            # maybe it&#39;s a FisherMatrix
            # make sure they have the right parameters
            if set(other.names) != set(self.names):
                raise ValueError(err) from err

            index = get_index_of_other_array(self.names, other.names)

            # make sure the fiducials match
            fiducial = other.fiducial[index]

            if not np.allclose(fiducial, self.fiducial):
                raise ValueError(err) from err

            if other.ndim == self.ndim:
                values = self.values / reindex_array(other.values, index)
            else:
                raise TypeError(err) from err
        else:
            values = self.values / other

        return self.__class__(
            values,
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __mul__(
        self,
        other : Union[FisherMatrix, float, int],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the result of multiplying a Fisher object by a number, or
        another Fisher object (element-wise).
        &#34;&#34;&#34;
        # we can only multiply two objects if they have the same dimensions and sizes
        try:
            other = float(other)
        except TypeError as err:
            # maybe it&#39;s a FisherMatrix
            # make sure they have the right parameters
            if set(other.names) != set(self.names):
                raise ValueError(err) from err

            index = get_index_of_other_array(self.names, other.names)

            # make sure the fiducials match
            fiducial = other.fiducial[index]

            if not np.allclose(fiducial, self.fiducial):
                raise ValueError(err) from err

            if other.ndim == self.ndim:
                values = self.values * reindex_array(other.values, index)
            else:
                raise TypeError(err) from err
        else:
            values = self.values * other

        return self.__class__(
            values,
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __rmul__(
        self,
        other : Union[float, int],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the result of multiplying a number by a Fisher object, or
        another Fisher object (element-wise).
        &#34;&#34;&#34;
        return self.__mul__(other)


    def reparametrize(
        self,
        jacobian : Collection,
        names : Optional[Collection[str]] = None,
        latex_names : Optional[Collection[str]] = None,
        fiducial : Optional[Collection[float]] = None,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns a new Fisher object with parameters `names`, which are
        related to the old ones via the transformation `jacobian`.
        See the [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Fisher_information&amp;oldid=1063384000#Reparametrization) for more information.

        Parameters
        ----------
        transformation : array-like
            the Jacobian of the transformation

        names : array-like, default = None
            list of new names for the Fisher object. If None, uses the old
            names.

        latex_names: array-like, default = None
            list of new LaTeX names for the Fisher object. If None, and
            `names` is set, uses those instead, otherwise uses the old LaTeX names.

        fiducial : array-like, default = None
            the new values of the fiducial. If not set, defaults to old values.

        Returns
        -------
        Instance of `FisherMatrix`.

        Examples
        --------
        &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2]))
        &gt;&gt;&gt; jac = [[1, 4], [3, 2]]
        &gt;&gt;&gt; fm.reparametrize(jac, names=[&#39;a&#39;, &#39;b&#39;])
        FisherMatrix(array([[19., 16.],
               [16., 24.]]), names=array([&#39;a&#39;, &#39;b&#39;], dtype=object), latex_names=array([&#39;a&#39;, &#39;b&#39;], dtype=object), fiducial=array([0., 0.]))
        &#34;&#34;&#34;
        values = np.transpose(jacobian) @ self.values @ jacobian

        if names is not None:
            if len(set(names)) != np.shape(jacobian)[-1]:
                raise MismatchingSizeError(names)
            if latex_names is not None:
                if len(set(latex_names)) != np.shape(jacobian)[-1]:
                    raise MismatchingSizeError(latex_names)
            else:
                latex_names = copy.deepcopy(names)
        else:
            # we don&#39;t transform the names
            names = copy.deepcopy(self.names)
            latex_names = copy.deepcopy(self.latex_names)

        if fiducial is not None:
            if len(fiducial) != np.shape(jacobian)[-1]:
                raise MismatchingSizeError(fiducial)
        else:
            fiducial = copy.deepcopy(self.fiducial)

        return self.__class__(
            values,
            names=names,
            latex_names=latex_names,
            fiducial=fiducial,
        )


    def to_file(
        self,
        path : str,
        *args : str,
        metadata : dict = {},
        overwrite : bool = False,
    ):
        r&#34;&#34;&#34;
        Saves the Fisher object to a file.
        The format used is a simple JSON file, containing at least the values of the
        Fisher object, the names of the parameters, the LaTeX names, and the
        fiducial values.

        Parameters
        ----------
        path : str
            the path to save the data to.

        args : str
            whatever other information about the object needs to be saved.
            Needs to be one of the following: `is_valid`, `eigenvalues`,
            `eigenvectors`, `trace`, `determinant`, or `constraints` (by
            default, the 1$\sigma$ marginalized constraints).

        metadata : dict, default = {}
            any metadata that should be associated to the object saved

        overwrite : bool, default = False
            whether to overwrite the file if it exists

        Returns
        -------
        The dictionary that was saved.

        Examples
        --------
        &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2]), names=[&#39;a&#39;, &#39;b&#39;], latex_names=[r&#39;$\mathbf{A}$&#39;, r&#39;$\mathbf{B}$&#39;])
        &gt;&gt;&gt; fm.to_file(&#39;example_matrix.json&#39;, overwrite=True)
        {&#39;values&#39;: [[1.0, 0.0], [0.0, 2.0]], &#39;names&#39;: [&#39;a&#39;, &#39;b&#39;], &#39;latex_names&#39;: [&#39;$\\mathbf{A}$&#39;, &#39;$\\mathbf{B}$&#39;], &#39;fiducial&#39;: [0.0, 0.0]}
        &gt;&gt;&gt; fm_read = FisherMatrix.from_file(&#39;example_matrix.json&#39;) # convenience function for reading it
        &gt;&gt;&gt; fm == fm_read # verify it&#39;s the same object
        True
        &#34;&#34;&#34;
        data = {
            &#39;values&#39; : self.values.tolist(),
            &#39;names&#39; : self.names.tolist(),
            &#39;latex_names&#39; : self.latex_names.tolist(),
            &#39;fiducial&#39; : self.fiducial.tolist(),
        }

        allowed_metadata = {
            &#39;is_valid&#39; : bool,
            &#39;eigenvalues&#39; : np.array,
            &#39;eigenvectors&#39; : np.array,
            &#39;trace&#39; : float,
            &#39;determinant&#39; : float,
            &#39;constraints&#39; : np.array,
        }

        for arg in args:
            if arg not in allowed_metadata:
                raise ValueError(
                    f&#39;name {arg} is not one of {list(allowed_metadata.keys())}&#39;
                )

        for arg in metadata:
            if arg in data:
                raise ValueError(
                    f&#39;name {arg} cannot be one of {list(data.keys())}&#39;
                )

        data = {
            **data,
            **{arg : jsonify(getattr(self, arg)()) for arg in args},
            **metadata,
        }

        if os.path.exists(path) and not overwrite:
            raise FileExistsError(
                f&#39;The file {path} already exists, please pass &#39; \
                &#39;`overwrite=True` if you wish to explicitly overwrite &#39;
                &#39;the file&#39;
            )

        with open(path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file_handle:
            file_handle.write(json.dumps(data, indent=4))

        return data


    def marginalize_over(
        self,
        *names : str,
        invert : bool = False,
        ignore_errors : bool = False,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Perform marginalization over some parameters.

        Parameters
        ----------
        names : str
            the names of the parameters to marginalize over

        invert : bool, default = False
            whether to marginalize over all the parameters NOT in names (the complement)

        ignore_errors : bool, default = False
            should non-existing parameters be ignored

        Returns
        -------
        Instance of `FisherMatrix`.

        Examples
        --------
        Generate a Fisher object using a random orthogonal matrix:
        &gt;&gt;&gt; from scipy.stats import ortho_group
        &gt;&gt;&gt; rm = ortho_group.rvs(5, random_state=12345)
        &gt;&gt;&gt; fm = FisherMatrix(rm.T @ np.diag([1, 2, 3, 7, 6]) @ rm)

        Marginalize over some parameters:
        &gt;&gt;&gt; fm.marginalize_over(&#39;p1&#39;, &#39;p2&#39;)
        FisherMatrix(array([[ 1.67715591, -1.01556085,  0.30020773],
               [-1.01556085,  4.92788976,  0.91219831],
               [ 0.30020773,  0.91219831,  3.1796454 ]]), names=array([&#39;p3&#39;, &#39;p4&#39;, &#39;p5&#39;], dtype=object), latex_names=array([&#39;p3&#39;, &#39;p4&#39;, &#39;p5&#39;], dtype=object), fiducial=array([0., 0., 0.]))

        Marginalize over all parameters which are NOT `p1` or `p2`:
        &gt;&gt;&gt; fm.marginalize_over(&#39;p1&#39;, &#39;p2&#39;, invert=True)
        FisherMatrix(array([[ 5.04480062, -0.04490453],
               [-0.04490453,  1.61599083]]), names=array([&#39;p1&#39;, &#39;p2&#39;], dtype=object), latex_names=array([&#39;p1&#39;, &#39;p2&#39;], dtype=object), fiducial=array([0., 0.]))
        &#34;&#34;&#34;
        inv = self.inverse()
        if invert is True:
            names = set(names) ^ set(self.names)
        fm = inv.drop(*names, ignore_errors=ignore_errors)
        return fm.inverse()


    @classmethod
    def from_file(
        cls,
        path : str,
    ):
        &#34;&#34;&#34;
        Reads a Fisher object from a file.

        Parameters
        ----------
        path : str
            the path to the file

        Returns
        -------
        Instance of `FisherMatrix`
        &#34;&#34;&#34;
        with open(path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file_handle:
            data = json.loads(file_handle.read())

        return cls(
            data[&#39;values&#39;],
            names=data[&#39;names&#39;],
            latex_names=data[&#39;latex_names&#39;],
            fiducial=data[&#39;fiducial&#39;],
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fitk.fisher_matrix.FisherMatrix"><code class="flex name class">
<span>class <span class="ident">FisherMatrix</span></span>
<span>(</span><span>values:Collection, names:Optional[Collection[str]]=None, latex_names:Optional[str]=None, fiducial:Optional[Collection[float]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for handling Fisher objects.</p>
<h2 id="examples">Examples</h2>
<p>Specify a Fisher object with default names and fiducials:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]))
</code></pre>
<p>The object has a friendly representation in the interactive session:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm
FisherMatrix(array([[5., 0.],
       [0., 4.]]), names=array(['p1', 'p2'], dtype=object), latex_names=array(['p1', 'p2'], dtype=object), fiducial=array([0., 0.]))
</code></pre>
<p>The string representation is probably more readable:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; print(fm)
FisherMatrix([[5. 0.]
 [0. 4.]], names=['p1' 'p2'], latex_names=['p1' 'p2'], fiducial=[0. 0.])
</code></pre>
<p>List the names:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm.names
array(['p1', 'p2'], dtype=object)
</code></pre>
<p>List the values of the Fisher object:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm.values
array([[5., 0.],
       [0., 4.]])
</code></pre>
<p>List the values of the fiducials:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm.fiducial
array([0., 0.])
</code></pre>
<p>Names can be changed in bulk (ditto for fiducial and values; dimension must of course match the original):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]))
&gt;&gt;&gt; fm.names = ['x', 'y']
&gt;&gt;&gt; fm.latex_names = [r'$\mathbf{X}$', r'$\mathbf{Y}$']
&gt;&gt;&gt; fm
FisherMatrix(array([[5., 0.],
       [0., 4.]]), names=array(['x', 'y'], dtype=object), latex_names=array(['$\\mathbf{X}$', '$\\mathbf{Y}$'], dtype=object), fiducial=array([0., 0.]))
</code></pre>
<p>We can get and set individual elements of the matrix using dict-like notation:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]), names=['x', 'y'])
&gt;&gt;&gt; fm['x', 'x']
5.0
</code></pre>
<p>The off-diagonal elements are automatically updated when using the setter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]), names=['x', 'y'])
&gt;&gt;&gt; fm['x', 'y'] = -2
&gt;&gt;&gt; fm
FisherMatrix(array([[ 5., -2.],
       [-2.,  4.]]), names=array(['x', 'y'], dtype=object), latex_names=array(['x', 'y'], dtype=object), fiducial=array([0., 0.]))
</code></pre>
<p>We can select submatrices by index:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 3]), names=['x', 'y', 'z'])
&gt;&gt;&gt; fm[1:]
FisherMatrix(array([[2., 0.],
       [0., 3.]]), names=array(['y', 'z'], dtype=object), latex_names=array(['y', 'z'], dtype=object), fiducial=array([0., 0.]))
</code></pre>
<p>Fisher object with parameter names:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]), names=['x', 'y'], latex_names=['$\\mathbf{X}$', '$\\mathbf{Y}$'])
&gt;&gt;&gt; fm_with_names = FisherMatrix(np.diag([1, 2]), names=['x', 'y'])
</code></pre>
<p>We can add Fisher objects (ordering of names is taken care of):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm + fm_with_names # doctest: +SKIP
FisherMatrix(array([[6., 0.],
       [0., 6.]]), names=array(['x', 'y'], dtype=object), latex_names=array(['$\\mathbf{X}$', '$\\mathbf{Y}$'], dtype=object), fiducial=array([0., 0.]))
</code></pre>
<p>We can also do element-wise multiplication or division:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm * fm_with_names
FisherMatrix(array([[5., 0.],
       [0., 8.]]), names=array(['x', 'y'], dtype=object), latex_names=array(['$\\mathbf{X}$', '$\\mathbf{Y}$'], dtype=object), fiducial=array([0., 0.]))
</code></pre>
<p>Furthermore, we can do matrix multiplication:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm @ fm_with_names
FisherMatrix(array([[5., 0.],
       [0., 8.]]), names=array(['x', 'y'], dtype=object), latex_names=array(['$\\mathbf{X}$', '$\\mathbf{Y}$'], dtype=object), fiducial=array([0., 0.]))
</code></pre>
<p>We can also perform standard matrix operations like the trace, eigenvalues, determinant:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm.trace()
9.0
&gt;&gt;&gt; fm.eigenvalues()
array([4., 5.])
&gt;&gt;&gt; fm.determinant()
19.999999999999996
</code></pre>
<p>We can also take the matrix inverse:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm.inverse()
FisherMatrix(array([[0.2 , 0.  ],
       [0.  , 0.25]]), names=array(['x', 'y'], dtype=object), latex_names=array(['$\\mathbf{X}$', '$\\mathbf{Y}$'], dtype=object), fiducial=array([0., 0.]))
</code></pre>
<p>We can drop parameters from the object:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm.drop('x')
FisherMatrix(array([[4.]]), names=array(['y'], dtype=object), latex_names=array(['$\\mathbf{Y}$'], dtype=object), fiducial=array([0.]))
</code></pre>
<p>We can save it to a file (the returned value is the dictionary that was saved):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm.to_file('example_matrix.json', overwrite=True)
{'values': [[5.0, 0.0], [0.0, 4.0]], 'names': ['x', 'y'], 'latex_names': ['$\\mathbf{X}$', '$\\mathbf{Y}$'], 'fiducial': [0.0, 0.0]}
</code></pre>
<p>Loading is performed by a class method <code>from_file</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm_new = FisherMatrix.from_file('example_matrix.json')
</code></pre>
<p>Constructor for Fisher object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>values</code></strong> :&ensp;<code>array-like</code></dt>
<dd>The values of the Fisher object.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>array-like iterable</code> of <code>str</code>, default <code>= None</code></dt>
<dd>The names of the parameters.
If not specified, defaults to <code>p1, &hellip;, pn</code>.</dd>
<dt><strong><code>latex_names</code></strong> :&ensp;<code>array-like iterable</code> of <code>str</code>, default <code>= None</code></dt>
<dd>The LaTeX names of the parameters.
If not specified, defaults to <code>names</code>.</dd>
<dt><strong><code>fiducial</code></strong> :&ensp;<code>array-like iterable</code> of <code>float</code>, default <code>= None</code></dt>
<dd>The fiducial values of the parameters. If not specified, default to
0 for all parameters.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>Optional[dict]</code>, default <code>= None</code></dt>
<dd>any metadata associated with the Fisher object</dd>
</dl>
<h2 id="raises">Raises</h2>
<ul>
<li><code>ValueError</code> if the input array has the wrong dimensionality (not 2)</li>
<li><code>ValueError</code> if the object is not square-like</li>
<li><code>MismatchingSizeError</code> if the sizes of the array of names, values, LaTeX names and fiducials do not match</li>
</ul>
<h2 id="examples_1">Examples</h2>
<p>Specify a Fisher object without names:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; FisherMatrix(np.diag([1, 2, 3]))
FisherMatrix(array([[1., 0., 0.],
       [0., 2., 0.],
       [0., 0., 3.]]), names=array(['p1', 'p2', 'p3'], dtype=object), latex_names=array(['p1', 'p2', 'p3'], dtype=object), fiducial=array([0., 0., 0.]))
</code></pre>
<p>Specify a Fisher object with names, LaTeX names, and fiducials:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; FisherMatrix(np.diag([1, 2]), names=['alpha', 'beta'],
... latex_names=[r'$\alpha$', r'$\beta$'], fiducial=[-3, 2])
FisherMatrix(array([[1., 0.],
       [0., 2.]]), names=array(['alpha', 'beta'], dtype=object), latex_names=array(['$\\alpha$', '$\\beta$'], dtype=object), fiducial=array([-3.,  2.]))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FisherMatrix:
    r&#34;&#34;&#34;
    Class for handling Fisher objects.

    Examples
    --------
    Specify a Fisher object with default names and fiducials:
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]))

    The object has a friendly representation in the interactive session:
    &gt;&gt;&gt; fm
    FisherMatrix(array([[5., 0.],
           [0., 4.]]), names=array([&#39;p1&#39;, &#39;p2&#39;], dtype=object), latex_names=array([&#39;p1&#39;, &#39;p2&#39;], dtype=object), fiducial=array([0., 0.]))

    The string representation is probably more readable:
    &gt;&gt;&gt; print(fm)
    FisherMatrix([[5. 0.]
     [0. 4.]], names=[&#39;p1&#39; &#39;p2&#39;], latex_names=[&#39;p1&#39; &#39;p2&#39;], fiducial=[0. 0.])

    List the names:
    &gt;&gt;&gt; fm.names
    array([&#39;p1&#39;, &#39;p2&#39;], dtype=object)

    List the values of the Fisher object:
    &gt;&gt;&gt; fm.values
    array([[5., 0.],
           [0., 4.]])

    List the values of the fiducials:
    &gt;&gt;&gt; fm.fiducial
    array([0., 0.])

    Names can be changed in bulk (ditto for fiducial and values; dimension must of course match the original):
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]))
    &gt;&gt;&gt; fm.names = [&#39;x&#39;, &#39;y&#39;]
    &gt;&gt;&gt; fm.latex_names = [r&#39;$\mathbf{X}$&#39;, r&#39;$\mathbf{Y}$&#39;]
    &gt;&gt;&gt; fm
    FisherMatrix(array([[5., 0.],
           [0., 4.]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0., 0.]))

    We can get and set individual elements of the matrix using dict-like notation:
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]), names=[&#39;x&#39;, &#39;y&#39;])
    &gt;&gt;&gt; fm[&#39;x&#39;, &#39;x&#39;]
    5.0

    The off-diagonal elements are automatically updated when using the setter:
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]), names=[&#39;x&#39;, &#39;y&#39;])
    &gt;&gt;&gt; fm[&#39;x&#39;, &#39;y&#39;] = -2
    &gt;&gt;&gt; fm
    FisherMatrix(array([[ 5., -2.],
           [-2.,  4.]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), fiducial=array([0., 0.]))

    We can select submatrices by index:
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 3]), names=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])
    &gt;&gt;&gt; fm[1:]
    FisherMatrix(array([[2., 0.],
           [0., 3.]]), names=array([&#39;y&#39;, &#39;z&#39;], dtype=object), latex_names=array([&#39;y&#39;, &#39;z&#39;], dtype=object), fiducial=array([0., 0.]))

    Fisher object with parameter names:
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([5, 4]), names=[&#39;x&#39;, &#39;y&#39;], latex_names=[&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;])
    &gt;&gt;&gt; fm_with_names = FisherMatrix(np.diag([1, 2]), names=[&#39;x&#39;, &#39;y&#39;])

    We can add Fisher objects (ordering of names is taken care of):
    &gt;&gt;&gt; fm + fm_with_names # doctest: +SKIP
    FisherMatrix(array([[6., 0.],
           [0., 6.]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0., 0.]))

    We can also do element-wise multiplication or division:
    &gt;&gt;&gt; fm * fm_with_names
    FisherMatrix(array([[5., 0.],
           [0., 8.]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0., 0.]))

    Furthermore, we can do matrix multiplication:
    &gt;&gt;&gt; fm @ fm_with_names
    FisherMatrix(array([[5., 0.],
           [0., 8.]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0., 0.]))

    We can also perform standard matrix operations like the trace, eigenvalues, determinant:
    &gt;&gt;&gt; fm.trace()
    9.0
    &gt;&gt;&gt; fm.eigenvalues()
    array([4., 5.])
    &gt;&gt;&gt; fm.determinant()
    19.999999999999996

    We can also take the matrix inverse:
    &gt;&gt;&gt; fm.inverse()
    FisherMatrix(array([[0.2 , 0.  ],
           [0.  , 0.25]]), names=array([&#39;x&#39;, &#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0., 0.]))

    We can drop parameters from the object:
    &gt;&gt;&gt; fm.drop(&#39;x&#39;)
    FisherMatrix(array([[4.]]), names=array([&#39;y&#39;], dtype=object), latex_names=array([&#39;$\\mathbf{Y}$&#39;], dtype=object), fiducial=array([0.]))

    We can save it to a file (the returned value is the dictionary that was saved):
    &gt;&gt;&gt; fm.to_file(&#39;example_matrix.json&#39;, overwrite=True)
    {&#39;values&#39;: [[5.0, 0.0], [0.0, 4.0]], &#39;names&#39;: [&#39;x&#39;, &#39;y&#39;], &#39;latex_names&#39;: [&#39;$\\mathbf{X}$&#39;, &#39;$\\mathbf{Y}$&#39;], &#39;fiducial&#39;: [0.0, 0.0]}

    Loading is performed by a class method `from_file`:
    &gt;&gt;&gt; fm_new = FisherMatrix.from_file(&#39;example_matrix.json&#39;)
    &#34;&#34;&#34;

    def __init__(
        self,
        values : Collection,
        names : Optional[Collection[str]] = None,
        latex_names : Optional[str] = None,
        fiducial : Optional[Collection[float]] = None,
    ):
        r&#34;&#34;&#34;
        Constructor for Fisher object.

        Parameters
        ----------
        values : array-like
            The values of the Fisher object.

        names : array-like iterable of `str`, default = None
            The names of the parameters.
            If not specified, defaults to `p1, ..., pn`.

        latex_names : array-like iterable of `str`, default = None
            The LaTeX names of the parameters.
            If not specified, defaults to `names`.

        fiducial : array-like iterable of `float`, default = None
            The fiducial values of the parameters. If not specified, default to
            0 for all parameters.

        metadata : Optional[dict], default = None
            any metadata associated with the Fisher object

        Raises
        ------
        * `ValueError` if the input array has the wrong dimensionality (not 2)
        * `ValueError` if the object is not square-like
        * `MismatchingSizeError` if the sizes of the array of names, values, LaTeX names and fiducials do not match

        Examples
        --------
        Specify a Fisher object without names:
        &gt;&gt;&gt; FisherMatrix(np.diag([1, 2, 3]))
        FisherMatrix(array([[1., 0., 0.],
               [0., 2., 0.],
               [0., 0., 3.]]), names=array([&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;], dtype=object), latex_names=array([&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;], dtype=object), fiducial=array([0., 0., 0.]))

        Specify a Fisher object with names, LaTeX names, and fiducials:
        &gt;&gt;&gt; FisherMatrix(np.diag([1, 2]), names=[&#39;alpha&#39;, &#39;beta&#39;],
        ... latex_names=[r&#39;$\alpha$&#39;, r&#39;$\beta$&#39;], fiducial=[-3, 2])
        FisherMatrix(array([[1., 0.],
               [0., 2.]]), names=array([&#39;alpha&#39;, &#39;beta&#39;], dtype=object), latex_names=array([&#39;$\\alpha$&#39;, &#39;$\\beta$&#39;], dtype=object), fiducial=array([-3.,  2.]))
        &#34;&#34;&#34;

        if np.ndim(values) != 2:
            raise ValueError(
                f&#39;The object {values} is not 2-dimensional&#39;
            )

        if not is_square(values):
            raise ValueError(
                f&#39;The object {values} is not square-like&#39;
            )

        # try to treat it as an array-like object
        self._values = np.array(values, dtype=float)

        self._size = np.shape(self._values)[0]
        self._ndim = np.ndim(self._values)

        # setting the fiducial
        if fiducial is None:
            self._fiducial = np.zeros(self._size, dtype=float)
        else:
            self._fiducial = np.array(fiducial, dtype=float)

        # setting the names
        if names is None:
            self._names = make_default_names(self._size)
        else:
            # check they&#39;re unique
            if len(set(names)) != len(names):
                raise MismatchingSizeError(set(names), names)

            self._names = np.array(names, dtype=object)

        # setting the pretty names (LaTeX)
        if latex_names is None:
            self._latex_names = copy.deepcopy(self._names)
        else:
            self._latex_names = np.array(latex_names, dtype=object)

        # check sizes of inputs
        if not all(
            len(_) == self._size \
            for _ in (self._names, self._fiducial, self._latex_names)
        ):
            raise MismatchingSizeError(
                self._values[0],
                self._names,
                self._fiducial,
                self._latex_names,
            )


    def rename(
        self,
        names : Mapping[str, Union[str, abc.Mapping]],
        ignore_errors : bool = False,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns a Fisher object with new names.

        Parameters
        ----------
        names : Mapping[str, Union[str, abc.Mapping]]
            a mapping (dictionary-like object) between the old names and the
            new ones. The values it maps to can either be a string (the new name), or a dict
            with keys `name`, `latex_name`, and `fiducial` (only `name` is mandatory).

        ignore_errors : bool, default = False
            if set to True, will not raise an error if a parameter doesn&#39;t exist

        Returns
        -------
        Instance of `FisherMatrix`.

        Examples
        --------
        &gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
        &gt;&gt;&gt; m.rename({&#39;p1&#39; : &#39;a&#39;, &#39;p2&#39; : dict(name=&#39;b&#39;, latex_name=&#39;$b$&#39;, fiducial=2)})
        FisherMatrix(array([[1., 0., 0.],
               [0., 2., 0.],
               [0., 0., 3.]]), names=array([&#39;a&#39;, &#39;b&#39;, &#39;p3&#39;], dtype=object), latex_names=array([&#39;a&#39;, &#39;$b$&#39;, &#39;p3&#39;], dtype=object), fiducial=array([0., 2., 0.]))
        &#34;&#34;&#34;
        # check uniqueness and size
        if len(set(names)) != len(names):
            raise MismatchingSizeError(set(names), names)

        if not ignore_errors:
            for name in names:
                if name not in self.names:
                    raise ParameterNotFoundError(name, self.names)

        names_new = copy.deepcopy(self.names)
        latex_names_new = copy.deepcopy(self.latex_names)
        fiducial_new = copy.deepcopy(self.fiducial)

        for name, value in names.items():
            index = np.where(names_new == name)
            # it&#39;s a mapping
            if isinstance(value, abc.Mapping):
                value = _process_fisher_mapping(value)
                latex_names_new[index] = value[&#39;latex_name&#39;]
                fiducial_new[index] = value[&#39;fiducial&#39;]
                names_new[index] = value[&#39;name&#39;]
            # otherwise, it&#39;s a string
            else:
                names_new[index] = value
                latex_names_new[index] = value

        return self.__class__(
            self.values,
            names=names_new,
            latex_names=latex_names_new,
            fiducial=fiducial_new,
        )


    def _repr_html_(self):
        &#34;&#34;&#34;
        Representation of the Fisher object suitable for viewing in Jupyter
        notebook environments.
        &#34;&#34;&#34;
        header_matrix = &#39;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&#39; + (
            &#39;&lt;th&gt;{}&lt;/th&gt;&#39; * len(self)
        ).format(*self.latex_names) + &#39;&lt;/tr&gt;&lt;/thead&gt;&#39;

        body_matrix = &#39;&lt;tbody&gt;&#39;
        for index, name in enumerate(self.latex_names):
            body_matrix += f&#39;&lt;tr&gt;&lt;th&gt;{name}&lt;/th&gt;&#39; + (
                &#39;&lt;td&gt;{:.3f}&lt;/td&gt;&#39; * len(self)
            ).format(*(self.values[:, index])) + &#39;&lt;/tr&gt;&#39;
        body_matrix += &#39;&lt;/tbody&gt;&#39;

        html_matrix = f&#39;&lt;table&gt;{header_matrix}{body_matrix}&lt;/table&gt;&#39;

        return html_matrix


    def __repr__(self):
        &#34;&#34;&#34;
        Representation of the Fisher object for non-Jupyter interfaces.
        &#34;&#34;&#34;
        return &#39;FisherMatrix(&#39; \
            f&#39;{repr(self.values)}, &#39; \
            f&#39;names={repr(self.names)}, &#39; \
            f&#39;latex_names={repr(self.latex_names)}, &#39; \
            f&#39;fiducial={repr(self.fiducial)})&#39;


    def __str__(self):
        &#34;&#34;&#34;
        String representation of the Fisher object.
        &#34;&#34;&#34;
        return &#39;FisherMatrix(&#39; \
            f&#39;{self.values}, &#39; \
            f&#39;names={self.names}, &#39; \
            f&#39;latex_names={self.latex_names}, &#39; \
            f&#39;fiducial={self.fiducial})&#39;



    def __getitem__(
        self,
        keys : Union[Tuple[str], slice],
    ):
        &#34;&#34;&#34;
        Implements access to elements in the Fisher object.
        Has support for slicing.
        &#34;&#34;&#34;
        # the object can be sliced
        if isinstance(keys, slice):
            start, stop, step = keys.indices(len(self))
            indices = (slice(start, stop, step),) * self.ndim
            sl = slice(start, stop, step)
            values = self.values[indices]
            names = self.names[sl]
            latex_names = self.latex_names[sl]
            fiducial = self.fiducial[sl]

            return self.__class__(
                values,
                names=names,
                latex_names=latex_names,
                fiducial=fiducial,
            )

        try:
            _ = iter(keys)
        except TypeError as err:
            raise TypeError(err) from err

        # the keys can be a tuple
        if isinstance(keys, tuple):
            if len(keys) != self.ndim:
                raise ValueError(
                    f&#39;Expected {self.ndim} arguments, got {len(keys)}&#39;
                )

            # error checking
            for key in keys:
                if key not in self.names:
                    raise ParameterNotFoundError(key, self.names)

            indices = tuple(np.where(self.names == key) for key in keys)

        # otherwise, it&#39;s some generic object
        else:
            if keys not in self.names:
                raise ParameterNotFoundError(keys, self.names)

            indices = (np.where(self.names == keys),)

        return self._values[indices][0, 0]


    def __setitem__(
        self,
        keys : Tuple[str],
        value : float,
    ):
        &#34;&#34;&#34;
        Implements setting of elements in the Fisher object.
        Does not support slicing.
        &#34;&#34;&#34;
        try:
            _ = iter(keys)
        except TypeError as err:
            raise err

        if len(keys) != self.ndim:
            raise ValueError(f&#39;Got length {len(keys)}&#39;)

        # automatically raises a value error
        indices = tuple(np.where(self.names == key) for key in keys)

        temp_data = copy.deepcopy(self._values)

        if not all(index == indices[0] for index in indices):
            for permutation in list(permutations(indices)):
                # update all symmetric parts
                temp_data[permutation] = value
        else:
            temp_data[indices] = value

        self._values = copy.deepcopy(temp_data)


    def is_valid(self):
        &#34;&#34;&#34;
        Checks whether the values make a valid Fisher object.
        A (square) matrix is a Fisher matrix if it satisifies the following two
        criteria:

        * it is symmetric
        * it is positive semi-definite

        Returns
        -------
        `True` or `False`

        Examples
        --------
        &gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
        &gt;&gt;&gt; m.is_valid()
        True
        &gt;&gt;&gt; FisherMatrix(np.diag([-1, 3])).is_valid()
        False
        &#34;&#34;&#34;
        return \
            is_symmetric(self.values) and \
            is_positive_semidefinite(self.values)


    def imshow(
        self,
        colorbar : bool = False,
        show_values : bool = False,
        normalized : bool = False,
        colorbar_space : float = 0.02,
        colorbar_width : float = 0.05,
        colorbar_orientation : str = &#39;vertical&#39;,
        rc : abc.Mapping = get_default_rcparams(),
        **kwargs,
    ):
        &#34;&#34;&#34;
        Returns the image of the Fisher object.
        &#34;&#34;&#34;
        # TODO should only work with 2D data.
        with plt.rc_context(rc):
            fig, ax = plt.subplots(figsize=(len(self), len(self)))
            img = ax.imshow(
                self.values,
                interpolation=&#39;none&#39;,
                norm=colors.CenteredNorm(),
                **kwargs,
            )

            ax.set_xticks(np.arange(len(self)))
            ax.set_yticks(np.arange(len(self)))
            ax.set_xticklabels(self.latex_names)
            ax.set_yticklabels(self.latex_names)

            if colorbar:
                allowed_orientations = (&#39;vertical&#39;, &#39;horizontal&#39;)
                if colorbar_orientation not in allowed_orientations:
                    raise ValueError(
                        f&#39;\&#39;{colorbar_orientation}\&#39; is not one of: {allowed_orientations}&#39;
                    )

                if colorbar_orientation == &#39;vertical&#39;:
                    cax = fig.add_axes(
                        [ax.get_position().x1 + colorbar_space,
                        ax.get_position().y0 * 0.997,
                        colorbar_width,
                        ax.get_position().height]
                    )
                    fig.colorbar(img, cax=cax, orientation=colorbar_orientation)
                    cax.set_yticklabels(
                        [f&#39;${float_to_latex(_)}$&#39; for _ in cax.get_yticks()]
                    )
                else:
                    cax = fig.add_axes(
                        [ax.get_position().x0,
                        ax.get_position().y1 + colorbar_space,
                        ax.get_position().width,
                        colorbar_width]
                    )
                    fig.colorbar(img, cax=cax, orientation=colorbar_orientation)
                    cax.xaxis.set_ticks_position(&#39;top&#39;)
                    cax.set_xticklabels(
                        [f&#39;${float_to_latex(_)}$&#39; for _ in cax.get_xticks()]
                    )

            # whether or not we want to display the actual values inside the
            # matrix
            if show_values:
                mid_coords = np.arange(len(self))
                for index1, index2 in product(range(len(self)), range(len(self))):
                    x = mid_coords[index1]
                    y = mid_coords[index2]
                    value = self.values[index1, index2] / \
                        np.sqrt(
                            self.values[index1, index1] \
                           *self.values[index2, index2]
                        ) if normalized \
                        else self.values[index1, index2]
                    text = ax.text(
                            x, y, f&#39;${float_to_latex(value)}$&#39;,
                            ha=&#39;center&#39;, va=&#39;center&#39;, color=&#39;white&#39;,
                    )
                    text.set_path_effects(
                        [Stroke(linewidth=1, foreground=&#34;black&#34;), Normal()]
                    )

        return fig


    def sort(
        self,
        **kwargs,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Sorts the Fisher object by name according to some criterion.

        Parameters
        ----------
        **kwargs
            all of the other keyword arguments for the Python builtin `sorted`.
            If none are specified, will sort according to the names of the parameters.
            In the special case that the value of the keyword `key` is set to
            either &#39;fiducial&#39; or &#39;latex_names&#39;, it will sort according to those.
            In the second special case that the value of the keyword `key` is
            set to an array of integers of equal size as the Fisher object, sorts them
            according to those instead.

        Returns
        -------
        Instance of `FisherMatrix`.

        Examples
        --------
        &gt;&gt;&gt; m = FisherMatrix(np.diag([3, 1, 2]), names=list(&#39;sdf&#39;),
        ... latex_names=[&#39;hjkl&#39;, &#39;qwe&#39;, &#39;ll&#39;], fiducial=[8, 7, 3])
        &gt;&gt;&gt; m.sort(key=&#39;fiducial&#39;)
        FisherMatrix(array([[2., 0., 0.],
               [0., 1., 0.],
               [0., 0., 3.]]), names=array([&#39;f&#39;, &#39;d&#39;, &#39;s&#39;], dtype=object), latex_names=array([&#39;ll&#39;, &#39;qwe&#39;, &#39;hjkl&#39;], dtype=object), fiducial=array([3., 7., 8.]))
        &gt;&gt;&gt; m.sort(key=&#39;latex_names&#39;)
        FisherMatrix(array([[3., 0., 0.],
               [0., 2., 0.],
               [0., 0., 1.]]), names=array([&#39;s&#39;, &#39;f&#39;, &#39;d&#39;], dtype=object), latex_names=array([&#39;hjkl&#39;, &#39;ll&#39;, &#39;qwe&#39;], dtype=object), fiducial=array([8., 3., 7.]))
        &#34;&#34;&#34;
        allowed_keys = (&#39;fiducial&#39;, &#39;latex_names&#39;)
        # an integer index
        if &#39;key&#39; in kwargs and all(hasattr(_, &#39;__index__&#39;) for _ in kwargs[&#39;key&#39;]):
            index = np.array(kwargs[&#39;key&#39;], dtype=int)
            names = self.names[index]
        # either &#39;fiducial&#39; or &#39;latex_names&#39;
        elif &#39;key&#39; in kwargs and kwargs[&#39;key&#39;] in allowed_keys:
            index = np.argsort(getattr(self, kwargs[&#39;key&#39;]))
            if &#39;reversed&#39; in kwargs and kwargs[&#39;reversed&#39;] is True:
                index = np.flip(index)
            names = self.names[index]
        # something that can be passed to `sorted`
        else:
            names = sorted(self.names, **kwargs)
            index = get_index_of_other_array(self.names, names)

        latex_names = self.latex_names[index]
        fiducial = self.fiducial[index]
        values = reindex_array(self.values, index)

        return self.__class__(
            values,
            names=names,
            latex_names=latex_names,
            fiducial=fiducial,
        )


    def __eq__(self, other):
        &#34;&#34;&#34;
        The equality operator.
        Returns `True` if the operands have the following properties:

        * are instances of FisherMatrix
        * have same names (potentially shuffled)
        * have same dimensionality
        * have same fiducials (potentially shuffled)
        * have same values (potentially shuffled)
        &#34;&#34;&#34;
        if set(self.names) != set(other.names):
            return False

        # index for re-shuffling parameters
        index = get_index_of_other_array(self.names, other.names)

        return isinstance(other, self.__class__) \
        and self.ndim == other.ndim \
        and len(self) == len(other) \
        and set(self.names) == set(other.names) \
        and np.allclose(
            self.fiducial,
            other.fiducial[index],
        ) \
        and np.allclose(
            self.values,
            reindex_array(other.values, index),
        )


    @property
    def ndim(self):
        &#34;&#34;&#34;
        Returns the number of dimensions of the Fisher object (for now always 2).
        &#34;&#34;&#34;
        return np.ndim(self._values)


    def __len__(self):
        &#34;&#34;&#34;
        Returns the number of parameters in the Fisher object.
        &#34;&#34;&#34;
        return self._size


    @property
    def values(self):
        &#34;&#34;&#34;
        Returns the values in the Fisher object as a numpy array.
        &#34;&#34;&#34;
        return self._values


    @values.setter
    def values(
        self,
        value,
    ):
        &#34;&#34;&#34;
        Setter for the values of the Fisher object.
        &#34;&#34;&#34;
        if self.ndim != np.ndim(value):
            raise ValueError(
                f&#39;The dimensionality of the matrices do not match: {self.ndim} and {np.ndim(value)}&#39;
            )
        if len(self) != len(value):
            raise MismatchingSizeError(self, value)

        if not is_square(value):
            raise ValueError(
                f&#39;{value} is not a square object&#39;
            )

        self._values = np.array(value, dtype=float)


    def is_diagonal(self):
        &#34;&#34;&#34;
        Checks whether the Fisher matrix is diagonal.

        Returns
        -------
        `True` or `False`
        &#34;&#34;&#34;
        return np.all(self.values == np.diag(np.diagonal(self.values)))


    def diagonal(self, **kwargs):
        &#34;&#34;&#34;
        Returns the diagonal elements of the Fisher object as a numpy array.

        Returns
        -------
        array-like of floats
        &#34;&#34;&#34;
        return np.diag(self.values, **kwargs)


    def drop(
        self,
        *names : str,
        invert : bool = False,
        ignore_errors : bool = False,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Removes parameters from the Fisher object.

        Parameters
        ----------
        names : string-like
            the names of the parameters to drop.
            If passing a list or a tuple, make sure to unpack it using the
            asterisk (*).

        invert : bool, default = False
            whether to drop all the parameters NOT in names (the complement)

        ignore_errors : bool, default = False
            should non-existing parameters be ignored

        Returns
        -------
        Instance of `FisherMatrix`

        Examples
        --------
        &gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
        &gt;&gt;&gt; m.drop(&#39;p1&#39;, &#39;p3&#39;)
        FisherMatrix(array([[2.]]), names=array([&#39;p2&#39;], dtype=object), latex_names=array([&#39;p2&#39;], dtype=object), fiducial=array([0.]))
        &#34;&#34;&#34;
        if not ignore_errors and not set(names).issubset(set(self.names)):
            raise ValueError(
                f&#39;The names ({list(names)}) are not a strict subset &#39; \
                f&#39;of the parameter names in the Fisher object ({self.names}); &#39; \
                &#39;you can pass `ignore_errors=True` to ignore this error&#39;
            )

        if ignore_errors:
            names = np.array([name for name in names if name in self.names])

        if invert is True:
            names = set(names) ^ set(self.names)

        # TODO should we remove this?
        if set(names) == set(self.names):
            raise ValueError(&#39;Unable to remove all parameters&#39;)

        index = [np.array(np.where(self.names == name), dtype=int) for name in names]

        values = self.values
        for dim in range(self.ndim):
            values = np.delete(
                values,
                index,
                axis=dim,
            )

        fiducial = np.delete(self.fiducial, index)
        latex_names = np.delete(self.latex_names, index)
        names = np.delete(self.names, index)

        return self.__class__(
            values,
            names=names,
            latex_names=latex_names,
            fiducial=fiducial,
        )


    def trace(
        self,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Returns the trace of the Fisher object as a numpy array.
        &#34;&#34;&#34;
        return np.trace(self.values, **kwargs)


    def eigenvalues(self):
        &#34;&#34;&#34;
        Returns the eigenvalues of the Fisher object as a numpy array.
        &#34;&#34;&#34;
        return np.linalg.eigvalsh(self.values)


    def eigenvectors(self):
        &#34;&#34;&#34;
        Returns the right eigenvectors of the Fisher object as a numpy array.
        &#34;&#34;&#34;
        return np.linalg.eigh(self.values)[-1]


    def condition_number(self):
        r&#34;&#34;&#34;
        Returns the condition number of the matrix with respect to the \(L^2\) norm.

        Examples
        --------
        &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 3]))
        &gt;&gt;&gt; fm.condition_number()
        3.0
        &#34;&#34;&#34;
        values = np.abs(self.eigenvalues())
        return np.max(values) / np.min(values)


    def inverse(self) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the inverse of the Fisher matrix.

        Returns
        -------
        Instance of `FisherMatrix`

        Examples
        --------
        &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 5]))
        &gt;&gt;&gt; fm.inverse()
        FisherMatrix(array([[1. , 0. , 0. ],
               [0. , 0.5, 0. ],
               [0. , 0. , 0.2]]), names=array([&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;], dtype=object), latex_names=array([&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;], dtype=object), fiducial=array([0., 0., 0.]))
        &#34;&#34;&#34;
        # inverse satisfies properties of Fisher matrix, see:
        # https://math.stackexchange.com/a/26200
        return self.__class__(
            np.linalg.inv(self.values),
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def determinant(self):
        &#34;&#34;&#34;
        Returns the determinant of the matrix.

        Returns
        -------
        float
        &#34;&#34;&#34;
        return np.linalg.det(self.values)


    def constraints(
        self,
        name : Optional[str] = None,
        marginalized : bool = True,
        sigma : Optional[float] = None,
        p : Optional[float] = None,
    ):
        r&#34;&#34;&#34;
        Returns the constraints on a parameter as a float, or on all of them
        as a numpy array if `name` is not specified.

        Parameters
        ----------
        name : Optional[str] = None
            the name of the parameter for which we we want the constraints

        marginalized : bool, default = True
            whether we want the marginalized or the unmarginalized
            constraints.

        sigma : Optional[float], default = None
            how many sigmas away.

        p : Optional[float], default = None
            the confidence interval (p-value).
            The relationship between `p` and `sigma` is defined via:
            \[
                p(\sigma) = \int\limits_{\mu - \sigma}^{\mu + \sigma}
                            f(x, \mu, 1)\, \mathrm{d}x
                          = \mathrm{Erf}(\sigma / \sqrt{2})
            \]
            and therefore the inverse is simply:
            \[
                \sigma(p) = \sqrt{2}\, \mathrm{Erf}^{-1}(p)
            \]
            The values of `p` corresponding to 1, 2, 3 `sigma` are roughly
            0.683, 0.954, and 0.997, respectively.

        Returns
        -------
        array-like of floats or single float

        Notes
        -----
        The user should specify either `sigma` or `p`, but not both
        simultaneously.
        If neither are specified, defaults to `sigma=1`.

        Examples
        --------
        Get (marginalized by default) constraints for all parameters:
        &gt;&gt;&gt; m = FisherMatrix([[3, -2], [-2, 5]])
        &gt;&gt;&gt; m.constraints()
        array([0.67419986, 0.52223297])

        Get the unmarginalized constraints instead:
        &gt;&gt;&gt; m.constraints(marginalized=False)
        array([0.57735027, 0.4472136 ])

        Get the unmarginalized constraints for a single parameter:
        &gt;&gt;&gt; m.constraints(&#39;p1&#39;, marginalized=False)
        array([0.57735027])

        Get the marginalized constraints for a single parameter:
        &gt;&gt;&gt; m.constraints(&#39;p1&#39;, p=0.682689) # p-value roughly equal to 1 sigma
        array([0.67419918])
        &#34;&#34;&#34;
        if sigma is not None and p is not None:
            raise ValueError(
                &#39;Cannot specify both `p` and `sigma` simultaneously&#39;
            )

        if p is not None:
            if not 0 &lt; p &lt; 1:
                raise ValueError(
                    f&#39;The value of `p` {p} is outside of the allowed range (0, 1)&#39;
                )
            sigma = np.sqrt(2) * erfinv(p)
        elif sigma is None:
            sigma = 1

        if sigma &lt;= 0:
            raise ValueError(
                f&#39;The value of `sigma` {sigma} is outside of the allowed range (0, infinify)&#39;
            )

        if marginalized:
            inv = self.inverse()
            result = np.sqrt(np.diag(inv.values)) * sigma
        else:
            result = 1. / np.sqrt(np.diag(self.values)) * sigma

        if name is not None:
            if name in self.names:
                return result[np.where(self.names == name)]
            raise ParameterNotFoundError(name, self.names)

        return result


    @property
    def fiducial(self):
        &#34;&#34;&#34;
        Returns the fiducial values of the Fisher object as a numpy array.
        &#34;&#34;&#34;
        return self._fiducial


    @fiducial.setter
    def fiducial(
        self,
        value,
    ):
        &#34;&#34;&#34;
        The setter for the fiducial values of the Fisher object.
        &#34;&#34;&#34;
        if len(value) != len(self):
            raise MismatchingSizeError(value, self)
        try:
            self._fiducial = np.array([float(_) for _ in value])
        except TypeError as err:
            raise TypeError(err) from err


    @property
    def names(self):
        &#34;&#34;&#34;
        Returns the parameter names of the Fisher object.
        &#34;&#34;&#34;
        return self._names


    @names.setter
    def names(
        self,
        value,
    ):
        &#34;&#34;&#34;
        The bulk setter for the names.
        The length of the names must be the same as the one of the original
        object.
        &#34;&#34;&#34;
        if len(set(value)) != len(self):
            raise MismatchingSizeError(set(value), self)
        self._names = np.array(value, dtype=object)


    @property
    def latex_names(self):
        &#34;&#34;&#34;
        Returns the LaTeX names of the parameters of the Fisher object.
        &#34;&#34;&#34;
        return self._latex_names


    @latex_names.setter
    def latex_names(
        self,
        value,
    ):
        &#34;&#34;&#34;
        The bulk setter for the LaTeX names.
        The length of the names must be the same as the one of the original
        object.
        &#34;&#34;&#34;
        if len(set(value)) != len(self):
            raise MismatchingSizeError(set(value), self)
        self._latex_names = np.array(value, dtype=object)


    def __add__(
        self,
        other : FisherMatrix,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the result of adding two Fisher objects.
        &#34;&#34;&#34;
        try:
            other = float(other)
        except TypeError as err:
            # make sure the dimensions match
            if other.ndim != self.ndim:
                raise ValueError(
                    f&#39;The dimensions of the objects do not match: {other.ndim} and {self.ndim}&#39;
                ) from err

            # make sure they have the right parameters
            if set(other.names) != set(self.names):
                raise ValueError(
                    f&#39;Incompatible parameter names: {other.names} and {self.names}&#39;
                ) from err

            index = get_index_of_other_array(self.names, other.names)

            # make sure the fiducials match
            fiducial = other.fiducial[index]

            if not np.allclose(fiducial, self.fiducial):
                raise ValueError(
                    f&#39;Incompatible fiducial values: {fiducial} and {self.fiducial}&#39;
                ) from err

            values = self.values + reindex_array(other.values, index)

            return self.__class__(
                values,
                names=self.names,
                latex_names=self.latex_names,
                fiducial=self.fiducial,
            )

        return self.__class__(
            self.values + other,
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __radd__(
        self,
        other : Union[FisherMatrix, float],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Addition when the Fisher object is the right operand.
        &#34;&#34;&#34;
        return self.__add__(other)


    def __neg__(self) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the negation of the Fisher object.
        &#34;&#34;&#34;
        return self.__class__(
            -self.values,
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __sub__(
        self,
        other : Union[FisherMatrix, float],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the result of subtracting two Fisher objects.
        &#34;&#34;&#34;
        return self.__add__(-other)


    def __rsub__(
        self,
        other : Union[FisherMatrix, float],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Subtraction when the Fisher object is the right operand.
        &#34;&#34;&#34;
        # this will never be called if we subtract two FisherMatrix instances,
        # so we just need to handle floats
        return -self.__add__(-other)


    def __array_ufunc__(
        self,
        ufunc,
        method,
        *inputs,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Handles numpy&#39;s universal functions.
        For a complete list and explanation, see:
        https://numpy.org/doc/stable/reference/ufuncs.html
        &#34;&#34;&#34;
        if method == &#39;__call__&#39;:
            scalars = []
            for i in inputs:
                if isinstance(i, Number):
                    scalars.append(i)
                elif isinstance(i, self.__class__):
                    scalars.append(i.values)
                else:
                    return NotImplemented

            names = [_.names for _ in inputs if isinstance(_, self.__class__)]

            if not np.all([set(names[0]) == set(_) for _ in names]):
                raise ValueError(
                    &#39;Mismatching names&#39;
                )

            # make sure the names have the same _ordering_
            for index, _ in enumerate(inputs):
                if isinstance(_, self.__class__):
                    scalars[index] = _.sort(
                        key=get_index_of_other_array(
                            names[0],
                            _.names,
                        )
                    ).values

            return self.__class__(
                ufunc(*scalars, **kwargs),
                names=self.names,
                latex_names=self.latex_names,
                fiducial=self.fiducial,
            )

        return NotImplemented


    def __pow__(
        self,
        other : float,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Raises the Fisher object to some power.
        &#34;&#34;&#34;
        return self.__class__(
            np.power(self.values, other),
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __matmul__(
        self,
        other : FisherMatrix,
    ):
        &#34;&#34;&#34;
        Matrix multiplies two Fisher objects.
        &#34;&#34;&#34;
        # make sure the dimensions match
        if other.ndim != self.ndim:
            raise ValueError(
                f&#39;The dimensions of the objects do not match: {other.ndim} and {self.ndim}&#39;
            )

        # make sure they have the right parameters
        if set(other.names) != set(self.names):
            raise ValueError(
                f&#39;Incompatible parameter names: {other.names} and {self.names}&#39;
            )

        index = get_index_of_other_array(self.names, other.names)

        # make sure the fiducials match
        fiducial = other.fiducial[index]

        if not np.allclose(fiducial, self.fiducial):
            raise ValueError(
                f&#39;Incompatible fiducial values: {fiducial} and {self.fiducial}&#39;
            )

        values = self.values @ reindex_array(other.values, index)

        return self.__class__(
            values,
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __truediv__(
        self,
        other : Union[FisherMatrix, float, int],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the result of dividing a Fisher object by a number, or another
        Fisher object (element-wise).
        &#34;&#34;&#34;
        # we can only divide two objects if they have the same dimensions and sizes
        try:
            other = float(other)
        except TypeError as err:
            # maybe it&#39;s a FisherMatrix
            # make sure they have the right parameters
            if set(other.names) != set(self.names):
                raise ValueError(err) from err

            index = get_index_of_other_array(self.names, other.names)

            # make sure the fiducials match
            fiducial = other.fiducial[index]

            if not np.allclose(fiducial, self.fiducial):
                raise ValueError(err) from err

            if other.ndim == self.ndim:
                values = self.values / reindex_array(other.values, index)
            else:
                raise TypeError(err) from err
        else:
            values = self.values / other

        return self.__class__(
            values,
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __mul__(
        self,
        other : Union[FisherMatrix, float, int],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the result of multiplying a Fisher object by a number, or
        another Fisher object (element-wise).
        &#34;&#34;&#34;
        # we can only multiply two objects if they have the same dimensions and sizes
        try:
            other = float(other)
        except TypeError as err:
            # maybe it&#39;s a FisherMatrix
            # make sure they have the right parameters
            if set(other.names) != set(self.names):
                raise ValueError(err) from err

            index = get_index_of_other_array(self.names, other.names)

            # make sure the fiducials match
            fiducial = other.fiducial[index]

            if not np.allclose(fiducial, self.fiducial):
                raise ValueError(err) from err

            if other.ndim == self.ndim:
                values = self.values * reindex_array(other.values, index)
            else:
                raise TypeError(err) from err
        else:
            values = self.values * other

        return self.__class__(
            values,
            names=self.names,
            latex_names=self.latex_names,
            fiducial=self.fiducial,
        )


    def __rmul__(
        self,
        other : Union[float, int],
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns the result of multiplying a number by a Fisher object, or
        another Fisher object (element-wise).
        &#34;&#34;&#34;
        return self.__mul__(other)


    def reparametrize(
        self,
        jacobian : Collection,
        names : Optional[Collection[str]] = None,
        latex_names : Optional[Collection[str]] = None,
        fiducial : Optional[Collection[float]] = None,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Returns a new Fisher object with parameters `names`, which are
        related to the old ones via the transformation `jacobian`.
        See the [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Fisher_information&amp;oldid=1063384000#Reparametrization) for more information.

        Parameters
        ----------
        transformation : array-like
            the Jacobian of the transformation

        names : array-like, default = None
            list of new names for the Fisher object. If None, uses the old
            names.

        latex_names: array-like, default = None
            list of new LaTeX names for the Fisher object. If None, and
            `names` is set, uses those instead, otherwise uses the old LaTeX names.

        fiducial : array-like, default = None
            the new values of the fiducial. If not set, defaults to old values.

        Returns
        -------
        Instance of `FisherMatrix`.

        Examples
        --------
        &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2]))
        &gt;&gt;&gt; jac = [[1, 4], [3, 2]]
        &gt;&gt;&gt; fm.reparametrize(jac, names=[&#39;a&#39;, &#39;b&#39;])
        FisherMatrix(array([[19., 16.],
               [16., 24.]]), names=array([&#39;a&#39;, &#39;b&#39;], dtype=object), latex_names=array([&#39;a&#39;, &#39;b&#39;], dtype=object), fiducial=array([0., 0.]))
        &#34;&#34;&#34;
        values = np.transpose(jacobian) @ self.values @ jacobian

        if names is not None:
            if len(set(names)) != np.shape(jacobian)[-1]:
                raise MismatchingSizeError(names)
            if latex_names is not None:
                if len(set(latex_names)) != np.shape(jacobian)[-1]:
                    raise MismatchingSizeError(latex_names)
            else:
                latex_names = copy.deepcopy(names)
        else:
            # we don&#39;t transform the names
            names = copy.deepcopy(self.names)
            latex_names = copy.deepcopy(self.latex_names)

        if fiducial is not None:
            if len(fiducial) != np.shape(jacobian)[-1]:
                raise MismatchingSizeError(fiducial)
        else:
            fiducial = copy.deepcopy(self.fiducial)

        return self.__class__(
            values,
            names=names,
            latex_names=latex_names,
            fiducial=fiducial,
        )


    def to_file(
        self,
        path : str,
        *args : str,
        metadata : dict = {},
        overwrite : bool = False,
    ):
        r&#34;&#34;&#34;
        Saves the Fisher object to a file.
        The format used is a simple JSON file, containing at least the values of the
        Fisher object, the names of the parameters, the LaTeX names, and the
        fiducial values.

        Parameters
        ----------
        path : str
            the path to save the data to.

        args : str
            whatever other information about the object needs to be saved.
            Needs to be one of the following: `is_valid`, `eigenvalues`,
            `eigenvectors`, `trace`, `determinant`, or `constraints` (by
            default, the 1$\sigma$ marginalized constraints).

        metadata : dict, default = {}
            any metadata that should be associated to the object saved

        overwrite : bool, default = False
            whether to overwrite the file if it exists

        Returns
        -------
        The dictionary that was saved.

        Examples
        --------
        &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2]), names=[&#39;a&#39;, &#39;b&#39;], latex_names=[r&#39;$\mathbf{A}$&#39;, r&#39;$\mathbf{B}$&#39;])
        &gt;&gt;&gt; fm.to_file(&#39;example_matrix.json&#39;, overwrite=True)
        {&#39;values&#39;: [[1.0, 0.0], [0.0, 2.0]], &#39;names&#39;: [&#39;a&#39;, &#39;b&#39;], &#39;latex_names&#39;: [&#39;$\\mathbf{A}$&#39;, &#39;$\\mathbf{B}$&#39;], &#39;fiducial&#39;: [0.0, 0.0]}
        &gt;&gt;&gt; fm_read = FisherMatrix.from_file(&#39;example_matrix.json&#39;) # convenience function for reading it
        &gt;&gt;&gt; fm == fm_read # verify it&#39;s the same object
        True
        &#34;&#34;&#34;
        data = {
            &#39;values&#39; : self.values.tolist(),
            &#39;names&#39; : self.names.tolist(),
            &#39;latex_names&#39; : self.latex_names.tolist(),
            &#39;fiducial&#39; : self.fiducial.tolist(),
        }

        allowed_metadata = {
            &#39;is_valid&#39; : bool,
            &#39;eigenvalues&#39; : np.array,
            &#39;eigenvectors&#39; : np.array,
            &#39;trace&#39; : float,
            &#39;determinant&#39; : float,
            &#39;constraints&#39; : np.array,
        }

        for arg in args:
            if arg not in allowed_metadata:
                raise ValueError(
                    f&#39;name {arg} is not one of {list(allowed_metadata.keys())}&#39;
                )

        for arg in metadata:
            if arg in data:
                raise ValueError(
                    f&#39;name {arg} cannot be one of {list(data.keys())}&#39;
                )

        data = {
            **data,
            **{arg : jsonify(getattr(self, arg)()) for arg in args},
            **metadata,
        }

        if os.path.exists(path) and not overwrite:
            raise FileExistsError(
                f&#39;The file {path} already exists, please pass &#39; \
                &#39;`overwrite=True` if you wish to explicitly overwrite &#39;
                &#39;the file&#39;
            )

        with open(path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file_handle:
            file_handle.write(json.dumps(data, indent=4))

        return data


    def marginalize_over(
        self,
        *names : str,
        invert : bool = False,
        ignore_errors : bool = False,
    ) -&gt; FisherMatrix:
        &#34;&#34;&#34;
        Perform marginalization over some parameters.

        Parameters
        ----------
        names : str
            the names of the parameters to marginalize over

        invert : bool, default = False
            whether to marginalize over all the parameters NOT in names (the complement)

        ignore_errors : bool, default = False
            should non-existing parameters be ignored

        Returns
        -------
        Instance of `FisherMatrix`.

        Examples
        --------
        Generate a Fisher object using a random orthogonal matrix:
        &gt;&gt;&gt; from scipy.stats import ortho_group
        &gt;&gt;&gt; rm = ortho_group.rvs(5, random_state=12345)
        &gt;&gt;&gt; fm = FisherMatrix(rm.T @ np.diag([1, 2, 3, 7, 6]) @ rm)

        Marginalize over some parameters:
        &gt;&gt;&gt; fm.marginalize_over(&#39;p1&#39;, &#39;p2&#39;)
        FisherMatrix(array([[ 1.67715591, -1.01556085,  0.30020773],
               [-1.01556085,  4.92788976,  0.91219831],
               [ 0.30020773,  0.91219831,  3.1796454 ]]), names=array([&#39;p3&#39;, &#39;p4&#39;, &#39;p5&#39;], dtype=object), latex_names=array([&#39;p3&#39;, &#39;p4&#39;, &#39;p5&#39;], dtype=object), fiducial=array([0., 0., 0.]))

        Marginalize over all parameters which are NOT `p1` or `p2`:
        &gt;&gt;&gt; fm.marginalize_over(&#39;p1&#39;, &#39;p2&#39;, invert=True)
        FisherMatrix(array([[ 5.04480062, -0.04490453],
               [-0.04490453,  1.61599083]]), names=array([&#39;p1&#39;, &#39;p2&#39;], dtype=object), latex_names=array([&#39;p1&#39;, &#39;p2&#39;], dtype=object), fiducial=array([0., 0.]))
        &#34;&#34;&#34;
        inv = self.inverse()
        if invert is True:
            names = set(names) ^ set(self.names)
        fm = inv.drop(*names, ignore_errors=ignore_errors)
        return fm.inverse()


    @classmethod
    def from_file(
        cls,
        path : str,
    ):
        &#34;&#34;&#34;
        Reads a Fisher object from a file.

        Parameters
        ----------
        path : str
            the path to the file

        Returns
        -------
        Instance of `FisherMatrix`
        &#34;&#34;&#34;
        with open(path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file_handle:
            data = json.loads(file_handle.read())

        return cls(
            data[&#39;values&#39;],
            names=data[&#39;names&#39;],
            latex_names=data[&#39;latex_names&#39;],
            fiducial=data[&#39;fiducial&#39;],
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="fitk.fisher_matrix.FisherMatrix.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>path:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a Fisher object from a file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path to the file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Instance of <code><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(
    cls,
    path : str,
):
    &#34;&#34;&#34;
    Reads a Fisher object from a file.

    Parameters
    ----------
    path : str
        the path to the file

    Returns
    -------
    Instance of `FisherMatrix`
    &#34;&#34;&#34;
    with open(path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file_handle:
        data = json.loads(file_handle.read())

    return cls(
        data[&#39;values&#39;],
        names=data[&#39;names&#39;],
        latex_names=data[&#39;latex_names&#39;],
        fiducial=data[&#39;fiducial&#39;],
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fitk.fisher_matrix.FisherMatrix.fiducial"><code class="name">var <span class="ident">fiducial</span></code></dt>
<dd>
<div class="desc"><p>Returns the fiducial values of the Fisher object as a numpy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fiducial(self):
    &#34;&#34;&#34;
    Returns the fiducial values of the Fisher object as a numpy array.
    &#34;&#34;&#34;
    return self._fiducial</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.latex_names"><code class="name">var <span class="ident">latex_names</span></code></dt>
<dd>
<div class="desc"><p>Returns the LaTeX names of the parameters of the Fisher object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def latex_names(self):
    &#34;&#34;&#34;
    Returns the LaTeX names of the parameters of the Fisher object.
    &#34;&#34;&#34;
    return self._latex_names</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.names"><code class="name">var <span class="ident">names</span></code></dt>
<dd>
<div class="desc"><p>Returns the parameter names of the Fisher object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def names(self):
    &#34;&#34;&#34;
    Returns the parameter names of the Fisher object.
    &#34;&#34;&#34;
    return self._names</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.ndim"><code class="name">var <span class="ident">ndim</span></code></dt>
<dd>
<div class="desc"><p>Returns the number of dimensions of the Fisher object (for now always 2).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ndim(self):
    &#34;&#34;&#34;
    Returns the number of dimensions of the Fisher object (for now always 2).
    &#34;&#34;&#34;
    return np.ndim(self._values)</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>Returns the values in the Fisher object as a numpy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self):
    &#34;&#34;&#34;
    Returns the values in the Fisher object as a numpy array.
    &#34;&#34;&#34;
    return self._values</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fitk.fisher_matrix.FisherMatrix.condition_number"><code class="name flex">
<span>def <span class="ident">condition_number</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the condition number of the matrix with respect to the <span><span class="MathJax_Preview">L^2</span><script type="math/tex">L^2</script></span> norm.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 3]))
&gt;&gt;&gt; fm.condition_number()
3.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def condition_number(self):
    r&#34;&#34;&#34;
    Returns the condition number of the matrix with respect to the \(L^2\) norm.

    Examples
    --------
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 3]))
    &gt;&gt;&gt; fm.condition_number()
    3.0
    &#34;&#34;&#34;
    values = np.abs(self.eigenvalues())
    return np.max(values) / np.min(values)</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.constraints"><code class="name flex">
<span>def <span class="ident">constraints</span></span>(<span>self, name:Optional[str]=None, marginalized:bool=True, sigma:Optional[float]=None, p:Optional[float]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the constraints on a parameter as a float, or on all of them
as a numpy array if <code>name</code> is not specified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>Optional[str] = None</code></dt>
<dd>the name of the parameter for which we we want the constraints</dd>
<dt><strong><code>marginalized</code></strong> :&ensp;<code>bool</code>, default <code>= True</code></dt>
<dd>whether we want the marginalized or the unmarginalized
constraints.</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>Optional[float]</code>, default <code>= None</code></dt>
<dd>how many sigmas away.</dd>
<dt><strong><code>p</code></strong> :&ensp;<code>Optional[float]</code>, default <code>= None</code></dt>
<dd>the confidence interval (p-value).
The relationship between <code>p</code> and <code>sigma</code> is defined via:
<span><span class="MathJax_Preview">
p(\sigma) = \int\limits_{\mu - \sigma}^{\mu + \sigma}
f(x, \mu, 1)\, \mathrm{d}x
= \mathrm{Erf}(\sigma / \sqrt{2})
</span><script type="math/tex; mode=display">
p(\sigma) = \int\limits_{\mu - \sigma}^{\mu + \sigma}
f(x, \mu, 1)\, \mathrm{d}x
= \mathrm{Erf}(\sigma / \sqrt{2})
</script></span>
and therefore the inverse is simply:
<span><span class="MathJax_Preview">
\sigma(p) = \sqrt{2}\, \mathrm{Erf}^{-1}(p)
</span><script type="math/tex; mode=display">
\sigma(p) = \sqrt{2}\, \mathrm{Erf}^{-1}(p)
</script></span>
The values of <code>p</code> corresponding to 1, 2, 3 <code>sigma</code> are roughly
0.683, 0.954, and 0.997, respectively.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array-like</code> of <code>floats</code> or <code>single float</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The user should specify either <code>sigma</code> or <code>p</code>, but not both
simultaneously.
If neither are specified, defaults to <code>sigma=1</code>.</p>
<h2 id="examples">Examples</h2>
<p>Get (marginalized by default) constraints for all parameters:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; m = FisherMatrix([[3, -2], [-2, 5]])
&gt;&gt;&gt; m.constraints()
array([0.67419986, 0.52223297])
</code></pre>
<p>Get the unmarginalized constraints instead:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; m.constraints(marginalized=False)
array([0.57735027, 0.4472136 ])
</code></pre>
<p>Get the unmarginalized constraints for a single parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; m.constraints('p1', marginalized=False)
array([0.57735027])
</code></pre>
<p>Get the marginalized constraints for a single parameter:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; m.constraints('p1', p=0.682689) # p-value roughly equal to 1 sigma
array([0.67419918])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constraints(
    self,
    name : Optional[str] = None,
    marginalized : bool = True,
    sigma : Optional[float] = None,
    p : Optional[float] = None,
):
    r&#34;&#34;&#34;
    Returns the constraints on a parameter as a float, or on all of them
    as a numpy array if `name` is not specified.

    Parameters
    ----------
    name : Optional[str] = None
        the name of the parameter for which we we want the constraints

    marginalized : bool, default = True
        whether we want the marginalized or the unmarginalized
        constraints.

    sigma : Optional[float], default = None
        how many sigmas away.

    p : Optional[float], default = None
        the confidence interval (p-value).
        The relationship between `p` and `sigma` is defined via:
        \[
            p(\sigma) = \int\limits_{\mu - \sigma}^{\mu + \sigma}
                        f(x, \mu, 1)\, \mathrm{d}x
                      = \mathrm{Erf}(\sigma / \sqrt{2})
        \]
        and therefore the inverse is simply:
        \[
            \sigma(p) = \sqrt{2}\, \mathrm{Erf}^{-1}(p)
        \]
        The values of `p` corresponding to 1, 2, 3 `sigma` are roughly
        0.683, 0.954, and 0.997, respectively.

    Returns
    -------
    array-like of floats or single float

    Notes
    -----
    The user should specify either `sigma` or `p`, but not both
    simultaneously.
    If neither are specified, defaults to `sigma=1`.

    Examples
    --------
    Get (marginalized by default) constraints for all parameters:
    &gt;&gt;&gt; m = FisherMatrix([[3, -2], [-2, 5]])
    &gt;&gt;&gt; m.constraints()
    array([0.67419986, 0.52223297])

    Get the unmarginalized constraints instead:
    &gt;&gt;&gt; m.constraints(marginalized=False)
    array([0.57735027, 0.4472136 ])

    Get the unmarginalized constraints for a single parameter:
    &gt;&gt;&gt; m.constraints(&#39;p1&#39;, marginalized=False)
    array([0.57735027])

    Get the marginalized constraints for a single parameter:
    &gt;&gt;&gt; m.constraints(&#39;p1&#39;, p=0.682689) # p-value roughly equal to 1 sigma
    array([0.67419918])
    &#34;&#34;&#34;
    if sigma is not None and p is not None:
        raise ValueError(
            &#39;Cannot specify both `p` and `sigma` simultaneously&#39;
        )

    if p is not None:
        if not 0 &lt; p &lt; 1:
            raise ValueError(
                f&#39;The value of `p` {p} is outside of the allowed range (0, 1)&#39;
            )
        sigma = np.sqrt(2) * erfinv(p)
    elif sigma is None:
        sigma = 1

    if sigma &lt;= 0:
        raise ValueError(
            f&#39;The value of `sigma` {sigma} is outside of the allowed range (0, infinify)&#39;
        )

    if marginalized:
        inv = self.inverse()
        result = np.sqrt(np.diag(inv.values)) * sigma
    else:
        result = 1. / np.sqrt(np.diag(self.values)) * sigma

    if name is not None:
        if name in self.names:
            return result[np.where(self.names == name)]
        raise ParameterNotFoundError(name, self.names)

    return result</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.determinant"><code class="name flex">
<span>def <span class="ident">determinant</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the determinant of the matrix.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determinant(self):
    &#34;&#34;&#34;
    Returns the determinant of the matrix.

    Returns
    -------
    float
    &#34;&#34;&#34;
    return np.linalg.det(self.values)</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.diagonal"><code class="name flex">
<span>def <span class="ident">diagonal</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the diagonal elements of the Fisher object as a numpy array.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array-like</code> of <code>floats</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagonal(self, **kwargs):
    &#34;&#34;&#34;
    Returns the diagonal elements of the Fisher object as a numpy array.

    Returns
    -------
    array-like of floats
    &#34;&#34;&#34;
    return np.diag(self.values, **kwargs)</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.drop"><code class="name flex">
<span>def <span class="ident">drop</span></span>(<span>self, *names:str, invert:bool=False, ignore_errors:bool=False) ><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></span>
</code></dt>
<dd>
<div class="desc"><p>Removes parameters from the Fisher object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>string-like</code></dt>
<dd>the names of the parameters to drop.
If passing a list or a tuple, make sure to unpack it using the
asterisk (*).</dd>
<dt><strong><code>invert</code></strong> :&ensp;<code>bool</code>, default <code>= False</code></dt>
<dd>whether to drop all the parameters NOT in names (the complement)</dd>
<dt><strong><code>ignore_errors</code></strong> :&ensp;<code>bool</code>, default <code>= False</code></dt>
<dd>should non-existing parameters be ignored</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Instance of <code><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></code></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
&gt;&gt;&gt; m.drop('p1', 'p3')
FisherMatrix(array([[2.]]), names=array(['p2'], dtype=object), latex_names=array(['p2'], dtype=object), fiducial=array([0.]))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop(
    self,
    *names : str,
    invert : bool = False,
    ignore_errors : bool = False,
) -&gt; FisherMatrix:
    &#34;&#34;&#34;
    Removes parameters from the Fisher object.

    Parameters
    ----------
    names : string-like
        the names of the parameters to drop.
        If passing a list or a tuple, make sure to unpack it using the
        asterisk (*).

    invert : bool, default = False
        whether to drop all the parameters NOT in names (the complement)

    ignore_errors : bool, default = False
        should non-existing parameters be ignored

    Returns
    -------
    Instance of `FisherMatrix`

    Examples
    --------
    &gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
    &gt;&gt;&gt; m.drop(&#39;p1&#39;, &#39;p3&#39;)
    FisherMatrix(array([[2.]]), names=array([&#39;p2&#39;], dtype=object), latex_names=array([&#39;p2&#39;], dtype=object), fiducial=array([0.]))
    &#34;&#34;&#34;
    if not ignore_errors and not set(names).issubset(set(self.names)):
        raise ValueError(
            f&#39;The names ({list(names)}) are not a strict subset &#39; \
            f&#39;of the parameter names in the Fisher object ({self.names}); &#39; \
            &#39;you can pass `ignore_errors=True` to ignore this error&#39;
        )

    if ignore_errors:
        names = np.array([name for name in names if name in self.names])

    if invert is True:
        names = set(names) ^ set(self.names)

    # TODO should we remove this?
    if set(names) == set(self.names):
        raise ValueError(&#39;Unable to remove all parameters&#39;)

    index = [np.array(np.where(self.names == name), dtype=int) for name in names]

    values = self.values
    for dim in range(self.ndim):
        values = np.delete(
            values,
            index,
            axis=dim,
        )

    fiducial = np.delete(self.fiducial, index)
    latex_names = np.delete(self.latex_names, index)
    names = np.delete(self.names, index)

    return self.__class__(
        values,
        names=names,
        latex_names=latex_names,
        fiducial=fiducial,
    )</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.eigenvalues"><code class="name flex">
<span>def <span class="ident">eigenvalues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the eigenvalues of the Fisher object as a numpy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eigenvalues(self):
    &#34;&#34;&#34;
    Returns the eigenvalues of the Fisher object as a numpy array.
    &#34;&#34;&#34;
    return np.linalg.eigvalsh(self.values)</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.eigenvectors"><code class="name flex">
<span>def <span class="ident">eigenvectors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the right eigenvectors of the Fisher object as a numpy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eigenvectors(self):
    &#34;&#34;&#34;
    Returns the right eigenvectors of the Fisher object as a numpy array.
    &#34;&#34;&#34;
    return np.linalg.eigh(self.values)[-1]</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.imshow"><code class="name flex">
<span>def <span class="ident">imshow</span></span>(<span>self, colorbar:bool=False, show_values:bool=False, normalized:bool=False, colorbar_space:float=0.02, colorbar_width:float=0.05, colorbar_orientation:str='vertical', rc:abc.Mapping={'mathtext.fontset': 'cm', 'font.family': 'serif'}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the image of the Fisher object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imshow(
    self,
    colorbar : bool = False,
    show_values : bool = False,
    normalized : bool = False,
    colorbar_space : float = 0.02,
    colorbar_width : float = 0.05,
    colorbar_orientation : str = &#39;vertical&#39;,
    rc : abc.Mapping = get_default_rcparams(),
    **kwargs,
):
    &#34;&#34;&#34;
    Returns the image of the Fisher object.
    &#34;&#34;&#34;
    # TODO should only work with 2D data.
    with plt.rc_context(rc):
        fig, ax = plt.subplots(figsize=(len(self), len(self)))
        img = ax.imshow(
            self.values,
            interpolation=&#39;none&#39;,
            norm=colors.CenteredNorm(),
            **kwargs,
        )

        ax.set_xticks(np.arange(len(self)))
        ax.set_yticks(np.arange(len(self)))
        ax.set_xticklabels(self.latex_names)
        ax.set_yticklabels(self.latex_names)

        if colorbar:
            allowed_orientations = (&#39;vertical&#39;, &#39;horizontal&#39;)
            if colorbar_orientation not in allowed_orientations:
                raise ValueError(
                    f&#39;\&#39;{colorbar_orientation}\&#39; is not one of: {allowed_orientations}&#39;
                )

            if colorbar_orientation == &#39;vertical&#39;:
                cax = fig.add_axes(
                    [ax.get_position().x1 + colorbar_space,
                    ax.get_position().y0 * 0.997,
                    colorbar_width,
                    ax.get_position().height]
                )
                fig.colorbar(img, cax=cax, orientation=colorbar_orientation)
                cax.set_yticklabels(
                    [f&#39;${float_to_latex(_)}$&#39; for _ in cax.get_yticks()]
                )
            else:
                cax = fig.add_axes(
                    [ax.get_position().x0,
                    ax.get_position().y1 + colorbar_space,
                    ax.get_position().width,
                    colorbar_width]
                )
                fig.colorbar(img, cax=cax, orientation=colorbar_orientation)
                cax.xaxis.set_ticks_position(&#39;top&#39;)
                cax.set_xticklabels(
                    [f&#39;${float_to_latex(_)}$&#39; for _ in cax.get_xticks()]
                )

        # whether or not we want to display the actual values inside the
        # matrix
        if show_values:
            mid_coords = np.arange(len(self))
            for index1, index2 in product(range(len(self)), range(len(self))):
                x = mid_coords[index1]
                y = mid_coords[index2]
                value = self.values[index1, index2] / \
                    np.sqrt(
                        self.values[index1, index1] \
                       *self.values[index2, index2]
                    ) if normalized \
                    else self.values[index1, index2]
                text = ax.text(
                        x, y, f&#39;${float_to_latex(value)}$&#39;,
                        ha=&#39;center&#39;, va=&#39;center&#39;, color=&#39;white&#39;,
                )
                text.set_path_effects(
                    [Stroke(linewidth=1, foreground=&#34;black&#34;), Normal()]
                )

    return fig</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.inverse"><code class="name flex">
<span>def <span class="ident">inverse</span></span>(<span>self) ><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the inverse of the Fisher matrix.</p>
<h2 id="returns">Returns</h2>
<p>Instance of <code><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></code></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 5]))
&gt;&gt;&gt; fm.inverse()
FisherMatrix(array([[1. , 0. , 0. ],
       [0. , 0.5, 0. ],
       [0. , 0. , 0.2]]), names=array(['p1', 'p2', 'p3'], dtype=object), latex_names=array(['p1', 'p2', 'p3'], dtype=object), fiducial=array([0., 0., 0.]))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inverse(self) -&gt; FisherMatrix:
    &#34;&#34;&#34;
    Returns the inverse of the Fisher matrix.

    Returns
    -------
    Instance of `FisherMatrix`

    Examples
    --------
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2, 5]))
    &gt;&gt;&gt; fm.inverse()
    FisherMatrix(array([[1. , 0. , 0. ],
           [0. , 0.5, 0. ],
           [0. , 0. , 0.2]]), names=array([&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;], dtype=object), latex_names=array([&#39;p1&#39;, &#39;p2&#39;, &#39;p3&#39;], dtype=object), fiducial=array([0., 0., 0.]))
    &#34;&#34;&#34;
    # inverse satisfies properties of Fisher matrix, see:
    # https://math.stackexchange.com/a/26200
    return self.__class__(
        np.linalg.inv(self.values),
        names=self.names,
        latex_names=self.latex_names,
        fiducial=self.fiducial,
    )</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.is_diagonal"><code class="name flex">
<span>def <span class="ident">is_diagonal</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the Fisher matrix is diagonal.</p>
<h2 id="returns">Returns</h2>
<p><code>True</code> or <code>False</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_diagonal(self):
    &#34;&#34;&#34;
    Checks whether the Fisher matrix is diagonal.

    Returns
    -------
    `True` or `False`
    &#34;&#34;&#34;
    return np.all(self.values == np.diag(np.diagonal(self.values)))</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.is_valid"><code class="name flex">
<span>def <span class="ident">is_valid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the values make a valid Fisher object.
A (square) matrix is a Fisher matrix if it satisifies the following two
criteria:</p>
<ul>
<li>it is symmetric</li>
<li>it is positive semi-definite</li>
</ul>
<h2 id="returns">Returns</h2>
<p><code>True</code> or <code>False</code></p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
&gt;&gt;&gt; m.is_valid()
True
&gt;&gt;&gt; FisherMatrix(np.diag([-1, 3])).is_valid()
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid(self):
    &#34;&#34;&#34;
    Checks whether the values make a valid Fisher object.
    A (square) matrix is a Fisher matrix if it satisifies the following two
    criteria:

    * it is symmetric
    * it is positive semi-definite

    Returns
    -------
    `True` or `False`

    Examples
    --------
    &gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
    &gt;&gt;&gt; m.is_valid()
    True
    &gt;&gt;&gt; FisherMatrix(np.diag([-1, 3])).is_valid()
    False
    &#34;&#34;&#34;
    return \
        is_symmetric(self.values) and \
        is_positive_semidefinite(self.values)</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.marginalize_over"><code class="name flex">
<span>def <span class="ident">marginalize_over</span></span>(<span>self, *names:str, invert:bool=False, ignore_errors:bool=False) ><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></span>
</code></dt>
<dd>
<div class="desc"><p>Perform marginalization over some parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>str</code></dt>
<dd>the names of the parameters to marginalize over</dd>
<dt><strong><code>invert</code></strong> :&ensp;<code>bool</code>, default <code>= False</code></dt>
<dd>whether to marginalize over all the parameters NOT in names (the complement)</dd>
<dt><strong><code>ignore_errors</code></strong> :&ensp;<code>bool</code>, default <code>= False</code></dt>
<dd>should non-existing parameters be ignored</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Instance of <code><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></code>.</p>
<h2 id="examples">Examples</h2>
<p>Generate a Fisher object using a random orthogonal matrix:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from scipy.stats import ortho_group
&gt;&gt;&gt; rm = ortho_group.rvs(5, random_state=12345)
&gt;&gt;&gt; fm = FisherMatrix(rm.T @ np.diag([1, 2, 3, 7, 6]) @ rm)
</code></pre>
<p>Marginalize over some parameters:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm.marginalize_over('p1', 'p2')
FisherMatrix(array([[ 1.67715591, -1.01556085,  0.30020773],
       [-1.01556085,  4.92788976,  0.91219831],
       [ 0.30020773,  0.91219831,  3.1796454 ]]), names=array(['p3', 'p4', 'p5'], dtype=object), latex_names=array(['p3', 'p4', 'p5'], dtype=object), fiducial=array([0., 0., 0.]))
</code></pre>
<p>Marginalize over all parameters which are NOT <code>p1</code> or <code>p2</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm.marginalize_over('p1', 'p2', invert=True)
FisherMatrix(array([[ 5.04480062, -0.04490453],
       [-0.04490453,  1.61599083]]), names=array(['p1', 'p2'], dtype=object), latex_names=array(['p1', 'p2'], dtype=object), fiducial=array([0., 0.]))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def marginalize_over(
    self,
    *names : str,
    invert : bool = False,
    ignore_errors : bool = False,
) -&gt; FisherMatrix:
    &#34;&#34;&#34;
    Perform marginalization over some parameters.

    Parameters
    ----------
    names : str
        the names of the parameters to marginalize over

    invert : bool, default = False
        whether to marginalize over all the parameters NOT in names (the complement)

    ignore_errors : bool, default = False
        should non-existing parameters be ignored

    Returns
    -------
    Instance of `FisherMatrix`.

    Examples
    --------
    Generate a Fisher object using a random orthogonal matrix:
    &gt;&gt;&gt; from scipy.stats import ortho_group
    &gt;&gt;&gt; rm = ortho_group.rvs(5, random_state=12345)
    &gt;&gt;&gt; fm = FisherMatrix(rm.T @ np.diag([1, 2, 3, 7, 6]) @ rm)

    Marginalize over some parameters:
    &gt;&gt;&gt; fm.marginalize_over(&#39;p1&#39;, &#39;p2&#39;)
    FisherMatrix(array([[ 1.67715591, -1.01556085,  0.30020773],
           [-1.01556085,  4.92788976,  0.91219831],
           [ 0.30020773,  0.91219831,  3.1796454 ]]), names=array([&#39;p3&#39;, &#39;p4&#39;, &#39;p5&#39;], dtype=object), latex_names=array([&#39;p3&#39;, &#39;p4&#39;, &#39;p5&#39;], dtype=object), fiducial=array([0., 0., 0.]))

    Marginalize over all parameters which are NOT `p1` or `p2`:
    &gt;&gt;&gt; fm.marginalize_over(&#39;p1&#39;, &#39;p2&#39;, invert=True)
    FisherMatrix(array([[ 5.04480062, -0.04490453],
           [-0.04490453,  1.61599083]]), names=array([&#39;p1&#39;, &#39;p2&#39;], dtype=object), latex_names=array([&#39;p1&#39;, &#39;p2&#39;], dtype=object), fiducial=array([0., 0.]))
    &#34;&#34;&#34;
    inv = self.inverse()
    if invert is True:
        names = set(names) ^ set(self.names)
    fm = inv.drop(*names, ignore_errors=ignore_errors)
    return fm.inverse()</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, names:Mapping[str,Union[str,abc.Mapping]], ignore_errors:bool=False) ><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a Fisher object with new names.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>Mapping[str, Union[str, abc.Mapping]]</code></dt>
<dd>a mapping (dictionary-like object) between the old names and the
new ones. The values it maps to can either be a string (the new name), or a dict
with keys <code>name</code>, <code>latex_name</code>, and <code>fiducial</code> (only <code>name</code> is mandatory).</dd>
<dt><strong><code>ignore_errors</code></strong> :&ensp;<code>bool</code>, default <code>= False</code></dt>
<dd>if set to True, will not raise an error if a parameter doesn't exist</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Instance of <code><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
&gt;&gt;&gt; m.rename({'p1' : 'a', 'p2' : dict(name='b', latex_name='$b$', fiducial=2)})
FisherMatrix(array([[1., 0., 0.],
       [0., 2., 0.],
       [0., 0., 3.]]), names=array(['a', 'b', 'p3'], dtype=object), latex_names=array(['a', '$b$', 'p3'], dtype=object), fiducial=array([0., 2., 0.]))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename(
    self,
    names : Mapping[str, Union[str, abc.Mapping]],
    ignore_errors : bool = False,
) -&gt; FisherMatrix:
    &#34;&#34;&#34;
    Returns a Fisher object with new names.

    Parameters
    ----------
    names : Mapping[str, Union[str, abc.Mapping]]
        a mapping (dictionary-like object) between the old names and the
        new ones. The values it maps to can either be a string (the new name), or a dict
        with keys `name`, `latex_name`, and `fiducial` (only `name` is mandatory).

    ignore_errors : bool, default = False
        if set to True, will not raise an error if a parameter doesn&#39;t exist

    Returns
    -------
    Instance of `FisherMatrix`.

    Examples
    --------
    &gt;&gt;&gt; m = FisherMatrix(np.diag([1, 2, 3]))
    &gt;&gt;&gt; m.rename({&#39;p1&#39; : &#39;a&#39;, &#39;p2&#39; : dict(name=&#39;b&#39;, latex_name=&#39;$b$&#39;, fiducial=2)})
    FisherMatrix(array([[1., 0., 0.],
           [0., 2., 0.],
           [0., 0., 3.]]), names=array([&#39;a&#39;, &#39;b&#39;, &#39;p3&#39;], dtype=object), latex_names=array([&#39;a&#39;, &#39;$b$&#39;, &#39;p3&#39;], dtype=object), fiducial=array([0., 2., 0.]))
    &#34;&#34;&#34;
    # check uniqueness and size
    if len(set(names)) != len(names):
        raise MismatchingSizeError(set(names), names)

    if not ignore_errors:
        for name in names:
            if name not in self.names:
                raise ParameterNotFoundError(name, self.names)

    names_new = copy.deepcopy(self.names)
    latex_names_new = copy.deepcopy(self.latex_names)
    fiducial_new = copy.deepcopy(self.fiducial)

    for name, value in names.items():
        index = np.where(names_new == name)
        # it&#39;s a mapping
        if isinstance(value, abc.Mapping):
            value = _process_fisher_mapping(value)
            latex_names_new[index] = value[&#39;latex_name&#39;]
            fiducial_new[index] = value[&#39;fiducial&#39;]
            names_new[index] = value[&#39;name&#39;]
        # otherwise, it&#39;s a string
        else:
            names_new[index] = value
            latex_names_new[index] = value

    return self.__class__(
        self.values,
        names=names_new,
        latex_names=latex_names_new,
        fiducial=fiducial_new,
    )</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.reparametrize"><code class="name flex">
<span>def <span class="ident">reparametrize</span></span>(<span>self, jacobian:Collection, names:Optional[Collection[str]]=None, latex_names:Optional[Collection[str]]=None, fiducial:Optional[Collection[float]]=None) ><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new Fisher object with parameters <code>names</code>, which are
related to the old ones via the transformation <code>jacobian</code>.
See the <a href="https://en.wikipedia.org/w/index.php?title=Fisher_information&amp;oldid=1063384000#Reparametrization">Wikipedia article</a> for more information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transformation</code></strong> :&ensp;<code>array-like</code></dt>
<dd>the Jacobian of the transformation</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>array-like</code>, default <code>= None</code></dt>
<dd>list of new names for the Fisher object. If None, uses the old
names.</dd>
<dt><strong><code>latex_names</code></strong> :&ensp;<code>array-like</code>, default <code>= None</code></dt>
<dd>list of new LaTeX names for the Fisher object. If None, and
<code>names</code> is set, uses those instead, otherwise uses the old LaTeX names.</dd>
<dt><strong><code>fiducial</code></strong> :&ensp;<code>array-like</code>, default <code>= None</code></dt>
<dd>the new values of the fiducial. If not set, defaults to old values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Instance of <code><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2]))
&gt;&gt;&gt; jac = [[1, 4], [3, 2]]
&gt;&gt;&gt; fm.reparametrize(jac, names=['a', 'b'])
FisherMatrix(array([[19., 16.],
       [16., 24.]]), names=array(['a', 'b'], dtype=object), latex_names=array(['a', 'b'], dtype=object), fiducial=array([0., 0.]))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reparametrize(
    self,
    jacobian : Collection,
    names : Optional[Collection[str]] = None,
    latex_names : Optional[Collection[str]] = None,
    fiducial : Optional[Collection[float]] = None,
) -&gt; FisherMatrix:
    &#34;&#34;&#34;
    Returns a new Fisher object with parameters `names`, which are
    related to the old ones via the transformation `jacobian`.
    See the [Wikipedia article](https://en.wikipedia.org/w/index.php?title=Fisher_information&amp;oldid=1063384000#Reparametrization) for more information.

    Parameters
    ----------
    transformation : array-like
        the Jacobian of the transformation

    names : array-like, default = None
        list of new names for the Fisher object. If None, uses the old
        names.

    latex_names: array-like, default = None
        list of new LaTeX names for the Fisher object. If None, and
        `names` is set, uses those instead, otherwise uses the old LaTeX names.

    fiducial : array-like, default = None
        the new values of the fiducial. If not set, defaults to old values.

    Returns
    -------
    Instance of `FisherMatrix`.

    Examples
    --------
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2]))
    &gt;&gt;&gt; jac = [[1, 4], [3, 2]]
    &gt;&gt;&gt; fm.reparametrize(jac, names=[&#39;a&#39;, &#39;b&#39;])
    FisherMatrix(array([[19., 16.],
           [16., 24.]]), names=array([&#39;a&#39;, &#39;b&#39;], dtype=object), latex_names=array([&#39;a&#39;, &#39;b&#39;], dtype=object), fiducial=array([0., 0.]))
    &#34;&#34;&#34;
    values = np.transpose(jacobian) @ self.values @ jacobian

    if names is not None:
        if len(set(names)) != np.shape(jacobian)[-1]:
            raise MismatchingSizeError(names)
        if latex_names is not None:
            if len(set(latex_names)) != np.shape(jacobian)[-1]:
                raise MismatchingSizeError(latex_names)
        else:
            latex_names = copy.deepcopy(names)
    else:
        # we don&#39;t transform the names
        names = copy.deepcopy(self.names)
        latex_names = copy.deepcopy(self.latex_names)

    if fiducial is not None:
        if len(fiducial) != np.shape(jacobian)[-1]:
            raise MismatchingSizeError(fiducial)
    else:
        fiducial = copy.deepcopy(self.fiducial)

    return self.__class__(
        values,
        names=names,
        latex_names=latex_names,
        fiducial=fiducial,
    )</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, **kwargs) ><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></span>
</code></dt>
<dd>
<div class="desc"><p>Sorts the Fisher object by name according to some criterion.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>all of the other keyword arguments for the Python builtin <code>sorted</code>.
If none are specified, will sort according to the names of the parameters.
In the special case that the value of the keyword <code>key</code> is set to
either 'fiducial' or 'latex_names', it will sort according to those.
In the second special case that the value of the keyword <code>key</code> is
set to an array of integers of equal size as the Fisher object, sorts them
according to those instead.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Instance of <code><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></code>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; m = FisherMatrix(np.diag([3, 1, 2]), names=list('sdf'),
... latex_names=['hjkl', 'qwe', 'll'], fiducial=[8, 7, 3])
&gt;&gt;&gt; m.sort(key='fiducial')
FisherMatrix(array([[2., 0., 0.],
       [0., 1., 0.],
       [0., 0., 3.]]), names=array(['f', 'd', 's'], dtype=object), latex_names=array(['ll', 'qwe', 'hjkl'], dtype=object), fiducial=array([3., 7., 8.]))
&gt;&gt;&gt; m.sort(key='latex_names')
FisherMatrix(array([[3., 0., 0.],
       [0., 2., 0.],
       [0., 0., 1.]]), names=array(['s', 'f', 'd'], dtype=object), latex_names=array(['hjkl', 'll', 'qwe'], dtype=object), fiducial=array([8., 3., 7.]))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(
    self,
    **kwargs,
) -&gt; FisherMatrix:
    &#34;&#34;&#34;
    Sorts the Fisher object by name according to some criterion.

    Parameters
    ----------
    **kwargs
        all of the other keyword arguments for the Python builtin `sorted`.
        If none are specified, will sort according to the names of the parameters.
        In the special case that the value of the keyword `key` is set to
        either &#39;fiducial&#39; or &#39;latex_names&#39;, it will sort according to those.
        In the second special case that the value of the keyword `key` is
        set to an array of integers of equal size as the Fisher object, sorts them
        according to those instead.

    Returns
    -------
    Instance of `FisherMatrix`.

    Examples
    --------
    &gt;&gt;&gt; m = FisherMatrix(np.diag([3, 1, 2]), names=list(&#39;sdf&#39;),
    ... latex_names=[&#39;hjkl&#39;, &#39;qwe&#39;, &#39;ll&#39;], fiducial=[8, 7, 3])
    &gt;&gt;&gt; m.sort(key=&#39;fiducial&#39;)
    FisherMatrix(array([[2., 0., 0.],
           [0., 1., 0.],
           [0., 0., 3.]]), names=array([&#39;f&#39;, &#39;d&#39;, &#39;s&#39;], dtype=object), latex_names=array([&#39;ll&#39;, &#39;qwe&#39;, &#39;hjkl&#39;], dtype=object), fiducial=array([3., 7., 8.]))
    &gt;&gt;&gt; m.sort(key=&#39;latex_names&#39;)
    FisherMatrix(array([[3., 0., 0.],
           [0., 2., 0.],
           [0., 0., 1.]]), names=array([&#39;s&#39;, &#39;f&#39;, &#39;d&#39;], dtype=object), latex_names=array([&#39;hjkl&#39;, &#39;ll&#39;, &#39;qwe&#39;], dtype=object), fiducial=array([8., 3., 7.]))
    &#34;&#34;&#34;
    allowed_keys = (&#39;fiducial&#39;, &#39;latex_names&#39;)
    # an integer index
    if &#39;key&#39; in kwargs and all(hasattr(_, &#39;__index__&#39;) for _ in kwargs[&#39;key&#39;]):
        index = np.array(kwargs[&#39;key&#39;], dtype=int)
        names = self.names[index]
    # either &#39;fiducial&#39; or &#39;latex_names&#39;
    elif &#39;key&#39; in kwargs and kwargs[&#39;key&#39;] in allowed_keys:
        index = np.argsort(getattr(self, kwargs[&#39;key&#39;]))
        if &#39;reversed&#39; in kwargs and kwargs[&#39;reversed&#39;] is True:
            index = np.flip(index)
        names = self.names[index]
    # something that can be passed to `sorted`
    else:
        names = sorted(self.names, **kwargs)
        index = get_index_of_other_array(self.names, names)

    latex_names = self.latex_names[index]
    fiducial = self.fiducial[index]
    values = reindex_array(self.values, index)

    return self.__class__(
        values,
        names=names,
        latex_names=latex_names,
        fiducial=fiducial,
    )</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.to_file"><code class="name flex">
<span>def <span class="ident">to_file</span></span>(<span>self, path:str, *args:str, metadata:dict={}, overwrite:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the Fisher object to a file.
The format used is a simple JSON file, containing at least the values of the
Fisher object, the names of the parameters, the LaTeX names, and the
fiducial values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path to save the data to.</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>str</code></dt>
<dd>whatever other information about the object needs to be saved.
Needs to be one of the following: <code>is_valid</code>, <code>eigenvalues</code>,
<code>eigenvectors</code>, <code>trace</code>, <code>determinant</code>, or <code>constraints</code> (by
default, the 1$\sigma$ marginalized constraints).</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code>, default <code>= {}</code></dt>
<dd>any metadata that should be associated to the object saved</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, default <code>= False</code></dt>
<dd>whether to overwrite the file if it exists</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The dictionary that was saved.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2]), names=['a', 'b'], latex_names=[r'$\mathbf{A}$', r'$\mathbf{B}$'])
&gt;&gt;&gt; fm.to_file('example_matrix.json', overwrite=True)
{'values': [[1.0, 0.0], [0.0, 2.0]], 'names': ['a', 'b'], 'latex_names': ['$\\mathbf{A}$', '$\\mathbf{B}$'], 'fiducial': [0.0, 0.0]}
&gt;&gt;&gt; fm_read = FisherMatrix.from_file('example_matrix.json') # convenience function for reading it
&gt;&gt;&gt; fm == fm_read # verify it's the same object
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_file(
    self,
    path : str,
    *args : str,
    metadata : dict = {},
    overwrite : bool = False,
):
    r&#34;&#34;&#34;
    Saves the Fisher object to a file.
    The format used is a simple JSON file, containing at least the values of the
    Fisher object, the names of the parameters, the LaTeX names, and the
    fiducial values.

    Parameters
    ----------
    path : str
        the path to save the data to.

    args : str
        whatever other information about the object needs to be saved.
        Needs to be one of the following: `is_valid`, `eigenvalues`,
        `eigenvectors`, `trace`, `determinant`, or `constraints` (by
        default, the 1$\sigma$ marginalized constraints).

    metadata : dict, default = {}
        any metadata that should be associated to the object saved

    overwrite : bool, default = False
        whether to overwrite the file if it exists

    Returns
    -------
    The dictionary that was saved.

    Examples
    --------
    &gt;&gt;&gt; fm = FisherMatrix(np.diag([1, 2]), names=[&#39;a&#39;, &#39;b&#39;], latex_names=[r&#39;$\mathbf{A}$&#39;, r&#39;$\mathbf{B}$&#39;])
    &gt;&gt;&gt; fm.to_file(&#39;example_matrix.json&#39;, overwrite=True)
    {&#39;values&#39;: [[1.0, 0.0], [0.0, 2.0]], &#39;names&#39;: [&#39;a&#39;, &#39;b&#39;], &#39;latex_names&#39;: [&#39;$\\mathbf{A}$&#39;, &#39;$\\mathbf{B}$&#39;], &#39;fiducial&#39;: [0.0, 0.0]}
    &gt;&gt;&gt; fm_read = FisherMatrix.from_file(&#39;example_matrix.json&#39;) # convenience function for reading it
    &gt;&gt;&gt; fm == fm_read # verify it&#39;s the same object
    True
    &#34;&#34;&#34;
    data = {
        &#39;values&#39; : self.values.tolist(),
        &#39;names&#39; : self.names.tolist(),
        &#39;latex_names&#39; : self.latex_names.tolist(),
        &#39;fiducial&#39; : self.fiducial.tolist(),
    }

    allowed_metadata = {
        &#39;is_valid&#39; : bool,
        &#39;eigenvalues&#39; : np.array,
        &#39;eigenvectors&#39; : np.array,
        &#39;trace&#39; : float,
        &#39;determinant&#39; : float,
        &#39;constraints&#39; : np.array,
    }

    for arg in args:
        if arg not in allowed_metadata:
            raise ValueError(
                f&#39;name {arg} is not one of {list(allowed_metadata.keys())}&#39;
            )

    for arg in metadata:
        if arg in data:
            raise ValueError(
                f&#39;name {arg} cannot be one of {list(data.keys())}&#39;
            )

    data = {
        **data,
        **{arg : jsonify(getattr(self, arg)()) for arg in args},
        **metadata,
    }

    if os.path.exists(path) and not overwrite:
        raise FileExistsError(
            f&#39;The file {path} already exists, please pass &#39; \
            &#39;`overwrite=True` if you wish to explicitly overwrite &#39;
            &#39;the file&#39;
        )

    with open(path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as file_handle:
        file_handle.write(json.dumps(data, indent=4))

    return data</code></pre>
</details>
</dd>
<dt id="fitk.fisher_matrix.FisherMatrix.trace"><code class="name flex">
<span>def <span class="ident">trace</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the trace of the Fisher object as a numpy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trace(
    self,
    **kwargs,
):
    &#34;&#34;&#34;
    Returns the trace of the Fisher object as a numpy array.
    &#34;&#34;&#34;
    return np.trace(self.values, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fitk" href="index.html">fitk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fitk.fisher_matrix.FisherMatrix" href="#fitk.fisher_matrix.FisherMatrix">FisherMatrix</a></code></h4>
<ul class="two-column">
<li><code><a title="fitk.fisher_matrix.FisherMatrix.condition_number" href="#fitk.fisher_matrix.FisherMatrix.condition_number">condition_number</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.constraints" href="#fitk.fisher_matrix.FisherMatrix.constraints">constraints</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.determinant" href="#fitk.fisher_matrix.FisherMatrix.determinant">determinant</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.diagonal" href="#fitk.fisher_matrix.FisherMatrix.diagonal">diagonal</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.drop" href="#fitk.fisher_matrix.FisherMatrix.drop">drop</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.eigenvalues" href="#fitk.fisher_matrix.FisherMatrix.eigenvalues">eigenvalues</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.eigenvectors" href="#fitk.fisher_matrix.FisherMatrix.eigenvectors">eigenvectors</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.fiducial" href="#fitk.fisher_matrix.FisherMatrix.fiducial">fiducial</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.from_file" href="#fitk.fisher_matrix.FisherMatrix.from_file">from_file</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.imshow" href="#fitk.fisher_matrix.FisherMatrix.imshow">imshow</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.inverse" href="#fitk.fisher_matrix.FisherMatrix.inverse">inverse</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.is_diagonal" href="#fitk.fisher_matrix.FisherMatrix.is_diagonal">is_diagonal</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.is_valid" href="#fitk.fisher_matrix.FisherMatrix.is_valid">is_valid</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.latex_names" href="#fitk.fisher_matrix.FisherMatrix.latex_names">latex_names</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.marginalize_over" href="#fitk.fisher_matrix.FisherMatrix.marginalize_over">marginalize_over</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.names" href="#fitk.fisher_matrix.FisherMatrix.names">names</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.ndim" href="#fitk.fisher_matrix.FisherMatrix.ndim">ndim</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.rename" href="#fitk.fisher_matrix.FisherMatrix.rename">rename</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.reparametrize" href="#fitk.fisher_matrix.FisherMatrix.reparametrize">reparametrize</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.sort" href="#fitk.fisher_matrix.FisherMatrix.sort">sort</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.to_file" href="#fitk.fisher_matrix.FisherMatrix.to_file">to_file</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.trace" href="#fitk.fisher_matrix.FisherMatrix.trace">trace</a></code></li>
<li><code><a title="fitk.fisher_matrix.FisherMatrix.values" href="#fitk.fisher_matrix.FisherMatrix.values">values</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>