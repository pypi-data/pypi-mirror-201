<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fitk.fisher_plotter API documentation</title>
<meta name="description" content="Package for plotting of Fisher objects.
See here for documentation of `FisherPlotter`, `FisherFigure1D`, and `FisherFigure2D`." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fitk.fisher_plotter</code></h1>
</header>
<section id="section-intro">
<p>Package for plotting of Fisher objects.
See here for documentation of <code><a title="fitk.fisher_plotter.FisherPlotter" href="#fitk.fisher_plotter.FisherPlotter">FisherPlotter</a></code>, <code><a title="fitk.fisher_plotter.FisherFigure1D" href="#fitk.fisher_plotter.FisherFigure1D">FisherFigure1D</a></code>, and <code><a title="fitk.fisher_plotter.FisherFigure2D" href="#fitk.fisher_plotter.FisherFigure2D">FisherFigure2D</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Package for plotting of Fisher objects.
See here for documentation of `FisherPlotter`, `FisherFigure1D`, and `FisherFigure2D`.
&#34;&#34;&#34;

from __future__ import annotations

# standard library imports
from abc import ABC, abstractmethod
from typing import \
    Collection, \
    Optional, \
    Tuple, \
    Union

# third party imports
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.transforms import Bbox
from matplotlib.axes import Axes
from matplotlib.patches import Ellipse
from scipy.stats import chi2, norm

# first party imports
from fitk.fisher_utils import \
    get_default_rcparams, \
    MismatchingSizeError, \
    ParameterNotFoundError, \
    is_iterable, \
    get_index_of_other_array, \
    float_to_latex
from fitk.fisher_matrix import FisherMatrix



class FisherBaseFigure(ABC):
    def __init__(
        self,
        figure : Figure,
        axes : Collection[Axes],
        names : Collection[str],
    ):
        &#34;&#34;&#34;
        Constructor.

        Parameters
        ----------
        figure : Figure
            the figure plotted by `FisherPlotter`

        axes : Collection[Axes]
            the axes of the above figure

        names : Collection[str]
            the names of the parameters that are plotted
        &#34;&#34;&#34;
        self._figure = figure
        self._axes = axes
        self._names = names


    @abstractmethod
    def __getitem__(self, key):
        &#34;&#34;&#34;
        Implements element access.
        &#34;&#34;&#34;
        pass


    @property
    def figure(self):
        &#34;&#34;&#34;
        Returns the underlying figure, an instance of `matplotlib.figure.Figure`.
        &#34;&#34;&#34;
        return self._figure


    @property
    def axes(self):
        &#34;&#34;&#34;
        Returns the axes of the figure as a numpy array.
        &#34;&#34;&#34;
        return self._axes


    @property
    def names(self):
        &#34;&#34;&#34;
        Returns the names of the parameters plotted.
        &#34;&#34;&#34;
        return self._names


    def savefig(
        self,
        path : str,
        dpi : float = 300,
        bbox_inches : Union[str, Bbox] = &#39;tight&#39;,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Convenience wrapper for `figure.savefig`.

        Parameters
        ----------
        path : str
            the path where to save the figure

        dpi : float, default = 300
            the resolution of the saved figure

        bbox_inches : Union[str, Bbox], default = &#39;tight&#39;
            what is the bounding box for the figure

        kwargs
            any other keyword arguments that should be passed to `figure.savefig`
        &#34;&#34;&#34;
        return self.figure.savefig(path, dpi=dpi, bbox_inches=bbox_inches, **kwargs)



class FisherFigure1D(FisherBaseFigure):
    &#34;&#34;&#34;
    Container for easy access to elements in the 1D plot.
    &#34;&#34;&#34;
    def __getitem__(
        self,
        key : str,
    ):
        &#34;&#34;&#34;
        Returns the axis associated to the name `key`.
        &#34;&#34;&#34;
        if key not in self.names:
            raise ParameterNotFoundError(key, self.names)

        return self.axes.flat[np.where(self.names == key)][0]



class FisherFigure2D(FisherBaseFigure):
    &#34;&#34;&#34;
    Container for easy access to elements in the 2D plot.
    &#34;&#34;&#34;
    def __getitem__(
        self,
        key : Tuple[str],
    ):
        pass



class FisherPlotter:
    &#34;&#34;&#34;
    Class for plotting FisherMatrix objects.
    &#34;&#34;&#34;
    def __init__(
        self,
        *args : FisherMatrix,
        labels : Optional[Collection[str]] = None,
    ):
        &#34;&#34;&#34;
        Constructor.

        Parameters
        ----------
        args : FisherMatrix
            `FisherMatrix` objects which we want to plot.
            Must have the same names, otherwise throws an error.
            Can have different fiducial values.
            The order of plotting of the parameters and the LaTeX labels to use
            are determined by the first argument.

        labels : array of strings, default None
            the list of labels to put in the legend of the plots.
            If not set, defaults to `0, ..., len(args) - 1`
        &#34;&#34;&#34;
        # make sure all of the Fisher objects have the same sizes
        if not all(len(args[0]) == len(arg) for arg in args):
            raise MismatchingSizeError(*args)

        # check names
        if not all(set(args[0].names) == set(arg.names) for arg in args):
            raise ValueError(
                &#39;The names of the inputs do not match&#39;
            )

        if labels is not None:
            if len(labels) != len(args):
                raise MismatchingSizeError(labels, args)
        else:
            labels = list(map(str, np.arange(len(args))))

        # in case the names are shuffled, we sort them according to the FIRST
        # input
        indices = np.array(
            [get_index_of_other_array(args[0].names, arg.names) for arg in args],
            dtype=object,
        )

        self._values = [arg.sort(key=index) for index, arg in zip(indices, args)]

        self._labels = np.array(labels, dtype=object)


    @property
    def values(self):
        &#34;&#34;&#34;
        Returns the input array of Fisher objects.
        &#34;&#34;&#34;
        return self._values


    @property
    def labels(self):
        &#34;&#34;&#34;
        Returns the labels of the Fisher objects.
        &#34;&#34;&#34;
        return self._labels


    def find_limits_1d(
        self,
        name : str,
        sigma : float = 3,
    ):
        &#34;&#34;&#34;
        Finds &#34;nice&#34; 1D limits for a given parameter taking into account fiducials
        and constraints.

        Parameters
        ----------
        name : str
            the name of the parameter

        sigma : float, default = 3
            how many sigmas away to plot

        Returns
        -------
        `tuple` with lower and upper limits
        &#34;&#34;&#34;
        sigmas = np.array(
            [_.constraints(name, marginalized=True, sigma=sigma) for _ in self.values]
        )
        fiducial = np.array(
            [_.fiducial[np.where(_.names == name)] for _ in self.values]
        )

        xleft, xright = np.min(fiducial - sigmas), np.max(fiducial + sigmas)

        return xleft, xright


    def plot_1d(
        self,
        max_cols : Optional[int] = None,
        rc : dict = get_default_rcparams(),
        **kwargs,
    ):
        &#34;&#34;&#34;
        Makes a 1D plot (Gaussians) of the Fisher objects and returns a
        `FisherFigure1D`.

        Parameters
        ----------
        max_cols : Optional[int], default = None
            the maximum number of columns to force the plot into.
            By default, the parameters are always plotted horizontally; if you
            need to spread it over `max_cols`, pass a non-negative integer
            here.

        rc : dict = get_default_rcparams()
            any parameters meant for `matplotlib.rcParams`.
            See [Matplotlib documentation](https://matplotlib.org/stable/tutorials/introductory/customizing.html)
            for more information.

        Returns
        -------
        An instance of `FisherFigure1D`.
        &#34;&#34;&#34;
        size = len(self.values[0])

        if max_cols is not None and max_cols &lt;= size:
            full = size % max_cols == 0
            layout = size // max_cols if full else size // max_cols + 1, max_cols
        else:
            layout = 1, size
            full = True

        with plt.rc_context(rc):
            # general figure setup
            fig = plt.figure(clear=True, figsize=(2 * layout[1], 2 * layout[0]))
            gs = fig.add_gridspec(
                nrows=layout[0], ncols=layout[1],
                hspace=0.5, wspace=0.1,
            )
            axes = gs.subplots()
            if size == 1:
                axes = np.array([axes])

            names = self.values[0].names
            latex_names = self.values[0].latex_names

            ylabel1d = r&#39;$p (\theta)$&#39;

            handles = []

            for (index, name), name_latex in zip(enumerate(names), latex_names):
                ax = axes.flat[index]
                title_list = [
                    &#39;{0} = ${1}^{{+{2}}}_{{-{2}}}$&#39;.format(
                    name_latex,
                    float_to_latex(float(_.fiducial[np.where(_.names == name)])),
                    float_to_latex(float(_.constraints(name, marginalized=True))),
                ) for _ in self.values
                ]

                # the scaling factor here is so that we don&#39;t cutoff the peak
                ymax = np.max(
                    [gaussian(0, 0, _.constraints(name, marginalized=True)) for _ in self.values]
                ) * 1.03

                for fm in self.values:
                    handle, = add_plot_1d(
                        fm.fiducial[np.where(fm.names == name)],
                        fm.constraints(name, marginalized=True),
                        ax,
                    )

                    if index == 0:
                        handles.append(handle)

                ax.set_xlabel(name_latex)
                ax.set_xlim(*self.find_limits_1d(name))
                ax.set_ylim(0, ymax)

                if kwargs.get(&#39;title&#39;) is True:
                    ax.set_title(&#39;\n&#39;.join(title_list))

                if index == 0:
                    ax.set_ylabel(ylabel1d)

                ax.set_yticks([])

            if kwargs.get(&#39;legend&#39;) is True:
                fig.legend(
                    np.array(handles, dtype=object),
                    self.labels,
                    frameon=False,
                    loc=&#39;upper center&#39;,
                    bbox_to_anchor=(0.5, -0.15),
                    ncol=len(self.values),
                )

            if isinstance(kwargs.get(&#39;title&#39;), str):
                fig.suptitle(kwargs.get(&#39;title&#39;))

            # remove any axes which are not drawn
            if not full:
                for index in range(
                    (layout[0] - 1) * layout[1] + 1,
                    layout[0] * layout[1]
                ):
                    axes.flat[index].remove()

        return FisherFigure1D(fig, axes, names)


    def plot_2d(
        self,
        rc : dict = get_default_rcparams(),
        **kwargs,
    ):
        &#34;&#34;&#34;
        Plots the 2D ellipses (and optionally 1D Gaussians) of the Fisher
        objects, and returns an instance of `FisherFigure2D`.
        &#34;&#34;&#34;
        pass


    def plot_triangle(
        self,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Plots the 2D ellipses and 1D Gaussians of the Fisher objects, and
        returns an instance of `FisherFigure2D`.
        &#34;&#34;&#34;
        pass



def gaussian(
    x : float,
    mu : float = 0,
    sigma : float = 1,
):
    &#34;&#34;&#34;
    Returns a normalized Gaussian.
    &#34;&#34;&#34;
    if sigma &lt;= 0:
        raise ValueError(
            f&#39;Invalid parameter: sigma = {sigma}&#39;
        )

    return np.exp(-(x - mu)**2 / 2 / sigma**2) / sigma / np.sqrt(2 * np.pi)



def get_chisq(
    sigma : float = 1,
    df : int = 2,
):
    r&#34;&#34;&#34;
    Returns \(\Delta \chi^2\).
    To obtain the scaling coefficient \(\alpha\), just take the square root of the output.

    Parameters
    ----------
    sigma : float, default = 1
        the error on the parameter

    df : int, default = 2
        the number of degrees of freedom

    Returns
    -------
    float
    &#34;&#34;&#34;
    return chi2.ppf(norm.cdf(sigma) - norm.cdf(-sigma), df=df)



def add_plot_1d(
    fiducial : float,
    sigma : float,
    ax : Axes,
    **kwargs,
):
    &#34;&#34;&#34;
    Adds a 1D Gaussian with marginalized constraints `sigma` close to fiducial
    value `fiducial` to axis `ax`.
    &#34;&#34;&#34;
    x = np.linspace(
        fiducial - 4 * sigma,
        fiducial + 4 * sigma,
        100,
    )

    temp = ax.plot(
        x,
        [gaussian(_, mu=fiducial, sigma=sigma) for _ in x],
        **kwargs,
    )

    return temp</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fitk.fisher_plotter.add_plot_1d"><code class="name flex">
<span>def <span class="ident">add_plot_1d</span></span>(<span>fiducial: float, sigma: float, ax: Axes, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a 1D Gaussian with marginalized constraints <code>sigma</code> close to fiducial
value <code>fiducial</code> to axis <code>ax</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_plot_1d(
    fiducial : float,
    sigma : float,
    ax : Axes,
    **kwargs,
):
    &#34;&#34;&#34;
    Adds a 1D Gaussian with marginalized constraints `sigma` close to fiducial
    value `fiducial` to axis `ax`.
    &#34;&#34;&#34;
    x = np.linspace(
        fiducial - 4 * sigma,
        fiducial + 4 * sigma,
        100,
    )

    temp = ax.plot(
        x,
        [gaussian(_, mu=fiducial, sigma=sigma) for _ in x],
        **kwargs,
    )

    return temp</code></pre>
</details>
</dd>
<dt id="fitk.fisher_plotter.gaussian"><code class="name flex">
<span>def <span class="ident">gaussian</span></span>(<span>x: float, mu: float = 0, sigma: float = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a normalized Gaussian.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gaussian(
    x : float,
    mu : float = 0,
    sigma : float = 1,
):
    &#34;&#34;&#34;
    Returns a normalized Gaussian.
    &#34;&#34;&#34;
    if sigma &lt;= 0:
        raise ValueError(
            f&#39;Invalid parameter: sigma = {sigma}&#39;
        )

    return np.exp(-(x - mu)**2 / 2 / sigma**2) / sigma / np.sqrt(2 * np.pi)</code></pre>
</details>
</dd>
<dt id="fitk.fisher_plotter.get_chisq"><code class="name flex">
<span>def <span class="ident">get_chisq</span></span>(<span>sigma: float = 1, df: int = 2)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <span><span class="MathJax_Preview">\Delta \chi^2</span><script type="math/tex">\Delta \chi^2</script></span>.
To obtain the scaling coefficient <span><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span>, just take the square root of the output.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sigma</code></strong> :&ensp;<code>float</code>, default <code>= 1</code></dt>
<dd>the error on the parameter</dd>
<dt><strong><code>df</code></strong> :&ensp;<code>int</code>, default <code>= 2</code></dt>
<dd>the number of degrees of freedom</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chisq(
    sigma : float = 1,
    df : int = 2,
):
    r&#34;&#34;&#34;
    Returns \(\Delta \chi^2\).
    To obtain the scaling coefficient \(\alpha\), just take the square root of the output.

    Parameters
    ----------
    sigma : float, default = 1
        the error on the parameter

    df : int, default = 2
        the number of degrees of freedom

    Returns
    -------
    float
    &#34;&#34;&#34;
    return chi2.ppf(norm.cdf(sigma) - norm.cdf(-sigma), df=df)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fitk.fisher_plotter.FisherBaseFigure"><code class="flex name class">
<span>class <span class="ident">FisherBaseFigure</span></span>
<span>(</span><span>figure: Figure, axes: Collection[Axes], names: Collection[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Constructor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figure</code></strong> :&ensp;<code>Figure</code></dt>
<dd>the figure plotted by <code><a title="fitk.fisher_plotter.FisherPlotter" href="#fitk.fisher_plotter.FisherPlotter">FisherPlotter</a></code></dd>
<dt><strong><code>axes</code></strong> :&ensp;<code>Collection[Axes]</code></dt>
<dd>the axes of the above figure</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>Collection[str]</code></dt>
<dd>the names of the parameters that are plotted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FisherBaseFigure(ABC):
    def __init__(
        self,
        figure : Figure,
        axes : Collection[Axes],
        names : Collection[str],
    ):
        &#34;&#34;&#34;
        Constructor.

        Parameters
        ----------
        figure : Figure
            the figure plotted by `FisherPlotter`

        axes : Collection[Axes]
            the axes of the above figure

        names : Collection[str]
            the names of the parameters that are plotted
        &#34;&#34;&#34;
        self._figure = figure
        self._axes = axes
        self._names = names


    @abstractmethod
    def __getitem__(self, key):
        &#34;&#34;&#34;
        Implements element access.
        &#34;&#34;&#34;
        pass


    @property
    def figure(self):
        &#34;&#34;&#34;
        Returns the underlying figure, an instance of `matplotlib.figure.Figure`.
        &#34;&#34;&#34;
        return self._figure


    @property
    def axes(self):
        &#34;&#34;&#34;
        Returns the axes of the figure as a numpy array.
        &#34;&#34;&#34;
        return self._axes


    @property
    def names(self):
        &#34;&#34;&#34;
        Returns the names of the parameters plotted.
        &#34;&#34;&#34;
        return self._names


    def savefig(
        self,
        path : str,
        dpi : float = 300,
        bbox_inches : Union[str, Bbox] = &#39;tight&#39;,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Convenience wrapper for `figure.savefig`.

        Parameters
        ----------
        path : str
            the path where to save the figure

        dpi : float, default = 300
            the resolution of the saved figure

        bbox_inches : Union[str, Bbox], default = &#39;tight&#39;
            what is the bounding box for the figure

        kwargs
            any other keyword arguments that should be passed to `figure.savefig`
        &#34;&#34;&#34;
        return self.figure.savefig(path, dpi=dpi, bbox_inches=bbox_inches, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fitk.fisher_plotter.FisherFigure1D" href="#fitk.fisher_plotter.FisherFigure1D">FisherFigure1D</a></li>
<li><a title="fitk.fisher_plotter.FisherFigure2D" href="#fitk.fisher_plotter.FisherFigure2D">FisherFigure2D</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fitk.fisher_plotter.FisherBaseFigure.axes"><code class="name">var <span class="ident">axes</span></code></dt>
<dd>
<div class="desc"><p>Returns the axes of the figure as a numpy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def axes(self):
    &#34;&#34;&#34;
    Returns the axes of the figure as a numpy array.
    &#34;&#34;&#34;
    return self._axes</code></pre>
</details>
</dd>
<dt id="fitk.fisher_plotter.FisherBaseFigure.figure"><code class="name">var <span class="ident">figure</span></code></dt>
<dd>
<div class="desc"><p>Returns the underlying figure, an instance of <code>matplotlib.figure.Figure</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def figure(self):
    &#34;&#34;&#34;
    Returns the underlying figure, an instance of `matplotlib.figure.Figure`.
    &#34;&#34;&#34;
    return self._figure</code></pre>
</details>
</dd>
<dt id="fitk.fisher_plotter.FisherBaseFigure.names"><code class="name">var <span class="ident">names</span></code></dt>
<dd>
<div class="desc"><p>Returns the names of the parameters plotted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def names(self):
    &#34;&#34;&#34;
    Returns the names of the parameters plotted.
    &#34;&#34;&#34;
    return self._names</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fitk.fisher_plotter.FisherBaseFigure.savefig"><code class="name flex">
<span>def <span class="ident">savefig</span></span>(<span>self, path: str, dpi: float = 300, bbox_inches: Union[str, Bbox] = 'tight', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convenience wrapper for <code>figure.savefig</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>the path where to save the figure</dd>
<dt><strong><code>dpi</code></strong> :&ensp;<code>float</code>, default <code>= 300</code></dt>
<dd>the resolution of the saved figure</dd>
<dt><strong><code>bbox_inches</code></strong> :&ensp;<code>Union[str, Bbox]</code>, default <code>= 'tight'</code></dt>
<dd>what is the bounding box for the figure</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>any other keyword arguments that should be passed to <code>figure.savefig</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savefig(
    self,
    path : str,
    dpi : float = 300,
    bbox_inches : Union[str, Bbox] = &#39;tight&#39;,
    **kwargs,
):
    &#34;&#34;&#34;
    Convenience wrapper for `figure.savefig`.

    Parameters
    ----------
    path : str
        the path where to save the figure

    dpi : float, default = 300
        the resolution of the saved figure

    bbox_inches : Union[str, Bbox], default = &#39;tight&#39;
        what is the bounding box for the figure

    kwargs
        any other keyword arguments that should be passed to `figure.savefig`
    &#34;&#34;&#34;
    return self.figure.savefig(path, dpi=dpi, bbox_inches=bbox_inches, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="fitk.fisher_plotter.FisherFigure1D"><code class="flex name class">
<span>class <span class="ident">FisherFigure1D</span></span>
<span>(</span><span>figure: Figure, axes: Collection[Axes], names: Collection[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Container for easy access to elements in the 1D plot.</p>
<p>Constructor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figure</code></strong> :&ensp;<code>Figure</code></dt>
<dd>the figure plotted by <code><a title="fitk.fisher_plotter.FisherPlotter" href="#fitk.fisher_plotter.FisherPlotter">FisherPlotter</a></code></dd>
<dt><strong><code>axes</code></strong> :&ensp;<code>Collection[Axes]</code></dt>
<dd>the axes of the above figure</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>Collection[str]</code></dt>
<dd>the names of the parameters that are plotted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FisherFigure1D(FisherBaseFigure):
    &#34;&#34;&#34;
    Container for easy access to elements in the 1D plot.
    &#34;&#34;&#34;
    def __getitem__(
        self,
        key : str,
    ):
        &#34;&#34;&#34;
        Returns the axis associated to the name `key`.
        &#34;&#34;&#34;
        if key not in self.names:
            raise ParameterNotFoundError(key, self.names)

        return self.axes.flat[np.where(self.names == key)][0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fitk.fisher_plotter.FisherBaseFigure" href="#fitk.fisher_plotter.FisherBaseFigure">FisherBaseFigure</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fitk.fisher_plotter.FisherBaseFigure" href="#fitk.fisher_plotter.FisherBaseFigure">FisherBaseFigure</a></b></code>:
<ul class="hlist">
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.axes" href="#fitk.fisher_plotter.FisherBaseFigure.axes">axes</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.figure" href="#fitk.fisher_plotter.FisherBaseFigure.figure">figure</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.names" href="#fitk.fisher_plotter.FisherBaseFigure.names">names</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.savefig" href="#fitk.fisher_plotter.FisherBaseFigure.savefig">savefig</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fitk.fisher_plotter.FisherFigure2D"><code class="flex name class">
<span>class <span class="ident">FisherFigure2D</span></span>
<span>(</span><span>figure: Figure, axes: Collection[Axes], names: Collection[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Container for easy access to elements in the 2D plot.</p>
<p>Constructor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>figure</code></strong> :&ensp;<code>Figure</code></dt>
<dd>the figure plotted by <code><a title="fitk.fisher_plotter.FisherPlotter" href="#fitk.fisher_plotter.FisherPlotter">FisherPlotter</a></code></dd>
<dt><strong><code>axes</code></strong> :&ensp;<code>Collection[Axes]</code></dt>
<dd>the axes of the above figure</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>Collection[str]</code></dt>
<dd>the names of the parameters that are plotted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FisherFigure2D(FisherBaseFigure):
    &#34;&#34;&#34;
    Container for easy access to elements in the 2D plot.
    &#34;&#34;&#34;
    def __getitem__(
        self,
        key : Tuple[str],
    ):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fitk.fisher_plotter.FisherBaseFigure" href="#fitk.fisher_plotter.FisherBaseFigure">FisherBaseFigure</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fitk.fisher_plotter.FisherBaseFigure" href="#fitk.fisher_plotter.FisherBaseFigure">FisherBaseFigure</a></b></code>:
<ul class="hlist">
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.axes" href="#fitk.fisher_plotter.FisherBaseFigure.axes">axes</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.figure" href="#fitk.fisher_plotter.FisherBaseFigure.figure">figure</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.names" href="#fitk.fisher_plotter.FisherBaseFigure.names">names</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.savefig" href="#fitk.fisher_plotter.FisherBaseFigure.savefig">savefig</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fitk.fisher_plotter.FisherPlotter"><code class="flex name class">
<span>class <span class="ident">FisherPlotter</span></span>
<span>(</span><span>*args: FisherMatrix, labels: Optional[Collection[str]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for plotting FisherMatrix objects.</p>
<p>Constructor.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>FisherMatrix</code></dt>
<dd><code>FisherMatrix</code> objects which we want to plot.
Must have the same names, otherwise throws an error.
Can have different fiducial values.
The order of plotting of the parameters and the LaTeX labels to use
are determined by the first argument.</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>array</code> of <code>strings</code>, default <code>None</code></dt>
<dd>the list of labels to put in the legend of the plots.
If not set, defaults to <code>0, ..., len(args) - 1</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FisherPlotter:
    &#34;&#34;&#34;
    Class for plotting FisherMatrix objects.
    &#34;&#34;&#34;
    def __init__(
        self,
        *args : FisherMatrix,
        labels : Optional[Collection[str]] = None,
    ):
        &#34;&#34;&#34;
        Constructor.

        Parameters
        ----------
        args : FisherMatrix
            `FisherMatrix` objects which we want to plot.
            Must have the same names, otherwise throws an error.
            Can have different fiducial values.
            The order of plotting of the parameters and the LaTeX labels to use
            are determined by the first argument.

        labels : array of strings, default None
            the list of labels to put in the legend of the plots.
            If not set, defaults to `0, ..., len(args) - 1`
        &#34;&#34;&#34;
        # make sure all of the Fisher objects have the same sizes
        if not all(len(args[0]) == len(arg) for arg in args):
            raise MismatchingSizeError(*args)

        # check names
        if not all(set(args[0].names) == set(arg.names) for arg in args):
            raise ValueError(
                &#39;The names of the inputs do not match&#39;
            )

        if labels is not None:
            if len(labels) != len(args):
                raise MismatchingSizeError(labels, args)
        else:
            labels = list(map(str, np.arange(len(args))))

        # in case the names are shuffled, we sort them according to the FIRST
        # input
        indices = np.array(
            [get_index_of_other_array(args[0].names, arg.names) for arg in args],
            dtype=object,
        )

        self._values = [arg.sort(key=index) for index, arg in zip(indices, args)]

        self._labels = np.array(labels, dtype=object)


    @property
    def values(self):
        &#34;&#34;&#34;
        Returns the input array of Fisher objects.
        &#34;&#34;&#34;
        return self._values


    @property
    def labels(self):
        &#34;&#34;&#34;
        Returns the labels of the Fisher objects.
        &#34;&#34;&#34;
        return self._labels


    def find_limits_1d(
        self,
        name : str,
        sigma : float = 3,
    ):
        &#34;&#34;&#34;
        Finds &#34;nice&#34; 1D limits for a given parameter taking into account fiducials
        and constraints.

        Parameters
        ----------
        name : str
            the name of the parameter

        sigma : float, default = 3
            how many sigmas away to plot

        Returns
        -------
        `tuple` with lower and upper limits
        &#34;&#34;&#34;
        sigmas = np.array(
            [_.constraints(name, marginalized=True, sigma=sigma) for _ in self.values]
        )
        fiducial = np.array(
            [_.fiducial[np.where(_.names == name)] for _ in self.values]
        )

        xleft, xright = np.min(fiducial - sigmas), np.max(fiducial + sigmas)

        return xleft, xright


    def plot_1d(
        self,
        max_cols : Optional[int] = None,
        rc : dict = get_default_rcparams(),
        **kwargs,
    ):
        &#34;&#34;&#34;
        Makes a 1D plot (Gaussians) of the Fisher objects and returns a
        `FisherFigure1D`.

        Parameters
        ----------
        max_cols : Optional[int], default = None
            the maximum number of columns to force the plot into.
            By default, the parameters are always plotted horizontally; if you
            need to spread it over `max_cols`, pass a non-negative integer
            here.

        rc : dict = get_default_rcparams()
            any parameters meant for `matplotlib.rcParams`.
            See [Matplotlib documentation](https://matplotlib.org/stable/tutorials/introductory/customizing.html)
            for more information.

        Returns
        -------
        An instance of `FisherFigure1D`.
        &#34;&#34;&#34;
        size = len(self.values[0])

        if max_cols is not None and max_cols &lt;= size:
            full = size % max_cols == 0
            layout = size // max_cols if full else size // max_cols + 1, max_cols
        else:
            layout = 1, size
            full = True

        with plt.rc_context(rc):
            # general figure setup
            fig = plt.figure(clear=True, figsize=(2 * layout[1], 2 * layout[0]))
            gs = fig.add_gridspec(
                nrows=layout[0], ncols=layout[1],
                hspace=0.5, wspace=0.1,
            )
            axes = gs.subplots()
            if size == 1:
                axes = np.array([axes])

            names = self.values[0].names
            latex_names = self.values[0].latex_names

            ylabel1d = r&#39;$p (\theta)$&#39;

            handles = []

            for (index, name), name_latex in zip(enumerate(names), latex_names):
                ax = axes.flat[index]
                title_list = [
                    &#39;{0} = ${1}^{{+{2}}}_{{-{2}}}$&#39;.format(
                    name_latex,
                    float_to_latex(float(_.fiducial[np.where(_.names == name)])),
                    float_to_latex(float(_.constraints(name, marginalized=True))),
                ) for _ in self.values
                ]

                # the scaling factor here is so that we don&#39;t cutoff the peak
                ymax = np.max(
                    [gaussian(0, 0, _.constraints(name, marginalized=True)) for _ in self.values]
                ) * 1.03

                for fm in self.values:
                    handle, = add_plot_1d(
                        fm.fiducial[np.where(fm.names == name)],
                        fm.constraints(name, marginalized=True),
                        ax,
                    )

                    if index == 0:
                        handles.append(handle)

                ax.set_xlabel(name_latex)
                ax.set_xlim(*self.find_limits_1d(name))
                ax.set_ylim(0, ymax)

                if kwargs.get(&#39;title&#39;) is True:
                    ax.set_title(&#39;\n&#39;.join(title_list))

                if index == 0:
                    ax.set_ylabel(ylabel1d)

                ax.set_yticks([])

            if kwargs.get(&#39;legend&#39;) is True:
                fig.legend(
                    np.array(handles, dtype=object),
                    self.labels,
                    frameon=False,
                    loc=&#39;upper center&#39;,
                    bbox_to_anchor=(0.5, -0.15),
                    ncol=len(self.values),
                )

            if isinstance(kwargs.get(&#39;title&#39;), str):
                fig.suptitle(kwargs.get(&#39;title&#39;))

            # remove any axes which are not drawn
            if not full:
                for index in range(
                    (layout[0] - 1) * layout[1] + 1,
                    layout[0] * layout[1]
                ):
                    axes.flat[index].remove()

        return FisherFigure1D(fig, axes, names)


    def plot_2d(
        self,
        rc : dict = get_default_rcparams(),
        **kwargs,
    ):
        &#34;&#34;&#34;
        Plots the 2D ellipses (and optionally 1D Gaussians) of the Fisher
        objects, and returns an instance of `FisherFigure2D`.
        &#34;&#34;&#34;
        pass


    def plot_triangle(
        self,
        **kwargs,
    ):
        &#34;&#34;&#34;
        Plots the 2D ellipses and 1D Gaussians of the Fisher objects, and
        returns an instance of `FisherFigure2D`.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="fitk.fisher_plotter.FisherPlotter.labels"><code class="name">var <span class="ident">labels</span></code></dt>
<dd>
<div class="desc"><p>Returns the labels of the Fisher objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def labels(self):
    &#34;&#34;&#34;
    Returns the labels of the Fisher objects.
    &#34;&#34;&#34;
    return self._labels</code></pre>
</details>
</dd>
<dt id="fitk.fisher_plotter.FisherPlotter.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<div class="desc"><p>Returns the input array of Fisher objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self):
    &#34;&#34;&#34;
    Returns the input array of Fisher objects.
    &#34;&#34;&#34;
    return self._values</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fitk.fisher_plotter.FisherPlotter.find_limits_1d"><code class="name flex">
<span>def <span class="ident">find_limits_1d</span></span>(<span>self, name: str, sigma: float = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds "nice" 1D limits for a given parameter taking into account fiducials
and constraints.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the parameter</dd>
<dt><strong><code>sigma</code></strong> :&ensp;<code>float</code>, default <code>= 3</code></dt>
<dd>how many sigmas away to plot</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> with lower and upper limits</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_limits_1d(
    self,
    name : str,
    sigma : float = 3,
):
    &#34;&#34;&#34;
    Finds &#34;nice&#34; 1D limits for a given parameter taking into account fiducials
    and constraints.

    Parameters
    ----------
    name : str
        the name of the parameter

    sigma : float, default = 3
        how many sigmas away to plot

    Returns
    -------
    `tuple` with lower and upper limits
    &#34;&#34;&#34;
    sigmas = np.array(
        [_.constraints(name, marginalized=True, sigma=sigma) for _ in self.values]
    )
    fiducial = np.array(
        [_.fiducial[np.where(_.names == name)] for _ in self.values]
    )

    xleft, xright = np.min(fiducial - sigmas), np.max(fiducial + sigmas)

    return xleft, xright</code></pre>
</details>
</dd>
<dt id="fitk.fisher_plotter.FisherPlotter.plot_1d"><code class="name flex">
<span>def <span class="ident">plot_1d</span></span>(<span>self, max_cols: Optional[int] = None, rc: dict = {'mathtext.fontset': 'cm', 'font.family': 'serif'}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a 1D plot (Gaussians) of the Fisher objects and returns a
<code><a title="fitk.fisher_plotter.FisherFigure1D" href="#fitk.fisher_plotter.FisherFigure1D">FisherFigure1D</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>max_cols</code></strong> :&ensp;<code>Optional[int]</code>, default <code>= None</code></dt>
<dd>the maximum number of columns to force the plot into.
By default, the parameters are always plotted horizontally; if you
need to spread it over <code>max_cols</code>, pass a non-negative integer
here.</dd>
<dt><strong><code>rc</code></strong> :&ensp;<code>dict = get_default_rcparams()</code></dt>
<dd>any parameters meant for <code>matplotlib.rcParams</code>.
See <a href="https://matplotlib.org/stable/tutorials/introductory/customizing.html">Matplotlib documentation</a>
for more information.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An instance of <code><a title="fitk.fisher_plotter.FisherFigure1D" href="#fitk.fisher_plotter.FisherFigure1D">FisherFigure1D</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_1d(
    self,
    max_cols : Optional[int] = None,
    rc : dict = get_default_rcparams(),
    **kwargs,
):
    &#34;&#34;&#34;
    Makes a 1D plot (Gaussians) of the Fisher objects and returns a
    `FisherFigure1D`.

    Parameters
    ----------
    max_cols : Optional[int], default = None
        the maximum number of columns to force the plot into.
        By default, the parameters are always plotted horizontally; if you
        need to spread it over `max_cols`, pass a non-negative integer
        here.

    rc : dict = get_default_rcparams()
        any parameters meant for `matplotlib.rcParams`.
        See [Matplotlib documentation](https://matplotlib.org/stable/tutorials/introductory/customizing.html)
        for more information.

    Returns
    -------
    An instance of `FisherFigure1D`.
    &#34;&#34;&#34;
    size = len(self.values[0])

    if max_cols is not None and max_cols &lt;= size:
        full = size % max_cols == 0
        layout = size // max_cols if full else size // max_cols + 1, max_cols
    else:
        layout = 1, size
        full = True

    with plt.rc_context(rc):
        # general figure setup
        fig = plt.figure(clear=True, figsize=(2 * layout[1], 2 * layout[0]))
        gs = fig.add_gridspec(
            nrows=layout[0], ncols=layout[1],
            hspace=0.5, wspace=0.1,
        )
        axes = gs.subplots()
        if size == 1:
            axes = np.array([axes])

        names = self.values[0].names
        latex_names = self.values[0].latex_names

        ylabel1d = r&#39;$p (\theta)$&#39;

        handles = []

        for (index, name), name_latex in zip(enumerate(names), latex_names):
            ax = axes.flat[index]
            title_list = [
                &#39;{0} = ${1}^{{+{2}}}_{{-{2}}}$&#39;.format(
                name_latex,
                float_to_latex(float(_.fiducial[np.where(_.names == name)])),
                float_to_latex(float(_.constraints(name, marginalized=True))),
            ) for _ in self.values
            ]

            # the scaling factor here is so that we don&#39;t cutoff the peak
            ymax = np.max(
                [gaussian(0, 0, _.constraints(name, marginalized=True)) for _ in self.values]
            ) * 1.03

            for fm in self.values:
                handle, = add_plot_1d(
                    fm.fiducial[np.where(fm.names == name)],
                    fm.constraints(name, marginalized=True),
                    ax,
                )

                if index == 0:
                    handles.append(handle)

            ax.set_xlabel(name_latex)
            ax.set_xlim(*self.find_limits_1d(name))
            ax.set_ylim(0, ymax)

            if kwargs.get(&#39;title&#39;) is True:
                ax.set_title(&#39;\n&#39;.join(title_list))

            if index == 0:
                ax.set_ylabel(ylabel1d)

            ax.set_yticks([])

        if kwargs.get(&#39;legend&#39;) is True:
            fig.legend(
                np.array(handles, dtype=object),
                self.labels,
                frameon=False,
                loc=&#39;upper center&#39;,
                bbox_to_anchor=(0.5, -0.15),
                ncol=len(self.values),
            )

        if isinstance(kwargs.get(&#39;title&#39;), str):
            fig.suptitle(kwargs.get(&#39;title&#39;))

        # remove any axes which are not drawn
        if not full:
            for index in range(
                (layout[0] - 1) * layout[1] + 1,
                layout[0] * layout[1]
            ):
                axes.flat[index].remove()

    return FisherFigure1D(fig, axes, names)</code></pre>
</details>
</dd>
<dt id="fitk.fisher_plotter.FisherPlotter.plot_2d"><code class="name flex">
<span>def <span class="ident">plot_2d</span></span>(<span>self, rc: dict = {'mathtext.fontset': 'cm', 'font.family': 'serif'}, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the 2D ellipses (and optionally 1D Gaussians) of the Fisher
objects, and returns an instance of <code><a title="fitk.fisher_plotter.FisherFigure2D" href="#fitk.fisher_plotter.FisherFigure2D">FisherFigure2D</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_2d(
    self,
    rc : dict = get_default_rcparams(),
    **kwargs,
):
    &#34;&#34;&#34;
    Plots the 2D ellipses (and optionally 1D Gaussians) of the Fisher
    objects, and returns an instance of `FisherFigure2D`.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="fitk.fisher_plotter.FisherPlotter.plot_triangle"><code class="name flex">
<span>def <span class="ident">plot_triangle</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the 2D ellipses and 1D Gaussians of the Fisher objects, and
returns an instance of <code><a title="fitk.fisher_plotter.FisherFigure2D" href="#fitk.fisher_plotter.FisherFigure2D">FisherFigure2D</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_triangle(
    self,
    **kwargs,
):
    &#34;&#34;&#34;
    Plots the 2D ellipses and 1D Gaussians of the Fisher objects, and
    returns an instance of `FisherFigure2D`.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fitk" href="index.html">fitk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fitk.fisher_plotter.add_plot_1d" href="#fitk.fisher_plotter.add_plot_1d">add_plot_1d</a></code></li>
<li><code><a title="fitk.fisher_plotter.gaussian" href="#fitk.fisher_plotter.gaussian">gaussian</a></code></li>
<li><code><a title="fitk.fisher_plotter.get_chisq" href="#fitk.fisher_plotter.get_chisq">get_chisq</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fitk.fisher_plotter.FisherBaseFigure" href="#fitk.fisher_plotter.FisherBaseFigure">FisherBaseFigure</a></code></h4>
<ul class="">
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.axes" href="#fitk.fisher_plotter.FisherBaseFigure.axes">axes</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.figure" href="#fitk.fisher_plotter.FisherBaseFigure.figure">figure</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.names" href="#fitk.fisher_plotter.FisherBaseFigure.names">names</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherBaseFigure.savefig" href="#fitk.fisher_plotter.FisherBaseFigure.savefig">savefig</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fitk.fisher_plotter.FisherFigure1D" href="#fitk.fisher_plotter.FisherFigure1D">FisherFigure1D</a></code></h4>
</li>
<li>
<h4><code><a title="fitk.fisher_plotter.FisherFigure2D" href="#fitk.fisher_plotter.FisherFigure2D">FisherFigure2D</a></code></h4>
</li>
<li>
<h4><code><a title="fitk.fisher_plotter.FisherPlotter" href="#fitk.fisher_plotter.FisherPlotter">FisherPlotter</a></code></h4>
<ul class="two-column">
<li><code><a title="fitk.fisher_plotter.FisherPlotter.find_limits_1d" href="#fitk.fisher_plotter.FisherPlotter.find_limits_1d">find_limits_1d</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherPlotter.labels" href="#fitk.fisher_plotter.FisherPlotter.labels">labels</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherPlotter.plot_1d" href="#fitk.fisher_plotter.FisherPlotter.plot_1d">plot_1d</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherPlotter.plot_2d" href="#fitk.fisher_plotter.FisherPlotter.plot_2d">plot_2d</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherPlotter.plot_triangle" href="#fitk.fisher_plotter.FisherPlotter.plot_triangle">plot_triangle</a></code></li>
<li><code><a title="fitk.fisher_plotter.FisherPlotter.values" href="#fitk.fisher_plotter.FisherPlotter.values">values</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>